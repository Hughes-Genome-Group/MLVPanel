/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./test.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/bam.js":
/*!********************!*\
  !*** ./src/bam.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Zlib) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.PairedAlignment = exports.BamAlignment = exports.BamFilter = exports.BamSource = exports.BamReader = exports.loadBamIndex = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _igvxhr = __webpack_require__(/*! ./igvxhr.js */ \"./src/igvxhr.js\");\n\nvar _bigwig = __webpack_require__(/*! ./bigwig.js */ \"./src/bigwig.js\");\n\nvar _inflate = __webpack_require__(/*! ./vendor/inflate.js */ \"./src/vendor/inflate.js\");\n\nvar _feature = __webpack_require__(/*! ./feature.js */ \"./src/feature.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BAI_MAGIC = 21578050;\nvar TABIX_MAGIC = 21578324;\nvar MAX_HEADER_SIZE = 100000000; // IF the header is larger than this we can't read it !\nvar B_MAX_GZIP_BLOCK_SIZE = 1 << 16;\n\n/**\r\n * @param indexURL\r\n * @param config\r\n * @param tabix\r\n *\r\n * @returns a Promised for the bam or tabix index.  The fulfill function takes the index as an argument.\r\n */\nvar loadBamIndex = function loadBamIndex(indexURL, config, tabix) {\n\n    return new Promise(function (fulfill, reject) {\n\n        var genome = null;\n\n        _igvxhr.igvxhr.loadArrayBuffer(indexURL, {\n            headers: config.headers,\n            withCredentials: config.withCredentials\n        }).then(function (arrayBuffer) {\n\n            var indices = [],\n                magic,\n                nbin,\n                nintv,\n                nref,\n                parser,\n                blockMin = Number.MAX_VALUE,\n                blockMax = 0,\n                binIndex,\n                linearIndex,\n                binNumber,\n                cs,\n                ce,\n                b,\n                i,\n                ref,\n                sequenceIndexMap;\n\n            if (!arrayBuffer) {\n                fulfill(null);\n                return;\n            }\n\n            if (tabix) {\n                console.log(Zlib);\n                var inflate = new Zlib.Zlib.Gunzip(new Uint8Array(arrayBuffer));\n                arrayBuffer = inflate.decompress().buffer;\n\n                /*let r =pako.inflate(new Uint8Array(arrayBuffer));\r\n                   arrayBuffer =r.buffer;*/\n            }\n\n            parser = new _bigwig.BinaryParser(new DataView(arrayBuffer));\n\n            magic = parser.getInt();\n\n            if (magic === BAI_MAGIC || tabix && magic === TABIX_MAGIC) {\n\n                nref = parser.getInt();\n\n                if (tabix) {\n                    // Tabix header parameters aren't used, but they must be read to advance the pointer\n                    var format = parser.getInt();\n                    var col_seq = parser.getInt();\n                    var col_beg = parser.getInt();\n                    var col_end = parser.getInt();\n                    var meta = parser.getInt();\n                    var skip = parser.getInt();\n                    var l_nm = parser.getInt();\n\n                    sequenceIndexMap = {};\n                    for (i = 0; i < nref; i++) {\n                        var seq_name = parser.getString();\n\n                        // Translate to \"official\" chr name.\n                        if (genome) seq_name = genome.getChromosomeName(seq_name);\n\n                        sequenceIndexMap[seq_name] = i;\n                    }\n                }\n\n                for (ref = 0; ref < nref; ++ref) {\n\n                    binIndex = {};\n                    linearIndex = [];\n\n                    nbin = parser.getInt();\n\n                    for (b = 0; b < nbin; ++b) {\n\n                        binNumber = parser.getInt();\n\n                        if (binNumber == 37450) {\n                            // This is a psuedo bin, not used but we have to consume the bytes\n                            nchnk = parser.getInt(); // # of chunks for this bin\n                            cs = parser.getVPointer(); // unmapped beg\n                            ce = parser.getVPointer(); // unmapped end\n                            var n_maped = parser.getLong();\n                            var nUnmapped = parser.getLong();\n                        } else {\n\n                            binIndex[binNumber] = [];\n                            var nchnk = parser.getInt(); // # of chunks for this bin\n\n                            for (i = 0; i < nchnk; i++) {\n                                cs = parser.getVPointer();\n                                ce = parser.getVPointer();\n                                if (cs && ce) {\n                                    if (cs.block < blockMin) {\n                                        blockMin = cs.block; // Block containing first alignment\n                                    }\n                                    if (ce.block > blockMax) {\n                                        blockMax = ce.block;\n                                    }\n                                    binIndex[binNumber].push([cs, ce]);\n                                }\n                            }\n                        }\n                    }\n\n                    nintv = parser.getInt();\n                    for (i = 0; i < nintv; i++) {\n                        cs = parser.getVPointer();\n                        linearIndex.push(cs); // Might be null\n                    }\n\n                    if (nbin > 0) {\n                        indices[ref] = {\n                            binIndex: binIndex,\n                            linearIndex: linearIndex\n                        };\n                    }\n                }\n            } else {\n                throw new Error(indexURL + \" is not a \" + (tabix ? \"tabix\" : \"bai\") + \" file\");\n            }\n            fulfill(new BamIndex(indices, blockMin, sequenceIndexMap, tabix));\n        }).catch(reject);\n    });\n};\n\nvar BamIndex = function () {\n    function BamIndex(indices, blockMin, sequenceIndexMap, tabix) {\n        _classCallCheck(this, BamIndex);\n\n        this.firstAlignmentBlock = blockMin;\n        this.indices = indices;\n        this.sequenceIndexMap = sequenceIndexMap;\n        this.tabix = tabix;\n    }\n\n    /**\r\n     * Fetch blocks for a particular genomic range.  This method is public so it can be unit-tested.\r\n     *\r\n     * @param refId  the sequence dictionary index of the chromosome\r\n     * @param min  genomic start position\r\n     * @param max  genomic end position\r\n     * @param return an array of {minv: {filePointer, offset}, {maxv: {filePointer, offset}}\r\n     */\n\n\n    _createClass(BamIndex, [{\n        key: \"blocksForRange\",\n        value: function blocksForRange(refId, min, max) {\n\n            var bam = this,\n                ba = bam.indices[refId],\n                overlappingBins,\n                leafChunks,\n                otherChunks,\n                nintv,\n                lowest,\n                minLin,\n                maxLin,\n                lb,\n                prunedOtherChunks,\n                i,\n                chnk,\n                dif,\n                intChunks,\n                mergedChunks;\n\n            if (!ba) {\n                return [];\n            } else {\n\n                overlappingBins = BamIndex.reg2bins(min, max); // List of bin #s that might overlap min, max\n                leafChunks = [];\n                otherChunks = [];\n\n                overlappingBins.forEach(function (bin) {\n\n                    if (ba.binIndex[bin]) {\n                        var chunks = ba.binIndex[bin],\n                            nchnk = chunks.length;\n\n                        for (var c = 0; c < nchnk; ++c) {\n                            var cs = chunks[c][0];\n                            var ce = chunks[c][1];\n                            (bin < 4681 ? otherChunks : leafChunks).push({ minv: cs, maxv: ce, bin: bin });\n                        }\n                    }\n                });\n\n                // Use the linear index to find the lowest chunk that could contain alignments in the region\n                nintv = ba.linearIndex.length;\n                lowest = null;\n                minLin = Math.min(min >> 14, nintv - 1), maxLin = Math.min(max >> 14, nintv - 1);\n                for (i = minLin; i <= maxLin; ++i) {\n                    lb = ba.linearIndex[i];\n                    if (!lb) {\n                        continue;\n                    }\n                    if (!lowest || lb.block < lowest.block || lb.offset < lowest.offset) {\n                        lowest = lb;\n                    }\n                }\n\n                // Prune chunks that end before the lowest chunk\n                prunedOtherChunks = [];\n                if (lowest != null) {\n                    for (i = 0; i < otherChunks.length; ++i) {\n                        chnk = otherChunks[i];\n                        if (chnk.maxv.block > lowest.block || chnk.maxv.block == lowest.block && chnk.maxv.offset >= lowest.offset) {\n                            prunedOtherChunks.push(chnk);\n                        }\n                    }\n                }\n\n                intChunks = [];\n                for (i = 0; i < prunedOtherChunks.length; ++i) {\n                    intChunks.push(prunedOtherChunks[i]);\n                }\n                for (i = 0; i < leafChunks.length; ++i) {\n                    intChunks.push(leafChunks[i]);\n                }\n\n                intChunks.sort(function (c0, c1) {\n                    dif = c0.minv.block - c1.minv.block;\n                    if (dif != 0) {\n                        return dif;\n                    } else {\n                        return c0.minv.offset - c1.minv.offset;\n                    }\n                });\n\n                mergedChunks = [];\n                if (intChunks.length > 0) {\n                    var cur = intChunks[0];\n                    for (var i = 1; i < intChunks.length; ++i) {\n                        var nc = intChunks[i];\n                        if (nc.minv.block - cur.maxv.block < 65000) {\n                            // Merge blocks that are withing 65k of each other\n                            cur = { minv: cur.minv, maxv: nc.maxv };\n                        } else {\n                            mergedChunks.push(cur);\n                            cur = nc;\n                        }\n                    }\n                    mergedChunks.push(cur);\n                }\n                return mergedChunks;\n            }\n        }\n    }], [{\n        key: \"reg2bins\",\n\n\n        /**\r\n         * Calculate the list of bins that may overlap with region [beg, end]\r\n         *\r\n         */\n        value: function reg2bins(beg, end) {\n            var i = 0,\n                k,\n                list = [];\n            if (end >= 1 << 29) end = 1 << 29;\n            --end;\n            list.push(0);\n            for (k = 1 + (beg >> 26); k <= 1 + (end >> 26); ++k) {\n                list.push(k);\n            }for (k = 9 + (beg >> 23); k <= 9 + (end >> 23); ++k) {\n                list.push(k);\n            }for (k = 73 + (beg >> 20); k <= 73 + (end >> 20); ++k) {\n                list.push(k);\n            }for (k = 585 + (beg >> 17); k <= 585 + (end >> 17); ++k) {\n                list.push(k);\n            }for (k = 4681 + (beg >> 14); k <= 4681 + (end >> 14); ++k) {\n                list.push(k);\n            }return list;\n        }\n    }]);\n\n    return BamIndex;\n}();\n\nvar BGZFile = function () {\n    function BGZFile(config) {\n        _classCallCheck(this, BGZFile);\n\n        this.filePosition = 0;\n        this.config = config;\n    }\n\n    _createClass(BGZFile, [{\n        key: \"nextBlock\",\n        value: function nextBlock() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                _igvxhr.igvxhr.loadArrayBuffer(self.path, {\n                    headers: self.config.headers,\n                    range: { start: self.filePosition, size: BLOCK_HEADER_LENGTH },\n                    withCredentials: self.config.withCredentials\n\n                }).then(function (arrayBuffer) {\n\n                    var ba = new Uint8Array(arrayBuffer);\n                    var xlen = ba[11] << 8 | ba[10];\n                    var si1 = ba[12];\n                    var si2 = ba[13];\n                    var slen = ba[15] << 8 | ba[14];\n                    var bsize = ba[17] << 8 | ba[16] + 1;\n\n                    self.filePosition += BLOCK_HEADER_LENGTH;\n\n                    _igvxhr.igvxhr.loadArrayBuffer(self.path, {\n                        headers: self.config.headers,\n                        range: { start: self.filePosition, size: bsize },\n                        withCredentials: self.config.withCredentials\n\n                    }).then(function (arrayBuffer) {\n\n                        var unc = (0, _inflate.jszlib_inflate_buffer)(arrayBuffer);\n\n                        self.filePosition += bsize + 8; // \"8\" for CRC-32 and size of uncompressed data\n\n                        fulfill(unc);\n                    }).catch(reject);\n                }).catch(reject);\n            });\n        }\n    }]);\n\n    return BGZFile;\n}();\n\nvar BAM_MAGIC = 21840194;\nvar SECRET_DECODER = ['=', 'A', 'C', 'x', 'G', 'x', 'x', 'x', 'T', 'x', 'x', 'x', 'x', 'x', 'x', 'N'];\nvar CIGAR_DECODER = ['M', 'I', 'D', 'N', 'S', 'H', 'P', '=', 'X', '?', '?', '?', '?', '?', '?', '?'];\nvar READ_STRAND_FLAG = 0x10;\nvar MATE_STRAND_FLAG = 0x20;\nvar FIRST_OF_PAIR_FLAG = 0x40;\nvar SECOND_OF_PAIR_FLAG = 0x80;\nvar READ_UNMAPPED_FLAG = 0x4;\nvar MATE_UNMAPPED_FLAG = 0x8;\nvar READ_PAIRED_FLAG = 0x1;\nvar PROPER_PAIR_FLAG = 0x2;\nvar SECONDARY_ALIGNMNET_FLAG = 0x100;\nvar SUPPLEMENTARY_ALIGNMENT_FLAG = 0x800;\n\nvar NOT_PRIMARY_ALIGNMENT_FLAG = 0x100;\nvar READ_FAILS_VENDOR_QUALITY_CHECK_FLAG = 0x200;\nvar DUPLICATE_READ_FLAG = 0x400;\nvar SUPPLEMENTARY_FLAG = 0x800;\n\nvar MAX_GZIP_BLOCK_SIZE = 65536; //  APPARENTLY.  Where is this documented???\nvar DEFAULT_SAMPLING_WINDOW_SIZE = 100;\nvar DEFAULT_SAMPLING_DEPTH = 50;\nvar MAXIMUM_SAMPLING_DEPTH = 2500;\n\n/**\r\n * Class for reading a bam file\r\n *\r\n * @param config\r\n * @constructor\r\n */\n\nvar BamReader = function () {\n    function BamReader(config) {\n        _classCallCheck(this, BamReader);\n\n        this.config = config;\n\n        this.filter = config.filter || new BamFilter();\n\n        this.bamPath = config.url;\n        // Todo - deal with Picard convention.  WHY DOES THERE HAVE TO BE 2?\n        this.baiPath = config.indexURL || this.bamPath + \".bai\"; // If there is an indexURL provided, use it!\n        this.headPath = config.headURL || this.bamPath;\n\n        this.samplingWindowSize = config.samplingWindowSize === undefined ? DEFAULT_SAMPLING_WINDOW_SIZE : config.samplingWindowSize;\n        this.samplingDepth = config.samplingDepth === undefined ? DEFAULT_SAMPLING_DEPTH : config.samplingDepth;\n        if (this.samplingDepth > MAXIMUM_SAMPLING_DEPTH) {\n            igv.log(\"Warning: attempt to set sampling depth > maximum value of 2500\");\n            this.samplingDepth = MAXIMUM_SAMPLING_DEPTH;\n        }\n\n        if (config.viewAsPairs) {\n            this.pairsSupported = true;\n        } else {\n            this.pairsSupported = config.pairsSupported === undefined ? true : config.pairsSupported;\n        }\n    }\n\n    _createClass(BamReader, [{\n        key: \"readAlignments\",\n        value: function readAlignments(chr, bpStart, bpEnd) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                getChrIndex(self).then(function (chrToIndex) {\n\n                    var chrId = chrToIndex[chr],\n                        alignmentContainer = new AlignmentContainer(chr, bpStart, bpEnd, self.samplingWindowSize, self.samplingDepth, self.pairsSupported);\n                    chrId = 11;\n                    if (chrId === undefined) {\n                        fulfill(alignmentContainer);\n                    } else {\n\n                        getIndex(self).then(function (bamIndex) {\n\n                            var chunks = bamIndex.blocksForRange(chrId, bpStart, bpEnd),\n                                promises = [];\n\n                            if (!chunks) {\n                                fulfill(null);\n                                reject(\"Error reading bam index\");\n                                return;\n                            }\n                            if (chunks.length === 0) {\n                                fulfill(alignmentContainer);\n                                return;\n                            }\n\n                            chunks.forEach(function (c) {\n\n                                promises.push(new Promise(function (fulfill, reject) {\n\n                                    var fetchMin = c.minv.block,\n                                        fetchMax = c.maxv.block + MAX_GZIP_BLOCK_SIZE,\n                                        // Make sure we get the whole block.\n                                    range = { start: fetchMin, size: fetchMax - fetchMin + 1 };\n\n                                    _igvxhr.igvxhr.loadArrayBuffer(self.bamPath, {\n                                        headers: self.config.headers,\n                                        range: range,\n                                        withCredentials: self.config.withCredentials\n                                    }).then(function (compressed) {\n\n                                        var ba = new Uint8Array(new unbgzf(compressed)); //new Uint8Array(igv.unbgzf(compressed)); //, c.maxv.block - c.minv.block + 1));\n                                        decodeBamRecords(ba, c.minv.offset, alignmentContainer, bpStart, bpEnd, chrId, self.filter);\n\n                                        fulfill(alignmentContainer);\n                                    }).catch(function (obj) {\n                                        reject(obj);\n                                    });\n                                }));\n                            });\n\n                            Promise.all(promises).then(function (ignored) {\n                                alignmentContainer.finish();\n                                fulfill(alignmentContainer);\n                            }).catch(function (obj) {\n                                reject(obj);\n                            });\n                        }).catch(reject);\n                    }\n                }).catch(reject);\n            });\n\n            function decodeBamRecords(ba, offset, alignmentContainer, min, max, chrId, filter) {\n\n                var blockSize, blockEnd, alignment, blocks, refID, pos, bmn, bin, mq, nl, flag_nc, flag, nc, lseq, mateRefID, matePos, readName, j, p, lengthOnRef, cigar, c, cigarArray, seq, seqBytes;\n\n                while (true) {\n\n                    blockSize = readInt(ba, offset);\n                    blockEnd = offset + blockSize + 4;\n\n                    if (blockEnd > ba.length) {\n                        return;\n                    }\n\n                    alignment = new BamAlignment();\n\n                    refID = readInt(ba, offset + 4);\n                    pos = readInt(ba, offset + 8);\n\n                    if (refID < 0) {\n                        return; // unmapped reads\n                    } else if (refID > chrId || pos > max) {\n                        return; // off right edge, we're done\n                    } else if (refID < chrId) {\n                        continue; // to left of start, not sure this is possible\n                    }\n\n                    bmn = readInt(ba, offset + 12);\n                    bin = (bmn & 0xffff0000) >> 16;\n                    mq = (bmn & 0xff00) >> 8;\n                    nl = bmn & 0xff;\n\n                    flag_nc = readInt(ba, offset + 16);\n                    flag = (flag_nc & 0xffff0000) >> 16;\n                    nc = flag_nc & 0xffff;\n\n                    alignment.flags = flag;\n                    alignment.strand = !(flag & READ_STRAND_FLAG);\n\n                    lseq = readInt(ba, offset + 20);\n\n                    mateRefID = readInt(ba, offset + 24);\n                    matePos = readInt(ba, offset + 28);\n                    alignment.fragmentLength = readInt(ba, offset + 32);\n\n                    readName = '';\n                    for (j = 0; j < nl - 1; ++j) {\n                        readName += String.fromCharCode(ba[offset + 36 + j]);\n                    }\n\n                    p = offset + 36 + nl;\n\n                    lengthOnRef = 0;\n                    cigar = '';\n\n                    cigarArray = [];\n                    for (c = 0; c < nc; ++c) {\n                        var cigop = readInt(ba, p);\n                        var opLen = cigop >> 4;\n                        var opLtr = CIGAR_DECODER[cigop & 0xf];\n                        if (opLtr == 'M' || opLtr == 'EQ' || opLtr == 'X' || opLtr == 'D' || opLtr == 'N' || opLtr == '=') lengthOnRef += opLen;\n                        cigar = cigar + opLen + opLtr;\n                        p += 4;\n\n                        cigarArray.push({ len: opLen, ltr: opLtr });\n                    }\n                    alignment.cigar = cigar;\n                    alignment.lengthOnRef = lengthOnRef;\n\n                    if (alignment.start + alignment.lengthOnRef < min) continue; // Record out-of-range \"to the left\", skip to next one\n\n\n                    seq = '';\n                    seqBytes = lseq + 1 >> 1;\n                    for (j = 0; j < seqBytes; ++j) {\n                        var sb = ba[p + j];\n                        seq += SECRET_DECODER[(sb & 0xf0) >> 4];\n                        seq += SECRET_DECODER[sb & 0x0f];\n                    }\n                    seq = seq.substring(0, lseq); // seq might have one extra character (if lseq is an odd number)\n\n                    p += seqBytes;\n                    alignment.seq = seq;\n\n                    if (lseq === 1 && String.fromCharCode(ba[p + j] + 33) === \"*\") {\n                        // TODO == how to represent this?\n                    } else {\n                        alignment.qual = [];\n                        for (j = 0; j < lseq; ++j) {\n                            alignment.qual.push(ba[p + j]);\n                        }\n                    }\n                    p += lseq;\n\n                    alignment.start = pos;\n                    alignment.mq = mq;\n                    alignment.readName = readName;\n                    alignment.chr = self.indexToChr[refID];\n\n                    if (mateRefID >= 0) {\n                        alignment.mate = {\n                            chr: self.indexToChr[mateRefID],\n                            position: matePos,\n                            strand: !(flag & MATE_STRAND_FLAG)\n                        };\n                    }\n\n                    alignment.tagBA = new Uint8Array(ba.buffer.slice(p, blockEnd)); // decode thiese on demand\n                    p += blockEnd;\n\n                    if (!min || alignment.start <= max && alignment.start + alignment.lengthOnRef >= min && filter.pass(alignment)) {\n                        if (chrId === undefined || refID == chrId) {\n                            blocks = makeBlocks(alignment, cigarArray);\n                            alignment.blocks = blocks.blocks;\n                            alignment.insertions = blocks.insertions;\n                            alignmentContainer.push(alignment);\n                        }\n                    }\n                    offset = blockEnd;\n                }\n                // Exits via top of loop.\n            }\n\n            /**\r\n             * Split the alignment record into blocks as specified in the cigarArray.  Each aligned block contains\r\n             * its portion of the read sequence and base quality strings.  A read sequence or base quality string\r\n             * of \"*\" indicates the value is not recorded.  In all other cases the length of the block sequence (block.seq)\r\n             * and quality string (block.qual) must == the block length.\r\n             *\r\n             * NOTE: Insertions are not yet treated // TODO\r\n             *\r\n             * @param record\r\n             * @param cigarArray\r\n             * @returns array of blocks\r\n             */\n            function makeBlocks(record, cigarArray) {\n\n                var blocks = [],\n                    insertions,\n                    seqOffset = 0,\n                    pos = record.start,\n                    len = cigarArray.length,\n                    blockSeq,\n                    blockQuals,\n                    gapType,\n                    minQ = 5,\n                    //prefs.getAsInt(PreferenceManager.SAM_BASE_QUALITY_MIN)\n                maxQ = 20; //prefs.getAsInt(PreferenceManager.SAM_BASE_QUALITY_MAX)\n\n                for (var i = 0; i < len; i++) {\n\n                    var c = cigarArray[i];\n\n                    switch (c.ltr) {\n                        case 'H':\n                            break; // ignore hard clips\n                        case 'P':\n                            break; // ignore pads\n                        case 'S':\n                            seqOffset += c.len;\n                            gapType = 'S';\n                            break; // soft clip read bases\n                        case 'N':\n                            pos += c.len;\n                            gapType = 'N';\n                            break; // reference skip\n                        case 'D':\n                            pos += c.len;\n                            gapType = 'D';\n                            break;\n                        case 'I':\n                            blockSeq = record.seq === \"*\" ? \"*\" : record.seq.substr(seqOffset, c.len);\n                            blockQuals = record.qual ? record.qual.slice(seqOffset, c.len) : undefined;\n                            if (insertions === undefined) insertions = [];\n                            insertions.push({ start: pos, len: c.len, seq: blockSeq, qual: blockQuals });\n                            seqOffset += c.len;\n                            break;\n                        case 'M':\n                        case 'EQ':\n                        case '=':\n                        case 'X':\n\n                            blockSeq = record.seq === \"*\" ? \"*\" : record.seq.substr(seqOffset, c.len);\n                            blockQuals = record.qual ? record.qual.slice(seqOffset, c.len) : undefined;\n                            blocks.push({ start: pos, len: c.len, seq: blockSeq, qual: blockQuals, gapType: gapType });\n                            seqOffset += c.len;\n                            pos += c.len;\n\n                            break;\n\n                        default:\n                            console.log(\"Error processing cigar element: \" + c.len + c.ltr);\n                    }\n                }\n\n                return { blocks: blocks, insertions: insertions };\n            }\n        }\n    }, {\n        key: \"readHeader\",\n        value: function readHeader() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                getIndex(self).then(function (index) {\n\n                    var len = index.firstAlignmentBlock + MAX_GZIP_BLOCK_SIZE; // Insure we get the complete compressed block containing the header\n\n                    _igvxhr.igvxhr.loadArrayBuffer(self.bamPath, {\n                        headers: self.config.headers,\n\n                        range: { start: 0, size: len },\n\n                        withCredentials: self.config.withCredentials\n                    }).then(function (compressedBuffer) {\n\n                        var unc = new unbgzf(compressedBuffer, len),\n                            uncba = new Uint8Array(unc),\n                            magic = readInt(uncba, 0),\n                            samHeaderLen = readInt(uncba, 4),\n                            samHeader = '',\n                            genome = null;\n\n                        for (var i = 0; i < samHeaderLen; ++i) {\n                            samHeader += String.fromCharCode(uncba[i + 8]);\n                        }\n\n                        var nRef = readInt(uncba, samHeaderLen + 8);\n                        var p = samHeaderLen + 12;\n\n                        self.chrToIndex = {};\n                        self.indexToChr = [];\n                        for (var i = 0; i < nRef; ++i) {\n                            var lName = readInt(uncba, p);\n                            var name = '';\n                            for (var j = 0; j < lName - 1; ++j) {\n                                name += String.fromCharCode(uncba[p + 4 + j]);\n                            }\n                            var lRef = readInt(uncba, p + lName + 4);\n                            //dlog(name + ': ' + lRef);\n\n                            if (genome && genome.getChromosomeName) {\n                                name = genome.getChromosomeName(name);\n                            }\n\n                            self.chrToIndex[name] = i;\n                            self.indexToChr.push(name);\n\n                            p = p + 8 + lName;\n                        }\n\n                        fulfill();\n                    }).catch(reject);\n                }).catch(reject);\n            });\n        }\n    }]);\n\n    return BamReader;\n}();\n\nfunction getIndex(bam) {\n\n    return new Promise(function (fulfill, reject) {\n\n        if (bam.index) {\n            fulfill(bam.index);\n        } else {\n            loadBamIndex(bam.baiPath, bam.config).then(function (index) {\n                bam.index = index;\n\n                fulfill(bam.index);\n            }).catch(reject);\n        }\n    });\n}\n\nfunction getChrIndex(bam) {\n\n    return new Promise(function (fulfill, reject) {\n\n        if (bam.chrToIndex) {\n            fulfill(bam.chrToIndex);\n        } else {\n            bam.readHeader().then(function () {\n                fulfill(bam.chrToIndex);\n            }).catch(reject);\n        }\n    });\n}\n\nfunction readInt(ba, offset) {\n    return ba[offset + 3] << 24 | ba[offset + 2] << 16 | ba[offset + 1] << 8 | ba[offset];\n}\n\nfunction readShort(ba, offset) {\n    return ba[offset + 1] << 8 | ba[offset];\n}\n\nvar BamSource = function () {\n    function BamSource(config) {\n        _classCallCheck(this, BamSource);\n\n        this.config = config;\n        this.alignmentContainer = undefined;\n        this.maxRows = config.maxRows || 1000;\n        this.sequence_source = new _feature.FastaSequence(config.seq_url);\n\n        if (config.sourceType === \"ga4gh\") {\n            this.bamReader = new igv.Ga4ghAlignmentReader(config);\n        } else {\n            this.bamReader = new BamReader(config);\n        }\n\n        this.viewAsPairs = config.viewAsPairs;\n    }\n\n    _createClass(BamSource, [{\n        key: \"setViewAsPairs\",\n        value: function setViewAsPairs(bool) {\n            var self = this;\n\n            if (this.viewAsPairs !== bool) {\n                this.viewAsPairs = bool;\n                // TODO -- repair alignments\n                if (this.alignmentContainer) {\n                    var alignmentContainer = this.alignmentContainer,\n                        alignments;\n\n                    if (bool) {\n                        alignments = pairAlignments(alignmentContainer.packedAlignmentRows);\n                    } else {\n                        alignments = unpairAlignments(alignmentContainer.packedAlignmentRows);\n                    }\n                    alignmentContainer.packedAlignmentRows = packAlignmentRows(alignments, alignmentContainer.start, alignmentContainer.end, self.maxRows);\n                }\n            }\n        }\n    }, {\n        key: \"getAlignments\",\n        value: function getAlignments(chr, bpStart, bpEnd) {\n\n            var self = this;\n            return new Promise(function (fulfill, reject) {\n\n                if (self.alignmentContainer && self.alignmentContainer.contains(chr, bpStart, bpEnd)) {\n                    fulfill(self.alignmentContainer);\n                } else {\n\n                    self.bamReader.readAlignments(chr, bpStart, bpEnd).then(function (alignmentContainer) {\n\n                        var maxRows = self.config.maxRows || 500,\n                            alignments = alignmentContainer.alignments;\n\n                        if (!self.viewAsPairs) {\n                            alignments = unpairAlignments([{ alignments: alignments }]);\n                        }\n\n                        alignmentContainer.packedAlignmentRows = packAlignmentRows(alignments, alignmentContainer.start, alignmentContainer.end, maxRows);\n\n                        alignmentContainer.alignments = undefined; // Don't need to hold onto these anymore\n                        self.alignmentContainer = alignmentContainer;\n\n                        self.sequence_source.getSequence(alignmentContainer.chr, alignmentContainer.start, alignmentContainer.end).then(function (sequence) {\n\n                            if (sequence) {\n\n                                alignmentContainer.coverageMap.refSeq = sequence; // TODO -- fix this\n                                alignmentContainer.sequence = sequence; // TODO -- fix this\n\n\n                                fulfill(alignmentContainer);\n                            }\n                        }).catch(reject);\n                    }).catch(reject);\n                }\n            });\n        }\n    }]);\n\n    return BamSource;\n}();\n\nfunction pairAlignments(rows) {\n\n    var pairCache = {},\n        result = [];\n\n    rows.forEach(function (row) {\n\n        row.alignments.forEach(function (alignment) {\n\n            var pairedAlignment;\n\n            if (canBePaired(alignment)) {\n\n                pairedAlignment = pairCache[alignment.readName];\n                if (pairedAlignment) {\n                    pairedAlignment.setSecondAlignment(alignment);\n                    pairCache[alignment.readName] = undefined; // Don't need to track this anymore.\n                } else {\n                    pairedAlignment = new igv.PairedAlignment(alignment);\n                    pairCache[alignment.readName] = pairedAlignment;\n                    result.push(pairedAlignment);\n                }\n            } else {\n                result.push(alignment);\n            }\n        });\n    });\n    return result;\n}\n\nfunction unpairAlignments(rows) {\n    var result = [];\n    rows.forEach(function (row) {\n        row.alignments.forEach(function (alignment) {\n            if (alignment instanceof PairedAlignment) {\n                if (alignment.firstAlignment) result.push(alignment.firstAlignment); // shouldn't need the null test\n                if (alignment.secondAlignment) result.push(alignment.secondAlignment);\n            } else {\n                result.push(alignment);\n            }\n        });\n    });\n    return result;\n}\n\nfunction canBePaired(alignment) {\n    return alignment.isPaired() && alignment.isMateMapped() && alignment.chr === alignment.mate.chr && (alignment.isFirstOfPair() || alignment.isSecondOfPair()) && !(alignment.isSecondary() || alignment.isSupplementary());\n}\n\nfunction packAlignmentRows(alignments, start, end, maxRows) {\n\n    if (!alignments) return;\n\n    alignments.sort(function (a, b) {\n        return a.start - b.start;\n    });\n\n    if (alignments.length === 0) {\n\n        return [];\n    } else {\n\n        var bucketList = [],\n            allocatedCount = 0,\n            lastAllocatedCount = 0,\n            nextStart = start,\n            alignmentRow,\n            index,\n            bucket,\n            alignment,\n            alignmentSpace = 4 * 2,\n            packedAlignmentRows = [],\n            bucketStart = Math.max(start, alignments[0].start);\n\n        alignments.forEach(function (alignment) {\n\n            var buckListIndex = Math.max(0, alignment.start - bucketStart);\n            if (bucketList[buckListIndex] === undefined) {\n                bucketList[buckListIndex] = [];\n            }\n            bucketList[buckListIndex].push(alignment);\n        });\n\n        while (allocatedCount < alignments.length && packedAlignmentRows.length < maxRows) {\n\n            alignmentRow = new BamAlignmentRow();\n\n            while (nextStart <= end) {\n\n                bucket = undefined;\n\n                while (!bucket && nextStart <= end) {\n\n                    index = nextStart - bucketStart;\n                    if (bucketList[index] === undefined) {\n                        ++nextStart; // No alignments at this index\n                    } else {\n                        bucket = bucketList[index];\n                    }\n                } // while (bucket)\n\n                if (!bucket) {\n                    break;\n                }\n                alignment = bucket.pop();\n                if (0 === bucket.length) {\n                    bucketList[index] = undefined;\n                }\n\n                alignmentRow.alignments.push(alignment);\n                nextStart = alignment.start + alignment.lengthOnRef + alignmentSpace;\n                ++allocatedCount;\n            } // while (nextStart)\n\n            if (alignmentRow.alignments.length > 0) {\n                packedAlignmentRows.push(alignmentRow);\n            }\n\n            nextStart = bucketStart;\n\n            if (allocatedCount === lastAllocatedCount) break; // Protect from infinite loops\n\n            lastAllocatedCount = allocatedCount;\n        } // while (allocatedCount)\n\n        return packedAlignmentRows;\n    }\n}\n\nvar BamAlignment = function () {\n    function BamAlignment() {\n        _classCallCheck(this, BamAlignment);\n\n        this.hidden = false;\n    }\n\n    _createClass(BamAlignment, [{\n        key: \"isMapped\",\n        value: function isMapped() {\n            return (this.flags & READ_UNMAPPED_FLAG) == 0;\n        }\n    }, {\n        key: \"isPaired\",\n        value: function isPaired() {\n            return (this.flags & READ_PAIRED_FLAG) != 0;\n        }\n    }, {\n        key: \"isProperPair\",\n        value: function isProperPair() {\n            return (this.flags & PROPER_PAIR_FLAG) != 0;\n        }\n    }, {\n        key: \"isFirstOfPair\",\n        value: function isFirstOfPair() {\n            return (this.flags & FIRST_OF_PAIR_FLAG) != 0;\n        }\n    }, {\n        key: \"isSecondOfPair\",\n        value: function isSecondOfPair() {\n            return (this.flags & SECOND_OF_PAIR_FLAG) != 0;\n        }\n    }, {\n        key: \"isSecondary\",\n        value: function isSecondary() {\n            return (this.flags & SECONDARY_ALIGNMNET_FLAG) != 0;\n        }\n    }, {\n        key: \"isSupplementary\",\n        value: function isSupplementary() {\n            return (this.flags & SUPPLEMENTARY_ALIGNMENT_FLAG) != 0;\n        }\n    }, {\n        key: \"isFailsVendorQualityCheck\",\n        value: function isFailsVendorQualityCheck() {\n            return (this.flags & READ_FAILS_VENDOR_QUALITY_CHECK_FLAG) != 0;\n        }\n    }, {\n        key: \"isDuplicate\",\n        value: function isDuplicate() {\n            return (this.flags & DUPLICATE_READ_FLAG) != 0;\n        }\n    }, {\n        key: \"isMateMapped\",\n        value: function isMateMapped() {\n            return (this.flags & MATE_UNMAPPED_FLAG) == 0;\n        }\n    }, {\n        key: \"isNegativeStrand\",\n        value: function isNegativeStrand() {\n            return (this.flags & READ_STRAND_FLAG) != 0;\n        }\n    }, {\n        key: \"isMateNegativeStrand\",\n        value: function isMateNegativeStrand() {\n            return (this.flags & MATE_STRAND_FLAG) != 0;\n        }\n    }, {\n        key: \"tags\",\n        value: function tags() {\n\n            function decodeTags(ba) {\n\n                var p = 0,\n                    len = ba.length,\n                    tags = {};\n\n                while (p < len) {\n                    var tag = String.fromCharCode(ba[p]) + String.fromCharCode(ba[p + 1]);\n                    var type = String.fromCharCode(ba[p + 2]);\n                    var value;\n\n                    if (type == 'A') {\n                        value = String.fromCharCode(ba[p + 3]);\n                        p += 4;\n                    } else if (type === 'i' || type === 'I') {\n                        value = readInt(ba, p + 3);\n                        p += 7;\n                    } else if (type === 'c' || type === 'C') {\n                        value = ba[p + 3];\n                        p += 4;\n                    } else if (type === 's' || type === 'S') {\n                        value = readShort(ba, p + 3);\n                        p += 5;\n                    } else if (type === 'f') {\n                        // TODO 'FIXME need floats';\n                        value = readFloat(ba, p + 3);\n                        p += 7;\n                    } else if (type === 'Z') {\n                        p += 3;\n                        value = '';\n                        for (;;) {\n                            var cc = ba[p++];\n                            if (cc === 0) {\n                                break;\n                            } else {\n                                value += String.fromCharCode(cc);\n                            }\n                        }\n                    } else {\n                        //'Unknown type ' + type;\n                        value = 'Error unknown type: ' + type;\n                        tags[tag] = value;\n                        break;\n                    }\n                    tags[tag] = value;\n                }\n                return tags;\n            }\n\n            if (!this.tagDict) {\n                if (this.tagBA) {\n                    this.tagDict = decodeTags(this.tagBA);\n                    this.tagBA = undefined;\n                } else {\n                    this.tagDict = {}; // Mark so we don't try again.  The record has not tags\n                }\n            }\n            return this.tagDict;\n        }\n    }, {\n        key: \"popupData\",\n        value: function popupData(genomicLocation) {\n\n            // if the user clicks on a base next to an insertion, show just the\n            // inserted bases in a popup (like in desktop IGV).\n            var nameValues = [],\n                isFirst,\n                tagDict;\n\n            if (this.insertions) {\n                for (var i = 0; i < this.insertions.length; i += 1) {\n                    var ins_start = this.insertions[i].start;\n                    if (genomicLocation == ins_start || genomicLocation == ins_start - 1) {\n                        nameValues.push({ name: 'Insertion', value: this.insertions[i].seq });\n                        nameValues.push({ name: 'Location', value: ins_start });\n                        return nameValues;\n                    }\n                }\n            }\n\n            nameValues.push({ name: 'Read Name', value: this.readName });\n\n            // Sample\n            // Read group\n            nameValues.push(\"<hr>\");\n\n            // Add 1 to genomic location to map from 0-based computer units to user-based units\n            nameValues.push({ name: 'Alignment Start', value: igv.numberFormatter(1 + this.start), borderTop: true });\n\n            nameValues.push({ name: 'Read Strand', value: true === this.strand ? '(+)' : '(-)', borderTop: true });\n            nameValues.push({ name: 'Cigar', value: this.cigar });\n            nameValues.push({ name: 'Mapped', value: yesNo(this.isMapped()) });\n            nameValues.push({ name: 'Mapping Quality', value: this.mq });\n            nameValues.push({ name: 'Secondary', value: yesNo(this.isSecondary()) });\n            nameValues.push({ name: 'Supplementary', value: yesNo(this.isSupplementary()) });\n            nameValues.push({ name: 'Duplicate', value: yesNo(this.isDuplicate()) });\n            nameValues.push({ name: 'Failed QC', value: yesNo(this.isFailsVendorQualityCheck()) });\n\n            if (this.isPaired()) {\n                nameValues.push(\"<hr>\");\n                nameValues.push({ name: 'First in Pair', value: !this.isSecondOfPair(), borderTop: true });\n                nameValues.push({ name: 'Mate is Mapped', value: yesNo(this.isMateMapped()) });\n                if (this.isMateMapped()) {\n                    nameValues.push({ name: 'Mate Chromosome', value: this.mate.chr });\n                    nameValues.push({ name: 'Mate Start', value: this.mate.position + 1 });\n                    nameValues.push({ name: 'Mate Strand', value: true === this.mate.strand ? '(+)' : '(-)' });\n                    nameValues.push({ name: 'Insert Size', value: this.fragmentLength });\n                    // Mate Start\n                    // Mate Strand\n                    // Insert Size\n                }\n                // First in Pair\n                // Pair Orientation\n            }\n\n            nameValues.push(\"<hr>\");\n            tagDict = this.tags();\n            isFirst = true;\n            for (var key in tagDict) {\n\n                if (tagDict.hasOwnProperty(key)) {\n\n                    if (isFirst) {\n                        nameValues.push({ name: key, value: tagDict[key], borderTop: true });\n                        isFirst = false;\n                    } else {\n                        nameValues.push({ name: key, value: tagDict[key] });\n                    }\n                }\n            }\n\n            return nameValues;\n\n            function yesNo(bool) {\n                return bool ? 'Yes' : 'No';\n            }\n        }\n    }]);\n\n    return BamAlignment;\n}();\n\nfunction readFloat(ba, offset) {\n\n    var dataView = new DataView(ba.buffer),\n        littleEndian = true;\n\n    return dataView.getFloat32(offset, littleEndian);\n}\n\nvar BamFilter = function () {\n    function BamFilter(options) {\n        _classCallCheck(this, BamFilter);\n\n        if (!options) options = {};\n        this.vendorFailed = options.vendorFailed === undefined ? true : options.vendorFailed;\n        this.duplicates = options.duplicates === undefined ? true : options.duplicates;\n        this.secondary = options.secondary || false;\n        this.supplementary = options.supplementary || false;\n        this.mqThreshold = options.mqThreshold === undefined ? 0 : options.mqThreshold;\n    }\n\n    _createClass(BamFilter, [{\n        key: \"pass\",\n        value: function pass(alignment) {\n\n            if (this.vendorFailed && alignment.isFailsVendorQualityCheck()) return false;\n            if (this.duplicates && alignment.isDuplicate()) return false;\n            if (this.secondary && alignment.isSecondary()) return false;\n            if (this.supplementary && alignment.isSupplementary()) return false;\n            if (alignment.mq < this.mqThreshold) return false;\n\n            return true;\n        }\n    }]);\n\n    return BamFilter;\n}();\n\nvar BLOCK_HEADER_LENGTH = 18;\nvar BLOCK_LENGTH_OFFSET = 16; // Location in the gzip block of the total block size (actually total block size - 1)\nvar BLOCK_FOOTER_LENGTH = 8; // Number of bytes that follow the deflated data\nvar MAX_COMPRESSED_BLOCK_SIZE = 64 * 1024; // We require that a compressed block (including header and footer, be <= this)\nvar GZIP_OVERHEAD = BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH + 2; // Gzip overhead is the header, the footer, and the block size (encoded as a short).\nvar GZIP_ID1 = 31; // Magic number\nvar GZIP_ID2 = 139; // Magic number\nvar GZIP_FLG = 4; // FEXTRA flag means there are optional fields\n\n\n// Uncompress data,  assumed to be series of bgzipped blocks\n// Code is based heavily on bam.js, part of the Dalliance Genome Explorer,  (c) Thomas Down 2006-2001.\n\nvar unbgzf = function unbgzf(data, lim) {\n    _classCallCheck(this, unbgzf);\n\n    for (var a in data) {\n        console.log(a);\n    }\n    var oBlockList = [],\n        ptr = [0],\n        totalSize = 0;\n\n    lim = lim || data.byteLength - 18;\n\n    while (ptr[0] < lim) {\n\n        var ba = new Uint8Array(data, ptr[0], 18);\n\n        var xlen = ba[11] << 8 | ba[10];\n        var si1 = ba[12];\n        var si2 = ba[13];\n        var slen = ba[15] << 8 | ba[14];\n        var bsize = ba[17] << 8 | ba[16] + 1;\n\n        var start = 12 + xlen + ptr[0]; // Start of CDATA\n        var length = data.byteLength - start;\n\n        if (length < bsize + 8) break;\n\n        var unc = (0, _inflate.jszlib_inflate_buffer)(data, start, length, ptr);\n\n        ptr[0] += 8; // Skipping CRC-32 and size of uncompressed data\n\n        totalSize += unc.byteLength;\n        oBlockList.push(unc);\n    }\n\n    // Concatenate decompressed blocks\n    if (oBlockList.length == 1) {\n        return oBlockList[0];\n    } else {\n        var out = new Uint8Array(totalSize);\n        var cursor = 0;\n        for (var i = 0; i < oBlockList.length; ++i) {\n            var b = new Uint8Array(oBlockList[i]);\n            (0, _inflate.arrayCopy)(b, 0, out, cursor, b.length);\n            cursor += b.length;\n        }\n        return out.buffer;\n    }\n};\n\nvar AlignmentContainer = function () {\n    function AlignmentContainer(chr, start, end, samplingWindowSize, samplingDepth, pairsSupported) {\n        _classCallCheck(this, AlignmentContainer);\n\n        this.chr = chr;\n        this.start = start;\n        this.end = end;\n        this.length = end - start;\n\n        this.coverageMap = new CoverageMap(chr, start, end);\n        this.alignments = [];\n        this.downsampledIntervals = [];\n\n        this.samplingWindowSize = samplingWindowSize === undefined ? 100 : samplingWindowSize;\n        this.samplingDepth = samplingDepth === undefined ? 50 : samplingDepth;\n\n        this.pairsSupported = pairsSupported;\n        this.paired = false; // false until proven otherwise\n        this.pairsCache = {}; // working cache of paired alignments by read name\n\n        this.downsampledReads = new Set();\n\n        this.currentBucket = new DownsampleBucket(this.start, this.start + this.samplingWindowSize, this);\n\n        this.filter = function filter(alignment) {\n            // TODO -- pass this in\n            return alignment.isMapped() && !alignment.isFailsVendorQualityCheck();\n        };\n    }\n\n    _createClass(AlignmentContainer, [{\n        key: \"push\",\n        value: function push(alignment) {\n\n            if (this.filter(alignment) === false) return;\n\n            this.coverageMap.incCounts(alignment); // Count coverage before any downsampling\n\n            if (this.pairsSupported && this.downsampledReads.has(alignment.readName)) {\n                return; // Mate already downsampled -- pairs are treated as a single alignment for downsampling\n            }\n\n            if (alignment.start >= this.currentBucket.end) {\n                finishBucket.call(this);\n                this.currentBucket = new DownsampleBucket(alignment.start, alignment.start + this.samplingWindowSize, this);\n            }\n\n            this.currentBucket.addAlignment(alignment);\n        }\n    }, {\n        key: \"forEach\",\n        value: function forEach(callback) {\n            this.alignments.forEach(callback);\n        }\n    }, {\n        key: \"finish\",\n        value: function finish() {\n\n            if (this.currentBucket !== undefined) {\n                finishBucket.call(this);\n            }\n\n            // Need to remove partial pairs whose mate was downsampled\n            if (this.pairsSupported) {\n                var tmp = [],\n                    ds = this.downsampledReads;\n\n                this.alignments.forEach(function (a) {\n                    if (!ds.has(a.readName)) {\n                        tmp.push(a);\n                    }\n                });\n                this.alignments = tmp;\n            }\n\n            this.alignments.sort(function (a, b) {\n                return a.start - b.start;\n            });\n\n            this.pairsCache = undefined;\n            this.downsampledReads = undefined;\n        }\n    }, {\n        key: \"contains\",\n        value: function contains(chr, start, end) {\n            return this.chr == chr && this.start <= start && this.end >= end;\n        }\n    }, {\n        key: \"hasDownsampledIntervals\",\n        value: function hasDownsampledIntervals() {\n            return this.downsampledIntervals && this.downsampledIntervals.length > 0;\n        }\n    }]);\n\n    return AlignmentContainer;\n}();\n\nfunction finishBucket() {\n    this.alignments = this.alignments.concat(this.currentBucket.alignments);\n    if (this.currentBucket.downsampledCount > 0) {\n        this.downsampledIntervals.push(new DownsampledInterval(this.currentBucket.start, this.currentBucket.end, this.currentBucket.downsampledCount));\n    }\n    this.paired = this.paired || this.currentBucket.paired;\n}\n\nvar DownsampleBucket = function () {\n    function DownsampleBucket(start, end, alignmentContainer) {\n        _classCallCheck(this, DownsampleBucket);\n\n        this.start = start;\n        this.end = end;\n        this.alignments = [];\n        this.downsampledCount = 0;\n        this.samplingDepth = alignmentContainer.samplingDepth;\n        this.pairsSupported = alignmentContainer.pairsSupported;\n        this.downsampledReads = alignmentContainer.downsampledReads;\n        this.pairsCache = alignmentContainer.pairsCache;\n    }\n\n    _createClass(DownsampleBucket, [{\n        key: \"addAlignment\",\n        value: function addAlignment(alignment) {\n\n            var samplingProb, idx, replacedAlignment, pairedAlignment;\n\n            if (this.alignments.length < this.samplingDepth) {\n\n                if (this.pairsSupported && canBePaired(alignment)) {\n                    pairedAlignment = this.pairsCache[alignment.readName];\n                    if (pairedAlignment) {\n                        //Not subject to downsampling, just update the existing alignment\n                        pairedAlignment.setSecondAlignment(alignment);\n                        this.pairsCache[alignment.readName] = undefined; // Don't need to track this anymore. NOTE: Don't \"delete\", causes runtime performance issues\n                    } else {\n                        // First alignment in a pair\n                        pairedAlignment = new PairedAlignment(alignment);\n                        this.paired = true;\n                        this.pairsCache[alignment.readName] = pairedAlignment;\n                        this.alignments.push(pairedAlignment);\n                    }\n                } else {\n                    this.alignments.push(alignment);\n                }\n            } else {\n\n                samplingProb = this.samplingDepth / (this.samplingDepth + this.downsampledCount + 1);\n\n                if (Math.random() < samplingProb) {\n\n                    idx = Math.floor(Math.random() * (this.alignments.length - 1));\n                    replacedAlignment = this.alignments[idx]; // To be replaced\n\n                    if (this.pairsSupported && canBePaired(alignment)) {\n\n                        if (this.pairsCache[replacedAlignment.readName] !== undefined) {\n                            this.pairsCache[replacedAlignment.readName] = undefined;\n                        }\n\n                        pairedAlignment = new PairedAlignment(alignment);\n                        this.paired = true;\n                        this.pairsCache[alignment.readName] = pairedAlignment;\n                        this.alignments[idx] = pairedAlignment;\n                    } else {\n                        this.alignments[idx] = alignment;\n                    }\n                    this.downsampledReads.add(replacedAlignment.readName);\n                } else {\n                    this.downsampledReads.add(alignment.readName);\n                }\n\n                this.downsampledCount++;\n            }\n        }\n    }]);\n\n    return DownsampleBucket;\n}();\n\n// TODO -- refactor this to use an object, rather than an array,  if end-start is > some threshold\n\n\nvar CoverageMap = function () {\n    function CoverageMap(chr, start, end) {\n        _classCallCheck(this, CoverageMap);\n\n        this.chr = chr;\n        this.bpStart = start;\n        this.length = end - start;\n\n        this.coverage = new Array(this.length);\n\n        this.maximum = 0;\n    }\n\n    _createClass(CoverageMap, [{\n        key: \"incCounts\",\n        value: function incCounts(alignment) {\n\n            var self = this;\n\n            if (alignment.blocks === undefined) {\n\n                incBlockCount(alignment);\n            } else {\n                alignment.blocks.forEach(function (block) {\n                    incBlockCount(block);\n                });\n            }\n\n            function incBlockCount(block) {\n\n                var key, base, i, j, q;\n\n                for (i = block.start - self.bpStart, j = 0; j < block.len; i++, j++) {\n\n                    if (!self.coverage[i]) {\n                        self.coverage[i] = new Coverage();\n                    }\n\n                    base = block.seq.charAt(j);\n                    key = alignment.strand ? \"pos\" + base : \"neg\" + base;\n                    q = block.qual[j];\n\n                    self.coverage[i][key] += 1;\n                    self.coverage[i][\"qual\" + base] += q;\n\n                    self.coverage[i].total += 1;\n                    self.coverage[i].qual += q;\n\n                    self.maximum = Math.max(self.coverage[i].total, self.maximum);\n                }\n            }\n        }\n    }]);\n\n    return CoverageMap;\n}();\n\nCoverageMap.threshold = 0.2;\nCoverageMap.qualityWeight = true;\n\nvar Coverage = function () {\n    function Coverage() {\n        _classCallCheck(this, Coverage);\n\n        this.posA = 0;\n        this.negA = 0;\n\n        this.posT = 0;\n        this.negT = 0;\n\n        this.posC = 0;\n        this.negC = 0;\n        this.posG = 0;\n\n        this.negG = 0;\n\n        this.posN = 0;\n        this.negN = 0;\n\n        this.pos = 0;\n        this.neg = 0;\n\n        this.qualA = 0;\n        this.qualT = 0;\n        this.qualC = 0;\n        this.qualG = 0;\n        this.qualN = 0;\n\n        this.qual = 0;\n\n        this.total = 0;\n    }\n\n    _createClass(Coverage, [{\n        key: \"isMismatch\",\n        value: function isMismatch(refBase) {\n\n            var myself = this,\n                mismatchQualitySum,\n                threshold = CoverageMap.threshold * (CoverageMap.qualityWeight && this.qual ? this.qual : this.total);\n\n            mismatchQualitySum = 0;\n            [\"A\", \"T\", \"C\", \"G\"].forEach(function (base) {\n\n                if (base !== refBase) {\n                    mismatchQualitySum += CoverageMap.qualityWeight && myself.qual ? myself[\"qual\" + base] : myself[\"pos\" + base] + myself[\"neg\" + base];\n                }\n            });\n\n            return mismatchQualitySum >= threshold;\n        }\n    }]);\n\n    return Coverage;\n}();\n\nvar DownsampledInterval = function () {\n    function DownsampledInterval(start, end, counts) {\n        _classCallCheck(this, DownsampledInterval);\n\n        this.start = start;\n        this.end = end;\n        this.counts = counts;\n    }\n\n    _createClass(DownsampledInterval, [{\n        key: \"popupData\",\n        value: function popupData(genomicLocation) {\n            return [{ name: \"start\", value: this.start + 1 }, { name: \"end\", value: this.end }, { name: \"# downsampled:\", value: this.counts }];\n        }\n    }]);\n\n    return DownsampledInterval;\n}();\n\nvar PairedAlignment = function () {\n    function PairedAlignment(firstAlignment) {\n        _classCallCheck(this, PairedAlignment);\n\n        this.firstAlignment = firstAlignment;\n        this.chr = firstAlignment.chr;\n        this.readName = firstAlignment.readName;\n\n        if (firstAlignment.start < firstAlignment.mate.position) {\n            this.start = firstAlignment.start;\n            this.end = Math.max(firstAlignment.mate.position, firstAlignment.start + firstAlignment.lengthOnRef); // Approximate\n            this.connectingStart = firstAlignment.start + firstAlignment.lengthOnRef;\n            this.connectingEnd = firstAlignment.mate.position;\n        } else {\n            this.start = firstAlignment.mate.position;\n            this.end = firstAlignment.start + firstAlignment.lengthOnRef;\n            this.connectingStart = firstAlignment.mate.position;\n            this.connectingEnd = firstAlignment.start;\n        }\n        this.lengthOnRef = this.end - this.start;\n    }\n\n    _createClass(PairedAlignment, [{\n        key: \"setSecondAlignment\",\n        value: function setSecondAlignment(alignment) {\n\n            // TODO -- check the chrs are equal,  error otherwise\n            this.secondAlignment = alignment;\n\n            if (alignment.start > this.firstAlignment.start) {\n                this.end = alignment.start + alignment.lengthOnRef;\n                this.connectingEnd = alignment.start;\n            } else {\n                this.start = alignment.start;\n                this.connectingStart = alignment.start + alignment.lengthOnRef;\n            }\n            this.lengthOnRef = this.end - this.start;\n        }\n    }, {\n        key: \"popupData\",\n        value: function popupData(genomicLocation) {\n\n            var nameValues = [];\n\n            nameValues = nameValues.concat(this.firstAlignment.popupData(genomicLocation));\n\n            if (this.secondAlignment) {\n                nameValues.push(\"-------------------------------\");\n                nameValues = nameValues.concat(this.secondAlignment.popupData(genomicLocation));\n            }\n            return nameValues;\n        }\n    }, {\n        key: \"isPaired\",\n        value: function isPaired() {\n            return true; // By definition\n        }\n    }, {\n        key: \"firstOfPairStrand\",\n        value: function firstOfPairStrand() {\n            if (this.firstAlignment.isFirstOfPair()) {\n                return this.firstAlignment.strand;\n            } else if (this.secondAlignment) {\n                return this.secondAlignment.strand;\n            } else {\n                return this.firstAlignment.strand; // This assumes inward pointing pairs\n            }\n        }\n    }]);\n\n    return PairedAlignment;\n}();\n\nvar BamAlignmentRow = function () {\n    function BamAlignmentRow() {\n        _classCallCheck(this, BamAlignmentRow);\n\n        this.alignments = [];\n        this.score = undefined;\n    }\n\n    _createClass(BamAlignmentRow, [{\n        key: \"findCenterAlignment\",\n        value: function findCenterAlignment(bpStart, bpEnd) {\n\n            var centerAlignment = undefined;\n\n            // find single alignment that overlaps sort location\n            this.alignments.forEach(function (a) {\n\n                if (undefined === centerAlignment) {\n\n                    if (a.start + a.lengthOnRef < bpStart || a.start > bpEnd) {\n                        // do nothing\n                    } else {\n                        centerAlignment = a;\n                    }\n                }\n            });\n\n            return centerAlignment;\n        }\n    }, {\n        key: \"updateScore\",\n        value: function updateScore(genomicLocation, genomicInterval, sortOption) {\n\n            this.score = this.caculateScore(genomicLocation, 1 + genomicLocation, genomicInterval, sortOption);\n        }\n    }, {\n        key: \"caculateScore\",\n        value: function caculateScore(bpStart, bpEnd, genomicInterval, sortOption) {\n\n            var baseScore, alignment;\n\n            alignment = this.findCenterAlignment(bpStart, bpEnd);\n            if (undefined === alignment) {\n                return Number.MAX_VALUE;\n            }\n\n            if (\"NUCLEOTIDE\" === sortOption.sort) {\n\n                baseScore = undefined;\n\n                alignment.blocks.forEach(function (block) {\n\n                    var sequence = genomicInterval.sequence,\n                        coverageMap = genomicInterval.coverageMap,\n                        reference,\n                        base,\n                        coverage,\n                        count,\n                        phred;\n\n                    if (\"*\" !== block.seq) {\n\n                        for (var i = 0, indexReferenceSequence = block.start - genomicInterval.start, bpBlockSequence = block.start, lengthBlockSequence = block.seq.length; i < lengthBlockSequence; i++, indexReferenceSequence++, bpBlockSequence++) {\n\n                            if (bpStart === bpBlockSequence) {\n\n                                reference = sequence.charAt(indexReferenceSequence);\n                                base = block.seq.charAt(i);\n\n                                if (base === \"=\") {\n                                    base = reference;\n                                }\n\n                                if (base === 'N') {\n                                    baseScore = 2;\n                                } else if (base === reference) {\n                                    baseScore = 3;\n                                } else if (base === \"X\" || base !== reference) {\n\n                                    coverage = coverageMap.coverage[bpBlockSequence - coverageMap.bpStart];\n                                    count = coverage[\"pos\" + base] + coverage[\"neg\" + base];\n                                    phred = coverage.qual ? coverage.qual : 0;\n                                    baseScore = -(count + phred / 1000.0);\n                                } else {\n                                    console.log(\"BamAlignmentRow.caculateScore - huh?\");\n                                }\n                            } // bpStart === bpBlockSequence\n                        } // block.seq.length\n                    } else {\n                        baseScore = 3;\n                    }\n                });\n\n                return undefined === baseScore ? Number.MAX_VALUE : baseScore;\n            } else if (\"STRAND\" === sortOption.sort) {\n\n                return alignment.strand ? 1 : -1;\n            } else if (\"START\" === sortOption.sort) {\n\n                return alignment.start;\n            }\n\n            return Number.MAX_VALUE;\n        }\n    }]);\n\n    return BamAlignmentRow;\n}();\n\nexports.loadBamIndex = loadBamIndex;\nexports.BamReader = BamReader;\nexports.BamSource = BamSource;\nexports.BamFilter = BamFilter;\nexports.BamAlignment = BamAlignment;\nexports.PairedAlignment = PairedAlignment;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/vendor/zlib_and_gzip.min.js */ \"./src/vendor/zlib_and_gzip.min.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9iYW0uanM/Nzk2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IEJyb2FkIEluc3RpdHV0ZVxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xyXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gKiBUSEUgU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuXHJcbmltcG9ydCB7aWd2eGhyfSBmcm9tIFwiLi9pZ3Z4aHIuanNcIjtcclxuaW1wb3J0IHtCaW5hcnlQYXJzZXJ9IGZyb20gXCIuL2JpZ3dpZy5qc1wiO1xyXG5pbXBvcnQge2pzemxpYl9pbmZsYXRlX2J1ZmZlcixhcnJheUNvcHl9IGZyb20gXCIuL3ZlbmRvci9pbmZsYXRlLmpzXCI7XHJcbmltcG9ydCB7RmFzdGFTZXF1ZW5jZX0gZnJvbSBcIi4vZmVhdHVyZS5qc1wiXHJcblxyXG5cclxuY29uc3QgQkFJX01BR0lDID0gMjE1NzgwNTA7XHJcbmNvbnN0IFRBQklYX01BR0lDID0gMjE1NzgzMjQ7XHJcbmNvbnN0IE1BWF9IRUFERVJfU0laRSA9IDEwMDAwMDAwMDsgICAvLyBJRiB0aGUgaGVhZGVyIGlzIGxhcmdlciB0aGFuIHRoaXMgd2UgY2FuJ3QgcmVhZCBpdCAhXHJcbmNvbnN0IEJfTUFYX0daSVBfQkxPQ0tfU0laRSA9ICgxIDw8IDE2KTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhVUkxcclxuICAgICAqIEBwYXJhbSBjb25maWdcclxuICAgICAqIEBwYXJhbSB0YWJpeFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGEgUHJvbWlzZWQgZm9yIHRoZSBiYW0gb3IgdGFiaXggaW5kZXguICBUaGUgZnVsZmlsbCBmdW5jdGlvbiB0YWtlcyB0aGUgaW5kZXggYXMgYW4gYXJndW1lbnQuXHJcbiAgICAgKi9cclxubGV0IGxvYWRCYW1JbmRleCA9IGZ1bmN0aW9uIChpbmRleFVSTCwgY29uZmlnLCB0YWJpeCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGdlbm9tZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBpZ3Z4aHIubG9hZEFycmF5QnVmZmVyKGluZGV4VVJMLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGNvbmZpZy5oZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogY29uZmlnLndpdGhDcmVkZW50aWFsc1xyXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hZ2ljLCBuYmluLCBuaW50diwgbnJlZiwgcGFyc2VyLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTWluID0gTnVtYmVyLk1BWF9WQUxVRSxcclxuICAgICAgICAgICAgICAgICAgICBibG9ja01heCA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgYmluSW5kZXgsIGxpbmVhckluZGV4LCBiaW5OdW1iZXIsIGNzLCBjZSwgYiwgaSwgcmVmLCBzZXF1ZW5jZUluZGV4TWFwO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghYXJyYXlCdWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGFiaXgpIHtcclxuICAgICAgICAgICAgICAgIFx0ICBjb25zb2xlLmxvZyhabGliKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbGF0ZSA9IG5ldyBabGliLlpsaWIuR3VuemlwKG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlCdWZmZXIgPSBpbmZsYXRlLmRlY29tcHJlc3MoKS5idWZmZXI7XHJcbiAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgIC8qbGV0IHIgPXBha28uaW5mbGF0ZShuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhcnJheUJ1ZmZlciA9ci5idWZmZXI7Ki9cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBwYXJzZXIgPSBuZXcgQmluYXJ5UGFyc2VyKG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcikpO1xyXG5cclxuICAgICAgICAgICAgICAgIG1hZ2ljID0gcGFyc2VyLmdldEludCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtYWdpYyA9PT0gQkFJX01BR0lDIHx8ICh0YWJpeCAmJiBtYWdpYyA9PT0gVEFCSVhfTUFHSUMpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG5yZWYgPSBwYXJzZXIuZ2V0SW50KCk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFiaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGFiaXggaGVhZGVyIHBhcmFtZXRlcnMgYXJlbid0IHVzZWQsIGJ1dCB0aGV5IG11c3QgYmUgcmVhZCB0byBhZHZhbmNlIHRoZSBwb2ludGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3JtYXQgPSBwYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xfc2VxID0gcGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sX2JlZyA9IHBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbF9lbmQgPSBwYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRhID0gcGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2tpcCA9IHBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxfbm0gPSBwYXJzZXIuZ2V0SW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZUluZGV4TWFwID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBucmVmOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXFfbmFtZSA9IHBhcnNlci5nZXRTdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2xhdGUgdG8gXCJvZmZpY2lhbFwiIGNociBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdlbm9tZSkgc2VxX25hbWUgPSBnZW5vbWUuZ2V0Q2hyb21vc29tZU5hbWUoc2VxX25hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcXVlbmNlSW5kZXhNYXBbc2VxX25hbWVdID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyZWYgPSAwOyByZWYgPCBucmVmOyArK3JlZikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYmluSW5kZXggPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZWFySW5kZXggPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5iaW4gPSBwYXJzZXIuZ2V0SW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGIgPSAwOyBiIDwgbmJpbjsgKytiKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluTnVtYmVyID0gcGFyc2VyLmdldEludCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaW5OdW1iZXIgPT0gMzc0NTApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgcHN1ZWRvIGJpbiwgbm90IHVzZWQgYnV0IHdlIGhhdmUgdG8gY29uc3VtZSB0aGUgYnl0ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuY2huayA9IHBhcnNlci5nZXRJbnQoKTsgLy8gIyBvZiBjaHVua3MgZm9yIHRoaXMgYmluXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3MgPSBwYXJzZXIuZ2V0VlBvaW50ZXIoKTsgICAvLyB1bm1hcHBlZCBiZWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZSA9IHBhcnNlci5nZXRWUG9pbnRlcigpOyAgIC8vIHVubWFwcGVkIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuX21hcGVkID0gcGFyc2VyLmdldExvbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgblVubWFwcGVkID0gcGFyc2VyLmdldExvbmcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5JbmRleFtiaW5OdW1iZXJdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5jaG5rID0gcGFyc2VyLmdldEludCgpOyAvLyAjIG9mIGNodW5rcyBmb3IgdGhpcyBiaW5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5jaG5rOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3MgPSBwYXJzZXIuZ2V0VlBvaW50ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2UgPSBwYXJzZXIuZ2V0VlBvaW50ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzICYmIGNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3MuYmxvY2sgPCBibG9ja01pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTWluID0gY3MuYmxvY2s7ICAgIC8vIEJsb2NrIGNvbnRhaW5pbmcgZmlyc3QgYWxpZ25tZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2UuYmxvY2sgPiBibG9ja01heCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTWF4ID0gY2UuYmxvY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5JbmRleFtiaW5OdW1iZXJdLnB1c2goW2NzLCBjZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmludHYgPSBwYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuaW50djsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcyA9IHBhcnNlci5nZXRWUG9pbnRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZWFySW5kZXgucHVzaChjcyk7ICAgLy8gTWlnaHQgYmUgbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmJpbiA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXNbcmVmXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5JbmRleDogYmluSW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZWFySW5kZXg6IGxpbmVhckluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW5kZXhVUkwgKyBcIiBpcyBub3QgYSBcIiArICh0YWJpeCA/IFwidGFiaXhcIiA6IFwiYmFpXCIpICsgXCIgZmlsZVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwobmV3IEJhbUluZGV4KGluZGljZXMsIGJsb2NrTWluLCBzZXF1ZW5jZUluZGV4TWFwLCB0YWJpeCkpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG5cclxuY2xhc3MgQmFtSW5kZXh7XHJcbiAgICBjb25zdHJ1Y3RvciAoaW5kaWNlcywgYmxvY2tNaW4sIHNlcXVlbmNlSW5kZXhNYXAsIHRhYml4KSB7XHJcbiAgICAgICAgdGhpcy5maXJzdEFsaWdubWVudEJsb2NrID0gYmxvY2tNaW47XHJcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gaW5kaWNlcztcclxuICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXhNYXAgPSBzZXF1ZW5jZUluZGV4TWFwO1xyXG4gICAgICAgIHRoaXMudGFiaXggPSB0YWJpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZldGNoIGJsb2NrcyBmb3IgYSBwYXJ0aWN1bGFyIGdlbm9taWMgcmFuZ2UuICBUaGlzIG1ldGhvZCBpcyBwdWJsaWMgc28gaXQgY2FuIGJlIHVuaXQtdGVzdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZWZJZCAgdGhlIHNlcXVlbmNlIGRpY3Rpb25hcnkgaW5kZXggb2YgdGhlIGNocm9tb3NvbWVcclxuICAgICAqIEBwYXJhbSBtaW4gIGdlbm9taWMgc3RhcnQgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSBtYXggIGdlbm9taWMgZW5kIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gcmV0dXJuIGFuIGFycmF5IG9mIHttaW52OiB7ZmlsZVBvaW50ZXIsIG9mZnNldH0sIHttYXh2OiB7ZmlsZVBvaW50ZXIsIG9mZnNldH19XHJcbiAgICAgKi9cclxuICAgIGJsb2Nrc0ZvclJhbmdlKHJlZklkLCBtaW4sIG1heCkge1xyXG5cclxuICAgICAgICB2YXIgYmFtID0gdGhpcyxcclxuICAgICAgICAgICAgYmEgPSBiYW0uaW5kaWNlc1tyZWZJZF0sXHJcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nQmlucyxcclxuICAgICAgICAgICAgbGVhZkNodW5rcyxcclxuICAgICAgICAgICAgb3RoZXJDaHVua3MsXHJcbiAgICAgICAgICAgIG5pbnR2LFxyXG4gICAgICAgICAgICBsb3dlc3QsXHJcbiAgICAgICAgICAgIG1pbkxpbixcclxuICAgICAgICAgICAgbWF4TGluLFxyXG4gICAgICAgICAgICBsYixcclxuICAgICAgICAgICAgcHJ1bmVkT3RoZXJDaHVua3MsXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIGNobmssXHJcbiAgICAgICAgICAgIGRpZixcclxuICAgICAgICAgICAgaW50Q2h1bmtzLFxyXG4gICAgICAgICAgICBtZXJnZWRDaHVua3M7XHJcblxyXG4gICAgICAgIGlmICghYmEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nQmlucyA9IEJhbUluZGV4LnJlZzJiaW5zKG1pbiwgbWF4KTsgICAgICAgIC8vIExpc3Qgb2YgYmluICNzIHRoYXQgbWlnaHQgb3ZlcmxhcCBtaW4sIG1heFxyXG4gICAgICAgICAgICBsZWFmQ2h1bmtzID0gW107XHJcbiAgICAgICAgICAgIG90aGVyQ2h1bmtzID0gW107XHJcblxyXG5cclxuICAgICAgICAgICAgb3ZlcmxhcHBpbmdCaW5zLmZvckVhY2goZnVuY3Rpb24gKGJpbikge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChiYS5iaW5JbmRleFtiaW5dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNodW5rcyA9IGJhLmJpbkluZGV4W2Jpbl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5jaG5rID0gY2h1bmtzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBuY2huazsgKytjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcyA9IGNodW5rc1tjXVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNlID0gY2h1bmtzW2NdWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYmluIDwgNDY4MSA/IG90aGVyQ2h1bmtzIDogbGVhZkNodW5rcykucHVzaCh7bWludjogY3MsIG1heHY6IGNlLCBiaW46IGJpbn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gVXNlIHRoZSBsaW5lYXIgaW5kZXggdG8gZmluZCB0aGUgbG93ZXN0IGNodW5rIHRoYXQgY291bGQgY29udGFpbiBhbGlnbm1lbnRzIGluIHRoZSByZWdpb25cclxuICAgICAgICAgICAgbmludHYgPSBiYS5saW5lYXJJbmRleC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxvd2VzdCA9IG51bGw7XHJcbiAgICAgICAgICAgIG1pbkxpbiA9IE1hdGgubWluKG1pbiA+PiAxNCwgbmludHYgLSAxKSwgbWF4TGluID0gTWF0aC5taW4obWF4ID4+IDE0LCBuaW50diAtIDEpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBtaW5MaW47IGkgPD0gbWF4TGluOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGxiID0gYmEubGluZWFySW5kZXhbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWxiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWxvd2VzdCB8fCBsYi5ibG9jayA8IGxvd2VzdC5ibG9jayB8fCBsYi5vZmZzZXQgPCBsb3dlc3Qub2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXN0ID0gbGI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFBydW5lIGNodW5rcyB0aGF0IGVuZCBiZWZvcmUgdGhlIGxvd2VzdCBjaHVua1xyXG4gICAgICAgICAgICBwcnVuZWRPdGhlckNodW5rcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAobG93ZXN0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvdGhlckNodW5rcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNobmsgPSBvdGhlckNodW5rc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2huay5tYXh2LmJsb2NrID4gbG93ZXN0LmJsb2NrIHx8IChjaG5rLm1heHYuYmxvY2sgPT0gbG93ZXN0LmJsb2NrICYmIGNobmsubWF4di5vZmZzZXQgPj0gbG93ZXN0Lm9mZnNldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJ1bmVkT3RoZXJDaHVua3MucHVzaChjaG5rKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGludENodW5rcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJ1bmVkT3RoZXJDaHVua3MubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGludENodW5rcy5wdXNoKHBydW5lZE90aGVyQ2h1bmtzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVhZkNodW5rcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaW50Q2h1bmtzLnB1c2gobGVhZkNodW5rc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGludENodW5rcy5zb3J0KGZ1bmN0aW9uIChjMCwgYzEpIHtcclxuICAgICAgICAgICAgICAgIGRpZiA9IGMwLm1pbnYuYmxvY2sgLSBjMS5taW52LmJsb2NrO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpZiAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMwLm1pbnYub2Zmc2V0IC0gYzEubWludi5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgbWVyZ2VkQ2h1bmtzID0gW107XHJcbiAgICAgICAgICAgIGlmIChpbnRDaHVua3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1ciA9IGludENodW5rc1swXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgaW50Q2h1bmtzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5jID0gaW50Q2h1bmtzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgobmMubWludi5ibG9jayAtIGN1ci5tYXh2LmJsb2NrKSA8IDY1MDAwKSB7IC8vIE1lcmdlIGJsb2NrcyB0aGF0IGFyZSB3aXRoaW5nIDY1ayBvZiBlYWNoIG90aGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IHttaW52OiBjdXIubWludiwgbWF4djogbmMubWF4dn07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VkQ2h1bmtzLnB1c2goY3VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gbmM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbWVyZ2VkQ2h1bmtzLnB1c2goY3VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkQ2h1bmtzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB0aGUgbGlzdCBvZiBiaW5zIHRoYXQgbWF5IG92ZXJsYXAgd2l0aCByZWdpb24gW2JlZywgZW5kXVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlZzJiaW5zKGJlZywgZW5kKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwLCBrLCBsaXN0ID0gW107XHJcbiAgICAgICAgaWYgKGVuZCA+PSAxIDw8IDI5KSAgIGVuZCA9IDEgPDwgMjk7XHJcbiAgICAgICAgLS1lbmQ7XHJcbiAgICAgICAgbGlzdC5wdXNoKDApO1xyXG4gICAgICAgIGZvciAoayA9IDEgKyAoYmVnID4+IDI2KTsgayA8PSAxICsgKGVuZCA+PiAyNik7ICsraykgbGlzdC5wdXNoKGspO1xyXG4gICAgICAgIGZvciAoayA9IDkgKyAoYmVnID4+IDIzKTsgayA8PSA5ICsgKGVuZCA+PiAyMyk7ICsraykgbGlzdC5wdXNoKGspO1xyXG4gICAgICAgIGZvciAoayA9IDczICsgKGJlZyA+PiAyMCk7IGsgPD0gNzMgKyAoZW5kID4+IDIwKTsgKytrKSBsaXN0LnB1c2goayk7XHJcbiAgICAgICAgZm9yIChrID0gNTg1ICsgKGJlZyA+PiAxNyk7IGsgPD0gNTg1ICsgKGVuZCA+PiAxNyk7ICsraykgbGlzdC5wdXNoKGspO1xyXG4gICAgICAgIGZvciAoayA9IDQ2ODEgKyAoYmVnID4+IDE0KTsgayA8PSA0NjgxICsgKGVuZCA+PiAxNCk7ICsraykgbGlzdC5wdXNoKGspO1xyXG4gICAgICAgIHJldHVybiBsaXN0O1xyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIEJHWkZpbGV7XHJcblxyXG4gICAgY29uc3RydWN0b3IgKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuZmlsZVBvc2l0aW9uID0gMDtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIH1cclxuXHJcbiAgICBuZXh0QmxvY2soKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlndnhoci5sb2FkQXJyYXlCdWZmZXIoc2VsZi5wYXRoLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHNlbGYuY29uZmlnLmhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtzdGFydDogc2VsZi5maWxlUG9zaXRpb24sIHNpemU6IEJMT0NLX0hFQURFUl9MRU5HVEh9LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogc2VsZi5jb25maWcud2l0aENyZWRlbnRpYWxzXHJcblxyXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICB2YXIgeGxlbiA9IChiYVsxMV0gPDwgOCkgfCAoYmFbMTBdKTtcclxuICAgICAgICAgICAgICAgIHZhciBzaTEgPSBiYVsxMl07XHJcbiAgICAgICAgICAgICAgICB2YXIgc2kyID0gYmFbMTNdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsZW4gPSAoYmFbMTVdIDw8IDgpIHwgKGJhWzE0XSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYnNpemUgPSAoYmFbMTddIDw8IDgpIHwgKGJhWzE2XSkgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuZmlsZVBvc2l0aW9uICs9IEJMT0NLX0hFQURFUl9MRU5HVEg7XHJcblxyXG4gICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcihzZWxmLnBhdGgsIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBzZWxmLmNvbmZpZy5oZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7c3RhcnQ6IHNlbGYuZmlsZVBvc2l0aW9uLCBzaXplOiBic2l6ZX0sXHJcbiAgICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLmNvbmZpZy53aXRoQ3JlZGVudGlhbHNcclxuXHJcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChhcnJheUJ1ZmZlcikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdW5jID0ganN6bGliX2luZmxhdGVfYnVmZmVyKGFycmF5QnVmZmVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5maWxlUG9zaXRpb24gKz0gKGJzaXplICsgOCk7ICAvLyBcIjhcIiBmb3IgQ1JDLTMyIGFuZCBzaXplIG9mIHVuY29tcHJlc3NlZCBkYXRhXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwodW5jKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpXHJcbiAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuICAgIHZhciBCQU1fTUFHSUMgPSAyMTg0MDE5NDtcclxuICAgIHZhciBTRUNSRVRfREVDT0RFUiA9IFsnPScsICdBJywgJ0MnLCAneCcsICdHJywgJ3gnLCAneCcsICd4JywgJ1QnLCAneCcsICd4JywgJ3gnLCAneCcsICd4JywgJ3gnLCAnTiddO1xyXG4gICAgdmFyIENJR0FSX0RFQ09ERVIgPSBbJ00nLCAnSScsICdEJywgJ04nLCAnUycsICdIJywgJ1AnLCAnPScsICdYJywgJz8nLCAnPycsICc/JywgJz8nLCAnPycsICc/JywgJz8nXTtcclxuICAgIHZhciBSRUFEX1NUUkFORF9GTEFHID0gMHgxMDtcclxuICAgIHZhciBNQVRFX1NUUkFORF9GTEFHID0gMHgyMDtcclxuICAgIHZhciBGSVJTVF9PRl9QQUlSX0ZMQUcgPSAweDQwO1xyXG4gICAgdmFyIFNFQ09ORF9PRl9QQUlSX0ZMQUcgPSAweDgwO1xyXG4gICAgdmFyIFJFQURfVU5NQVBQRURfRkxBRyA9IDB4NDtcclxuICAgIHZhciBNQVRFX1VOTUFQUEVEX0ZMQUcgPSAweDg7XHJcbiAgICB2YXIgUkVBRF9QQUlSRURfRkxBRyA9IDB4MTtcclxuICAgIHZhciBQUk9QRVJfUEFJUl9GTEFHID0gMHgyO1xyXG4gICAgdmFyIFNFQ09OREFSWV9BTElHTk1ORVRfRkxBRyA9IDB4MTAwO1xyXG4gICAgdmFyIFNVUFBMRU1FTlRBUllfQUxJR05NRU5UX0ZMQUcgPSAweDgwMDtcclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXIgTk9UX1BSSU1BUllfQUxJR05NRU5UX0ZMQUcgPSAweDEwMDtcclxuICAgIHZhciBSRUFEX0ZBSUxTX1ZFTkRPUl9RVUFMSVRZX0NIRUNLX0ZMQUcgPSAweDIwMDtcclxuICAgIHZhciBEVVBMSUNBVEVfUkVBRF9GTEFHID0gMHg0MDA7XHJcbiAgICB2YXIgU1VQUExFTUVOVEFSWV9GTEFHID0gMHg4MDA7XHJcblxyXG4gICAgY29uc3QgTUFYX0daSVBfQkxPQ0tfU0laRSA9IDY1NTM2OyAgIC8vICBBUFBBUkVOVExZLiAgV2hlcmUgaXMgdGhpcyBkb2N1bWVudGVkPz8/XHJcbiAgICBjb25zdCBERUZBVUxUX1NBTVBMSU5HX1dJTkRPV19TSVpFID0gMTAwO1xyXG4gICAgY29uc3QgREVGQVVMVF9TQU1QTElOR19ERVBUSCA9IDUwO1xyXG4gICAgY29uc3QgTUFYSU1VTV9TQU1QTElOR19ERVBUSCA9IDI1MDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFzcyBmb3IgcmVhZGluZyBhIGJhbSBmaWxlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuIGNsYXNzIEJhbVJlYWRlcntcclxuICAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuXHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcblxyXG4gICAgICAgIHRoaXMuZmlsdGVyID0gY29uZmlnLmZpbHRlciB8fCBuZXcgQmFtRmlsdGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuYmFtUGF0aCA9IGNvbmZpZy51cmw7XHJcbiAgICAgICAgLy8gVG9kbyAtIGRlYWwgd2l0aCBQaWNhcmQgY29udmVudGlvbi4gIFdIWSBET0VTIFRIRVJFIEhBVkUgVE8gQkUgMj9cclxuICAgICAgICB0aGlzLmJhaVBhdGggPSBjb25maWcuaW5kZXhVUkwgfHwgdGhpcy5iYW1QYXRoICsgXCIuYmFpXCI7IC8vIElmIHRoZXJlIGlzIGFuIGluZGV4VVJMIHByb3ZpZGVkLCB1c2UgaXQhXHJcbiAgICAgICAgdGhpcy5oZWFkUGF0aCA9IGNvbmZpZy5oZWFkVVJMIHx8IHRoaXMuYmFtUGF0aDtcclxuXHJcblxyXG4gICAgICAgIHRoaXMuc2FtcGxpbmdXaW5kb3dTaXplID0gY29uZmlnLnNhbXBsaW5nV2luZG93U2l6ZSA9PT0gdW5kZWZpbmVkID8gREVGQVVMVF9TQU1QTElOR19XSU5ET1dfU0laRSA6IGNvbmZpZy5zYW1wbGluZ1dpbmRvd1NpemU7XHJcbiAgICAgICAgdGhpcy5zYW1wbGluZ0RlcHRoID0gY29uZmlnLnNhbXBsaW5nRGVwdGggPT09IHVuZGVmaW5lZCA/IERFRkFVTFRfU0FNUExJTkdfREVQVEggOiBjb25maWcuc2FtcGxpbmdEZXB0aDtcclxuICAgICAgICBpZih0aGlzLnNhbXBsaW5nRGVwdGggPiBNQVhJTVVNX1NBTVBMSU5HX0RFUFRIKSB7XHJcbiAgICAgICAgICAgIGlndi5sb2coXCJXYXJuaW5nOiBhdHRlbXB0IHRvIHNldCBzYW1wbGluZyBkZXB0aCA+IG1heGltdW0gdmFsdWUgb2YgMjUwMFwiKTtcclxuICAgICAgICAgICAgdGhpcy5zYW1wbGluZ0RlcHRoID0gTUFYSU1VTV9TQU1QTElOR19ERVBUSDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb25maWcudmlld0FzUGFpcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5wYWlyc1N1cHBvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBhaXJzU3VwcG9ydGVkID0gY29uZmlnLnBhaXJzU3VwcG9ydGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnBhaXJzU3VwcG9ydGVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmVhZEFsaWdubWVudHMoY2hyLCBicFN0YXJ0LCBicEVuZCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG5cclxuICAgICAgICAgICAgZ2V0Q2hySW5kZXgoc2VsZikudGhlbihmdW5jdGlvbiAoY2hyVG9JbmRleCkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjaHJJZCA9IGNoclRvSW5kZXhbY2hyXSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Q29udGFpbmVyID0gbmV3IEFsaWdubWVudENvbnRhaW5lcihjaHIsIGJwU3RhcnQsIGJwRW5kLCBzZWxmLnNhbXBsaW5nV2luZG93U2l6ZSwgc2VsZi5zYW1wbGluZ0RlcHRoLCBzZWxmLnBhaXJzU3VwcG9ydGVkKTtcclxuICAgICAgICAgICAgICAgICAgICBjaHJJZD0xMTtcclxuICAgICAgICAgICAgICAgIGlmIChjaHJJZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChhbGlnbm1lbnRDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0SW5kZXgoc2VsZikudGhlbihmdW5jdGlvbiAoYmFtSW5kZXgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaHVua3MgPSBiYW1JbmRleC5ibG9ja3NGb3JSYW5nZShjaHJJZCwgYnBTdGFydCwgYnBFbmQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNodW5rcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChcIkVycm9yIHJlYWRpbmcgYmFtIGluZGV4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGFsaWdubWVudENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmZXRjaE1pbiA9IGMubWludi5ibG9jayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hNYXggPSBjLm1heHYuYmxvY2sgKyBNQVhfR1pJUF9CTE9DS19TSVpFLCAgIC8vIE1ha2Ugc3VyZSB3ZSBnZXQgdGhlIHdob2xlIGJsb2NrLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHtzdGFydDogZmV0Y2hNaW4sIHNpemU6IGZldGNoTWF4IC0gZmV0Y2hNaW4gKyAxfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcihzZWxmLmJhbVBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHNlbGYuY29uZmlnLmhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogcmFuZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHNlbGYuY29uZmlnLndpdGhDcmVkZW50aWFsc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21wcmVzc2VkKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShuZXcgdW5iZ3pmKGNvbXByZXNzZWQpKTsgLy9uZXcgVWludDhBcnJheShpZ3YudW5iZ3pmKGNvbXByZXNzZWQpKTsgLy8sIGMubWF4di5ibG9jayAtIGMubWludi5ibG9jayArIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlQmFtUmVjb3JkcyhiYSwgYy5taW52Lm9mZnNldCwgYWxpZ25tZW50Q29udGFpbmVyLCBicFN0YXJ0LCBicEVuZCwgY2hySWQsIHNlbGYuZmlsdGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoYWxpZ25tZW50Q29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qob2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudENvbnRhaW5lci5maW5pc2goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoYWxpZ25tZW50Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkZWNvZGVCYW1SZWNvcmRzKGJhLCBvZmZzZXQsIGFsaWdubWVudENvbnRhaW5lciwgbWluLCBtYXgsIGNocklkLCBmaWx0ZXIpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBibG9ja1NpemUsXHJcbiAgICAgICAgICAgICAgICBibG9ja0VuZCxcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudCxcclxuICAgICAgICAgICAgICAgIGJsb2NrcyxcclxuICAgICAgICAgICAgICAgIHJlZklELFxyXG4gICAgICAgICAgICAgICAgcG9zLFxyXG4gICAgICAgICAgICAgICAgYm1uLFxyXG4gICAgICAgICAgICAgICAgYmluLFxyXG4gICAgICAgICAgICAgICAgbXEsXHJcbiAgICAgICAgICAgICAgICBubCxcclxuICAgICAgICAgICAgICAgIGZsYWdfbmMsXHJcbiAgICAgICAgICAgICAgICBmbGFnLFxyXG4gICAgICAgICAgICAgICAgbmMsXHJcbiAgICAgICAgICAgICAgICBsc2VxLFxyXG4gICAgICAgICAgICAgICAgbWF0ZVJlZklELFxyXG4gICAgICAgICAgICAgICAgbWF0ZVBvcyxcclxuICAgICAgICAgICAgICAgIHJlYWROYW1lLFxyXG4gICAgICAgICAgICAgICAgaixcclxuICAgICAgICAgICAgICAgIHAsXHJcbiAgICAgICAgICAgICAgICBsZW5ndGhPblJlZixcclxuICAgICAgICAgICAgICAgIGNpZ2FyLFxyXG4gICAgICAgICAgICAgICAgYyxcclxuICAgICAgICAgICAgICAgIGNpZ2FyQXJyYXksXHJcbiAgICAgICAgICAgICAgICBzZXEsXHJcbiAgICAgICAgICAgICAgICBzZXFCeXRlcztcclxuXHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYmxvY2tTaXplID0gcmVhZEludChiYSwgb2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIGJsb2NrRW5kID0gb2Zmc2V0ICsgYmxvY2tTaXplICsgNDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tFbmQgPiBiYS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50ID0gbmV3IEJhbUFsaWdubWVudCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlZklEID0gcmVhZEludChiYSwgb2Zmc2V0ICsgNCk7XHJcbiAgICAgICAgICAgICAgICBwb3MgPSByZWFkSW50KGJhLCBvZmZzZXQgKyA4KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihyZWZJRCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICAgLy8gdW5tYXBwZWQgcmVhZHNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZklEID4gY2hySWQgfHwgcG9zID4gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAgICAvLyBvZmYgcmlnaHQgZWRnZSwgd2UncmUgZG9uZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmSUQgPCBjaHJJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAgIC8vIHRvIGxlZnQgb2Ygc3RhcnQsIG5vdCBzdXJlIHRoaXMgaXMgcG9zc2libGVcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBibW4gPSByZWFkSW50KGJhLCBvZmZzZXQgKyAxMik7XHJcbiAgICAgICAgICAgICAgICBiaW4gPSAoYm1uICYgMHhmZmZmMDAwMCkgPj4gMTY7XHJcbiAgICAgICAgICAgICAgICBtcSA9IChibW4gJiAweGZmMDApID4+IDg7XHJcbiAgICAgICAgICAgICAgICBubCA9IGJtbiAmIDB4ZmY7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxhZ19uYyA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDE2KTtcclxuICAgICAgICAgICAgICAgIGZsYWcgPSAoZmxhZ19uYyAmIDB4ZmZmZjAwMDApID4+IDE2O1xyXG4gICAgICAgICAgICAgICAgbmMgPSBmbGFnX25jICYgMHhmZmZmO1xyXG5cclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC5mbGFncyA9IGZsYWc7XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQuc3RyYW5kID0gIShmbGFnICYgUkVBRF9TVFJBTkRfRkxBRyk7XHJcblxyXG4gICAgICAgICAgICAgICAgbHNlcSA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDIwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBtYXRlUmVmSUQgPSByZWFkSW50KGJhLCBvZmZzZXQgKyAyNCk7XHJcbiAgICAgICAgICAgICAgICBtYXRlUG9zID0gcmVhZEludChiYSwgb2Zmc2V0ICsgMjgpO1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LmZyYWdtZW50TGVuZ3RoID0gcmVhZEludChiYSwgb2Zmc2V0ICsgMzIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlYWROYW1lID0gJyc7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbmwgLSAxOyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICByZWFkTmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhW29mZnNldCArIDM2ICsgal0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHAgPSBvZmZzZXQgKyAzNiArIG5sO1xyXG5cclxuICAgICAgICAgICAgICAgIGxlbmd0aE9uUmVmID0gMDtcclxuICAgICAgICAgICAgICAgIGNpZ2FyID0gJyc7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGNpZ2FyQXJyYXkgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAoYyA9IDA7IGMgPCBuYzsgKytjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNpZ29wID0gcmVhZEludChiYSwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wTGVuID0gKGNpZ29wID4+IDQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcEx0ciA9IENJR0FSX0RFQ09ERVJbY2lnb3AgJiAweGZdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcEx0ciA9PSAnTScgfHwgb3BMdHIgPT0gJ0VRJyB8fCBvcEx0ciA9PSAnWCcgfHwgb3BMdHIgPT0gJ0QnIHx8IG9wTHRyID09ICdOJyB8fCBvcEx0ciA9PSAnPScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aE9uUmVmICs9IG9wTGVuO1xyXG4gICAgICAgICAgICAgICAgICAgIGNpZ2FyID0gY2lnYXIgKyBvcExlbiArIG9wTHRyO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2lnYXJBcnJheS5wdXNoKHtsZW46IG9wTGVuLCBsdHI6IG9wTHRyfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQuY2lnYXIgPSBjaWdhcjtcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC5sZW5ndGhPblJlZiA9IGxlbmd0aE9uUmVmO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQuc3RhcnQgKyBhbGlnbm1lbnQubGVuZ3RoT25SZWYgPCBtaW4pIGNvbnRpbnVlOyAgLy8gUmVjb3JkIG91dC1vZi1yYW5nZSBcInRvIHRoZSBsZWZ0XCIsIHNraXAgdG8gbmV4dCBvbmVcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgc2VxID0gJyc7XHJcbiAgICAgICAgICAgICAgICBzZXFCeXRlcyA9IChsc2VxICsgMSkgPj4gMTtcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBzZXFCeXRlczsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNiID0gYmFbcCArIGpdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcSArPSBTRUNSRVRfREVDT0RFUlsoc2IgJiAweGYwKSA+PiA0XTtcclxuICAgICAgICAgICAgICAgICAgICBzZXEgKz0gU0VDUkVUX0RFQ09ERVJbKHNiICYgMHgwZildO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VxID0gc2VxLnN1YnN0cmluZygwLCBsc2VxKTsgIC8vIHNlcSBtaWdodCBoYXZlIG9uZSBleHRyYSBjaGFyYWN0ZXIgKGlmIGxzZXEgaXMgYW4gb2RkIG51bWJlcilcclxuXHJcbiAgICAgICAgICAgICAgICBwICs9IHNlcUJ5dGVzO1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LnNlcSA9IHNlcTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxzZXEgPT09IDEgJiYgU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwICsgal0gKyAzMykgPT09IFwiKlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyA9PSBob3cgdG8gcmVwcmVzZW50IHRoaXM/XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQucXVhbCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsc2VxOyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50LnF1YWwucHVzaChiYVtwICsgal0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHAgKz0gbHNlcTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LnN0YXJ0ID0gcG9zO1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50Lm1xID0gbXE7XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQucmVhZE5hbWUgPSByZWFkTmFtZTtcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC5jaHIgPSBzZWxmLmluZGV4VG9DaHJbcmVmSURdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtYXRlUmVmSUQgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudC5tYXRlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHI6IHNlbGYuaW5kZXhUb0NoclttYXRlUmVmSURdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogbWF0ZVBvcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyYW5kOiAhKGZsYWcgJiBNQVRFX1NUUkFORF9GTEFHKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC50YWdCQSA9IG5ldyBVaW50OEFycmF5KGJhLmJ1ZmZlci5zbGljZShwLCBibG9ja0VuZCkpOyAgLy8gZGVjb2RlIHRoaWVzZSBvbiBkZW1hbmRcclxuICAgICAgICAgICAgICAgIHAgKz0gYmxvY2tFbmQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFtaW4gfHwgYWxpZ25tZW50LnN0YXJ0IDw9IG1heCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudC5zdGFydCArIGFsaWdubWVudC5sZW5ndGhPblJlZiA+PSBtaW4gJiZcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIucGFzcyhhbGlnbm1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNocklkID09PSB1bmRlZmluZWQgfHwgcmVmSUQgPT0gY2hySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzID0gbWFrZUJsb2NrcyhhbGlnbm1lbnQsIGNpZ2FyQXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQuYmxvY2tzID0gYmxvY2tzLmJsb2NrcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Lmluc2VydGlvbnMgPSBibG9ja3MuaW5zZXJ0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Q29udGFpbmVyLnB1c2goYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBibG9ja0VuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBFeGl0cyB2aWEgdG9wIG9mIGxvb3AuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTcGxpdCB0aGUgYWxpZ25tZW50IHJlY29yZCBpbnRvIGJsb2NrcyBhcyBzcGVjaWZpZWQgaW4gdGhlIGNpZ2FyQXJyYXkuICBFYWNoIGFsaWduZWQgYmxvY2sgY29udGFpbnNcclxuICAgICAgICAgKiBpdHMgcG9ydGlvbiBvZiB0aGUgcmVhZCBzZXF1ZW5jZSBhbmQgYmFzZSBxdWFsaXR5IHN0cmluZ3MuICBBIHJlYWQgc2VxdWVuY2Ugb3IgYmFzZSBxdWFsaXR5IHN0cmluZ1xyXG4gICAgICAgICAqIG9mIFwiKlwiIGluZGljYXRlcyB0aGUgdmFsdWUgaXMgbm90IHJlY29yZGVkLiAgSW4gYWxsIG90aGVyIGNhc2VzIHRoZSBsZW5ndGggb2YgdGhlIGJsb2NrIHNlcXVlbmNlIChibG9jay5zZXEpXHJcbiAgICAgICAgICogYW5kIHF1YWxpdHkgc3RyaW5nIChibG9jay5xdWFsKSBtdXN0ID09IHRoZSBibG9jayBsZW5ndGguXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBOT1RFOiBJbnNlcnRpb25zIGFyZSBub3QgeWV0IHRyZWF0ZWQgLy8gVE9ET1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHJlY29yZFxyXG4gICAgICAgICAqIEBwYXJhbSBjaWdhckFycmF5XHJcbiAgICAgICAgICogQHJldHVybnMgYXJyYXkgb2YgYmxvY2tzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gbWFrZUJsb2NrcyhyZWNvcmQsIGNpZ2FyQXJyYXkpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBibG9ja3MgPSBbXSxcclxuICAgICAgICAgICAgICAgIGluc2VydGlvbnMsXHJcbiAgICAgICAgICAgICAgICBzZXFPZmZzZXQgPSAwLFxyXG4gICAgICAgICAgICAgICAgcG9zID0gcmVjb3JkLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgbGVuID0gY2lnYXJBcnJheS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBibG9ja1NlcSxcclxuICAgICAgICAgICAgICAgIGJsb2NrUXVhbHMsXHJcbiAgICAgICAgICAgICAgICBnYXBUeXBlLFxyXG4gICAgICAgICAgICAgICAgbWluUSA9IDUsICAvL3ByZWZzLmdldEFzSW50KFByZWZlcmVuY2VNYW5hZ2VyLlNBTV9CQVNFX1FVQUxJVFlfTUlOKVxyXG4gICAgICAgICAgICAgICAgbWF4USA9IDIwOyAvL3ByZWZzLmdldEFzSW50KFByZWZlcmVuY2VNYW5hZ2VyLlNBTV9CQVNFX1FVQUxJVFlfTUFYKVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjID0gY2lnYXJBcnJheVtpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGMubHRyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCcgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gaWdub3JlIGhhcmQgY2xpcHNcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdQJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBpZ25vcmUgcGFkc1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1MnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxT2Zmc2V0ICs9IGMubGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXBUeXBlID0gJ1MnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gc29mdCBjbGlwIHJlYWQgYmFzZXNcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSBjLmxlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FwVHlwZSA9ICdOJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7ICAvLyByZWZlcmVuY2Ugc2tpcFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0QnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IGMubGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXBUeXBlID0gJ0QnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdJJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrU2VxID0gcmVjb3JkLnNlcSA9PT0gXCIqXCIgPyBcIipcIiA6IHJlY29yZC5zZXEuc3Vic3RyKHNlcU9mZnNldCwgYy5sZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja1F1YWxzID0gcmVjb3JkLnF1YWwgPyByZWNvcmQucXVhbC5zbGljZShzZXFPZmZzZXQsIGMubGVuKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc2VydGlvbnMgPT09IHVuZGVmaW5lZCkgaW5zZXJ0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRpb25zLnB1c2goe3N0YXJ0OiBwb3MsIGxlbjogYy5sZW4sIHNlcTogYmxvY2tTZXEsIHF1YWw6IGJsb2NrUXVhbHN9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxT2Zmc2V0ICs9IGMubGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRVEnIDpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICc9JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWCcgOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tTZXEgPSByZWNvcmQuc2VxID09PSBcIipcIiA/IFwiKlwiIDogcmVjb3JkLnNlcS5zdWJzdHIoc2VxT2Zmc2V0LCBjLmxlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrUXVhbHMgPSByZWNvcmQucXVhbCA/IHJlY29yZC5xdWFsLnNsaWNlKHNlcU9mZnNldCwgYy5sZW4pIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja3MucHVzaCh7c3RhcnQ6IHBvcywgbGVuOiBjLmxlbiwgc2VxOiBibG9ja1NlcSwgcXVhbDogYmxvY2tRdWFscywgZ2FwVHlwZTogZ2FwVHlwZX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXFPZmZzZXQgKz0gYy5sZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSBjLmxlbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBwcm9jZXNzaW5nIGNpZ2FyIGVsZW1lbnQ6IFwiICsgYy5sZW4gKyBjLmx0cik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7YmxvY2tzOiBibG9ja3MsIGluc2VydGlvbnM6IGluc2VydGlvbnN9O1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVhZEhlYWRlcigpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgZ2V0SW5kZXgoc2VsZikudGhlbihmdW5jdGlvbiAoaW5kZXgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gaW5kZXguZmlyc3RBbGlnbm1lbnRCbG9jayArIE1BWF9HWklQX0JMT0NLX1NJWkU7ICAgLy8gSW5zdXJlIHdlIGdldCB0aGUgY29tcGxldGUgY29tcHJlc3NlZCBibG9jayBjb250YWluaW5nIHRoZSBoZWFkZXJcclxuXHJcbiAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZEFycmF5QnVmZmVyKHNlbGYuYmFtUGF0aCxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHNlbGYuY29uZmlnLmhlYWRlcnMsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZToge3N0YXJ0OiAwLCBzaXplOiBsZW59LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLmNvbmZpZy53aXRoQ3JlZGVudGlhbHNcclxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21wcmVzc2VkQnVmZmVyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1bmMgPSBuZXcgdW5iZ3pmKGNvbXByZXNzZWRCdWZmZXIsIGxlbiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuY2JhID0gbmV3IFVpbnQ4QXJyYXkodW5jKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFnaWMgPSByZWFkSW50KHVuY2JhLCAwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2FtSGVhZGVyTGVuID0gcmVhZEludCh1bmNiYSwgNCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbUhlYWRlciA9ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5vbWUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbUhlYWRlckxlbjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbUhlYWRlciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVuY2JhW2kgKyA4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgblJlZiA9IHJlYWRJbnQodW5jYmEsIHNhbUhlYWRlckxlbiArIDgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gc2FtSGVhZGVyTGVuICsgMTI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2hyVG9JbmRleCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhUb0NociA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJlZjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsTmFtZSA9IHJlYWRJbnQodW5jYmEsIHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxOYW1lIC0gMTsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodW5jYmFbcCArIDQgKyBqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxSZWYgPSByZWFkSW50KHVuY2JhLCBwICsgbE5hbWUgKyA0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9kbG9nKG5hbWUgKyAnOiAnICsgbFJlZik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2Vub21lICYmIGdlbm9tZS5nZXRDaHJvbW9zb21lTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGdlbm9tZS5nZXRDaHJvbW9zb21lTmFtZShuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jaHJUb0luZGV4W25hbWVdID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleFRvQ2hyLnB1c2gobmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcCArIDggKyBsTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufVxyXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXgoYmFtKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYmFtLmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKGJhbS5pbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2FkQmFtSW5kZXgoYmFtLmJhaVBhdGgsIGJhbS5jb25maWcpLnRoZW4oZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFtLmluZGV4ID0gaW5kZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoYmFtLmluZGV4KTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q2hySW5kZXgoYmFtKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYmFtLmNoclRvSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoYmFtLmNoclRvSW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYmFtLnJlYWRIZWFkZXIoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGJhbS5jaHJUb0luZGV4KTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWFkSW50KGJhLCBvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gKGJhW29mZnNldCArIDNdIDw8IDI0KSB8IChiYVtvZmZzZXQgKyAyXSA8PCAxNikgfCAoYmFbb2Zmc2V0ICsgMV0gPDwgOCkgfCAoYmFbb2Zmc2V0XSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVhZFNob3J0KGJhLCBvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gKGJhW29mZnNldCArIDFdIDw8IDgpIHwgKGJhW29mZnNldF0pO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgQmFtU291cmNle1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50Q29udGFpbmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubWF4Um93cyA9IGNvbmZpZy5tYXhSb3dzIHx8IDEwMDA7XHJcbiAgICAgICAgdGhpcy5zZXF1ZW5jZV9zb3VyY2U9bmV3IEZhc3RhU2VxdWVuY2UoY29uZmlnLnNlcV91cmwpO1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnLnNvdXJjZVR5cGUgPT09IFwiZ2E0Z2hcIikge1xyXG4gICAgICAgICAgICB0aGlzLmJhbVJlYWRlciA9IG5ldyBpZ3YuR2E0Z2hBbGlnbm1lbnRSZWFkZXIoY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFtUmVhZGVyID0gbmV3IEJhbVJlYWRlcihjb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICB0aGlzLnZpZXdBc1BhaXJzID0gY29uZmlnLnZpZXdBc1BhaXJzO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZXRWaWV3QXNQYWlycyhib29sKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICBpZiAodGhpcy52aWV3QXNQYWlycyAhPT0gYm9vbCkge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdBc1BhaXJzID0gYm9vbDtcclxuICAgICAgICAgICAgLy8gVE9ETyAtLSByZXBhaXIgYWxpZ25tZW50c1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hbGlnbm1lbnRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbGlnbm1lbnRDb250YWluZXIgPSB0aGlzLmFsaWdubWVudENvbnRhaW5lcixcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRzO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChib29sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50cyA9IHBhaXJBbGlnbm1lbnRzKGFsaWdubWVudENvbnRhaW5lci5wYWNrZWRBbGlnbm1lbnRSb3dzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudHMgPSB1bnBhaXJBbGlnbm1lbnRzKGFsaWdubWVudENvbnRhaW5lci5wYWNrZWRBbGlnbm1lbnRSb3dzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFsaWdubWVudENvbnRhaW5lci5wYWNrZWRBbGlnbm1lbnRSb3dzID0gcGFja0FsaWdubWVudFJvd3MoYWxpZ25tZW50cywgYWxpZ25tZW50Q29udGFpbmVyLnN0YXJ0LCBhbGlnbm1lbnRDb250YWluZXIuZW5kLCBzZWxmLm1heFJvd3MpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRBbGlnbm1lbnRzKGNociwgYnBTdGFydCwgYnBFbmQpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZi5hbGlnbm1lbnRDb250YWluZXIgJiYgc2VsZi5hbGlnbm1lbnRDb250YWluZXIuY29udGFpbnMoY2hyLCBicFN0YXJ0LCBicEVuZCkpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5hbGlnbm1lbnRDb250YWluZXIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuYmFtUmVhZGVyLnJlYWRBbGlnbm1lbnRzKGNociwgYnBTdGFydCwgYnBFbmQpLnRoZW4oZnVuY3Rpb24gKGFsaWdubWVudENvbnRhaW5lcikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4Um93cyA9IHNlbGYuY29uZmlnLm1heFJvd3MgfHwgNTAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRzID0gYWxpZ25tZW50Q29udGFpbmVyLmFsaWdubWVudHM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi52aWV3QXNQYWlycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRzID0gdW5wYWlyQWxpZ25tZW50cyhbe2FsaWdubWVudHM6IGFsaWdubWVudHN9XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIucGFja2VkQWxpZ25tZW50Um93cyA9IHBhY2tBbGlnbm1lbnRSb3dzKGFsaWdubWVudHMsIGFsaWdubWVudENvbnRhaW5lci5zdGFydCwgYWxpZ25tZW50Q29udGFpbmVyLmVuZCwgbWF4Um93cyk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIuYWxpZ25tZW50cyA9IHVuZGVmaW5lZDsgIC8vIERvbid0IG5lZWQgdG8gaG9sZCBvbnRvIHRoZXNlIGFueW1vcmVcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmFsaWdubWVudENvbnRhaW5lciA9IGFsaWdubWVudENvbnRhaW5lcjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICBzZWxmLnNlcXVlbmNlX3NvdXJjZS5nZXRTZXF1ZW5jZShhbGlnbm1lbnRDb250YWluZXIuY2hyLCBhbGlnbm1lbnRDb250YWluZXIuc3RhcnQsIGFsaWdubWVudENvbnRhaW5lci5lbmQpLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzZXF1ZW5jZSkge1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2UpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Q29udGFpbmVyLmNvdmVyYWdlTWFwLnJlZlNlcSA9IHNlcXVlbmNlOyAgICAvLyBUT0RPIC0tIGZpeCB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Q29udGFpbmVyLnNlcXVlbmNlID0gc2VxdWVuY2U7ICAgICAgICAgICAvLyBUT0RPIC0tIGZpeCB0aGlzXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGFsaWdubWVudENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4gICAgZnVuY3Rpb24gcGFpckFsaWdubWVudHMocm93cykge1xyXG5cclxuICAgICAgICB2YXIgcGFpckNhY2hlID0ge30sXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgICAgICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xyXG5cclxuICAgICAgICAgICAgcm93LmFsaWdubWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHBhaXJlZEFsaWdubWVudDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuQmVQYWlyZWQoYWxpZ25tZW50KSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYWlyZWRBbGlnbm1lbnQgPSBwYWlyQ2FjaGVbYWxpZ25tZW50LnJlYWROYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFpcmVkQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJlZEFsaWdubWVudC5zZXRTZWNvbmRBbGlnbm1lbnQoYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpckNhY2hlW2FsaWdubWVudC5yZWFkTmFtZV0gPSB1bmRlZmluZWQ7ICAgLy8gRG9uJ3QgbmVlZCB0byB0cmFjayB0aGlzIGFueW1vcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyZWRBbGlnbm1lbnQgPSBuZXcgaWd2LlBhaXJlZEFsaWdubWVudChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyQ2FjaGVbYWxpZ25tZW50LnJlYWROYW1lXSA9IHBhaXJlZEFsaWdubWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFpcmVkQWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1bnBhaXJBbGlnbm1lbnRzKHJvd3MpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICAgICAgcm93LmFsaWdubWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxpZ25tZW50IGluc3RhbmNlb2YgUGFpcmVkQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWdubWVudC5maXJzdEFsaWdubWVudCkgcmVzdWx0LnB1c2goYWxpZ25tZW50LmZpcnN0QWxpZ25tZW50KTsgIC8vIHNob3VsZG4ndCBuZWVkIHRoZSBudWxsIHRlc3RcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxpZ25tZW50LnNlY29uZEFsaWdubWVudCkgcmVzdWx0LnB1c2goYWxpZ25tZW50LnNlY29uZEFsaWdubWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjYW5CZVBhaXJlZChhbGlnbm1lbnQpIHtcclxuICAgICAgICByZXR1cm4gYWxpZ25tZW50LmlzUGFpcmVkKCkgJiZcclxuICAgICAgICAgICAgYWxpZ25tZW50LmlzTWF0ZU1hcHBlZCgpICYmXHJcbiAgICAgICAgICAgIGFsaWdubWVudC5jaHIgPT09IGFsaWdubWVudC5tYXRlLmNociAmJlxyXG4gICAgICAgICAgICAoYWxpZ25tZW50LmlzRmlyc3RPZlBhaXIoKSB8fCBhbGlnbm1lbnQuaXNTZWNvbmRPZlBhaXIoKSkgJiYgIShhbGlnbm1lbnQuaXNTZWNvbmRhcnkoKSB8fCBhbGlnbm1lbnQuaXNTdXBwbGVtZW50YXJ5KCkpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBwYWNrQWxpZ25tZW50Um93cyhhbGlnbm1lbnRzLCBzdGFydCwgZW5kLCBtYXhSb3dzKSB7XHJcblxyXG4gICAgICAgIGlmICghYWxpZ25tZW50cykgcmV0dXJuO1xyXG5cclxuICAgICAgICBhbGlnbm1lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoYWxpZ25tZW50cy5sZW5ndGggPT09IDApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBidWNrZXRMaXN0ID0gW10sXHJcbiAgICAgICAgICAgICAgICBhbGxvY2F0ZWRDb3VudCA9IDAsXHJcbiAgICAgICAgICAgICAgICBsYXN0QWxsb2NhdGVkQ291bnQgPSAwLFxyXG4gICAgICAgICAgICAgICAgbmV4dFN0YXJ0ID0gc3RhcnQsXHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnRSb3csXHJcbiAgICAgICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgICAgIGJ1Y2tldCxcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudCxcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudFNwYWNlID0gNCAqIDIsXHJcbiAgICAgICAgICAgICAgICBwYWNrZWRBbGlnbm1lbnRSb3dzID0gW10sXHJcbiAgICAgICAgICAgICAgICBidWNrZXRTdGFydCA9IE1hdGgubWF4KHN0YXJ0LCBhbGlnbm1lbnRzWzBdLnN0YXJ0KTtcclxuXHJcbiAgICAgICAgICAgIGFsaWdubWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGJ1Y2tMaXN0SW5kZXggPSBNYXRoLm1heCgwLCBhbGlnbm1lbnQuc3RhcnQgLSBidWNrZXRTdGFydCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVja2V0TGlzdFtidWNrTGlzdEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0TGlzdFtidWNrTGlzdEluZGV4XSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnVja2V0TGlzdFtidWNrTGlzdEluZGV4XS5wdXNoKGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChhbGxvY2F0ZWRDb3VudCA8IGFsaWdubWVudHMubGVuZ3RoICYmIHBhY2tlZEFsaWdubWVudFJvd3MubGVuZ3RoIDwgbWF4Um93cykge1xyXG5cclxuICAgICAgICAgICAgICAgIGFsaWdubWVudFJvdyA9IG5ldyBCYW1BbGlnbm1lbnRSb3coKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dFN0YXJ0IDw9IGVuZCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICghYnVja2V0ICYmIG5leHRTdGFydCA8PSBlbmQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbmV4dFN0YXJ0IC0gYnVja2V0U3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWNrZXRMaXN0W2luZGV4XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK25leHRTdGFydDsgICAgICAgICAgICAgICAgICAgICAvLyBObyBhbGlnbm1lbnRzIGF0IHRoaXMgaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IGJ1Y2tldExpc3RbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gLy8gd2hpbGUgKGJ1Y2tldClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFidWNrZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudCA9IGJ1Y2tldC5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gYnVja2V0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWNrZXRMaXN0W2luZGV4XSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudFJvdy5hbGlnbm1lbnRzLnB1c2goYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhcnQgPSBhbGlnbm1lbnQuc3RhcnQgKyBhbGlnbm1lbnQubGVuZ3RoT25SZWYgKyBhbGlnbm1lbnRTcGFjZTtcclxuICAgICAgICAgICAgICAgICAgICArK2FsbG9jYXRlZENvdW50O1xyXG5cclxuICAgICAgICAgICAgICAgIH0gLy8gd2hpbGUgKG5leHRTdGFydClcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYWxpZ25tZW50Um93LmFsaWdubWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhY2tlZEFsaWdubWVudFJvd3MucHVzaChhbGlnbm1lbnRSb3cpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG5leHRTdGFydCA9IGJ1Y2tldFN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhbGxvY2F0ZWRDb3VudCA9PT0gbGFzdEFsbG9jYXRlZENvdW50KSBicmVhazsgICAvLyBQcm90ZWN0IGZyb20gaW5maW5pdGUgbG9vcHNcclxuXHJcbiAgICAgICAgICAgICAgICBsYXN0QWxsb2NhdGVkQ291bnQgPSBhbGxvY2F0ZWRDb3VudDtcclxuXHJcbiAgICAgICAgICAgIH0gLy8gd2hpbGUgKGFsbG9jYXRlZENvdW50KVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhY2tlZEFsaWdubWVudFJvd3M7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcblxyXG5jbGFzcyBCYW1BbGlnbm1lbnR7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaXNNYXBwZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgUkVBRF9VTk1BUFBFRF9GTEFHKSA9PSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzUGFpcmVkICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBSRUFEX1BBSVJFRF9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzUHJvcGVyUGFpciAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgUFJPUEVSX1BBSVJfRkxBRykgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc0ZpcnN0T2ZQYWlyKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIEZJUlNUX09GX1BBSVJfRkxBRykgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc1NlY29uZE9mUGFpcigpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBTRUNPTkRfT0ZfUEFJUl9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzU2Vjb25kYXJ5KCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIFNFQ09OREFSWV9BTElHTk1ORVRfRkxBRykgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc1N1cHBsZW1lbnRhcnkoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgU1VQUExFTUVOVEFSWV9BTElHTk1FTlRfRkxBRykgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc0ZhaWxzVmVuZG9yUXVhbGl0eUNoZWNrKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIFJFQURfRkFJTFNfVkVORE9SX1FVQUxJVFlfQ0hFQ0tfRkxBRykgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc0R1cGxpY2F0ZSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBEVVBMSUNBVEVfUkVBRF9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzTWF0ZU1hcHBlZCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBNQVRFX1VOTUFQUEVEX0ZMQUcpID09IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaXNOZWdhdGl2ZVN0cmFuZCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBSRUFEX1NUUkFORF9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzTWF0ZU5lZ2F0aXZlU3RyYW5kKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIE1BVEVfU1RSQU5EX0ZMQUcpICE9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgdGFncygpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlVGFncyhiYSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHAgPSAwLFxyXG4gICAgICAgICAgICAgICAgbGVuID0gYmEubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgdGFncyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKHAgPCBsZW4pIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhW3BdKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYmFbcCArIDFdKTtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwICsgMl0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09ICdBJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwICsgM10pO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2knIHx8IHR5cGUgPT09ICdJJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVhZEludChiYSwgcCArIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2MnIHx8IHR5cGUgPT09ICdDJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmFbcCArIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3MnIHx8IHR5cGUgPT09ICdTJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVhZFNob3J0KGJhLCBwICsgMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcCArPSA1O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZicpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPICdGSVhNRSBuZWVkIGZsb2F0cyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZWFkRmxvYXQoYmEsIHAgKyAzKTtcclxuICAgICAgICAgICAgICAgICAgICBwICs9IDc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdaJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gMztcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyA7KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYyA9IGJhW3ArK107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8nVW5rbm93biB0eXBlICcgKyB0eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJ0Vycm9yIHVua25vd24gdHlwZTogJyArIHR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFnc1t0YWddID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0YWdzW3RhZ10gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFncztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy50YWdEaWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRhZ0JBKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ0RpY3QgPSBkZWNvZGVUYWdzKHRoaXMudGFnQkEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50YWdCQSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFnRGljdCA9IHt9OyAgLy8gTWFyayBzbyB3ZSBkb24ndCB0cnkgYWdhaW4uICBUaGUgcmVjb3JkIGhhcyBub3QgdGFnc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZ0RpY3Q7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHBvcHVwRGF0YShnZW5vbWljTG9jYXRpb24pIHtcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlIHVzZXIgY2xpY2tzIG9uIGEgYmFzZSBuZXh0IHRvIGFuIGluc2VydGlvbiwgc2hvdyBqdXN0IHRoZVxyXG4gICAgICAgIC8vIGluc2VydGVkIGJhc2VzIGluIGEgcG9wdXAgKGxpa2UgaW4gZGVza3RvcCBJR1YpLlxyXG4gICAgICAgIHZhciBuYW1lVmFsdWVzID0gW10sIGlzRmlyc3QsIHRhZ0RpY3Q7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuaW5zZXJ0aW9ucykge1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnNlcnRpb25zLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zX3N0YXJ0ID0gdGhpcy5pbnNlcnRpb25zW2ldLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgaWYoZ2Vub21pY0xvY2F0aW9uID09IGluc19zdGFydCB8fCBnZW5vbWljTG9jYXRpb24gPT0gaW5zX3N0YXJ0IC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7bmFtZTogJ0luc2VydGlvbicsIHZhbHVlOiB0aGlzLmluc2VydGlvbnNbaV0uc2VxIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7bmFtZTogJ0xvY2F0aW9uJywgdmFsdWU6IGluc19zdGFydCB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZVZhbHVlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ1JlYWQgTmFtZScsIHZhbHVlOiB0aGlzLnJlYWROYW1lIH0pO1xyXG5cclxuICAgICAgICAvLyBTYW1wbGVcclxuICAgICAgICAvLyBSZWFkIGdyb3VwXHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKFwiPGhyPlwiKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIDEgdG8gZ2Vub21pYyBsb2NhdGlvbiB0byBtYXAgZnJvbSAwLWJhc2VkIGNvbXB1dGVyIHVuaXRzIHRvIHVzZXItYmFzZWQgdW5pdHNcclxuICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnQWxpZ25tZW50IFN0YXJ0JywgdmFsdWU6IGlndi5udW1iZXJGb3JtYXR0ZXIoMSArIHRoaXMuc3RhcnQpLCBib3JkZXJUb3A6IHRydWUgfSk7XHJcblxyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdSZWFkIFN0cmFuZCcsIHZhbHVlOiAodHJ1ZSA9PT0gdGhpcy5zdHJhbmQgPyAnKCspJyA6ICcoLSknKSwgYm9yZGVyVG9wOiB0cnVlIH0pO1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdDaWdhcicsIHZhbHVlOiB0aGlzLmNpZ2FyIH0pO1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdNYXBwZWQnLCB2YWx1ZTogeWVzTm8odGhpcy5pc01hcHBlZCgpKSB9KTtcclxuICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnTWFwcGluZyBRdWFsaXR5JywgdmFsdWU6IHRoaXMubXEgfSk7XHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ1NlY29uZGFyeScsIHZhbHVlOiB5ZXNObyh0aGlzLmlzU2Vjb25kYXJ5KCkpIH0pO1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdTdXBwbGVtZW50YXJ5JywgdmFsdWU6IHllc05vKHRoaXMuaXNTdXBwbGVtZW50YXJ5KCkpIH0pO1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdEdXBsaWNhdGUnLCB2YWx1ZTogeWVzTm8odGhpcy5pc0R1cGxpY2F0ZSgpKSB9KTtcclxuICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnRmFpbGVkIFFDJywgdmFsdWU6IHllc05vKHRoaXMuaXNGYWlsc1ZlbmRvclF1YWxpdHlDaGVjaygpKSB9KTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNQYWlyZWQoKSkge1xyXG4gICAgICAgICAgICBuYW1lVmFsdWVzLnB1c2goXCI8aHI+XCIpO1xyXG4gICAgICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnRmlyc3QgaW4gUGFpcicsIHZhbHVlOiAhdGhpcy5pc1NlY29uZE9mUGFpcigpLCBib3JkZXJUb3A6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdNYXRlIGlzIE1hcHBlZCcsIHZhbHVlOiB5ZXNObyh0aGlzLmlzTWF0ZU1hcHBlZCgpKSB9KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNNYXRlTWFwcGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdNYXRlIENocm9tb3NvbWUnLCB2YWx1ZTogdGhpcy5tYXRlLmNociB9KTtcclxuICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdNYXRlIFN0YXJ0JywgdmFsdWU6ICh0aGlzLm1hdGUucG9zaXRpb24gKyAxKX0pO1xyXG4gICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ01hdGUgU3RyYW5kJywgdmFsdWU6ICh0cnVlID09PSB0aGlzLm1hdGUuc3RyYW5kID8gJygrKScgOiAnKC0pJyl9KTtcclxuICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdJbnNlcnQgU2l6ZScsIHZhbHVlOiB0aGlzLmZyYWdtZW50TGVuZ3RoIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gTWF0ZSBTdGFydFxyXG4gICAgICAgICAgICAgICAgLy8gTWF0ZSBTdHJhbmRcclxuICAgICAgICAgICAgICAgIC8vIEluc2VydCBTaXplXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRmlyc3QgaW4gUGFpclxyXG4gICAgICAgICAgICAvLyBQYWlyIE9yaWVudGF0aW9uXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKFwiPGhyPlwiKTtcclxuICAgICAgICB0YWdEaWN0ID0gdGhpcy50YWdzKCk7XHJcbiAgICAgICAgaXNGaXJzdCA9IHRydWU7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRhZ0RpY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh0YWdEaWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6IGtleSwgdmFsdWU6IHRhZ0RpY3Rba2V5XSwgYm9yZGVyVG9wOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZToga2V5LCB2YWx1ZTogdGFnRGljdFtrZXldIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5hbWVWYWx1ZXM7XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiB5ZXNObyhib29sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBib29sID8gJ1llcycgOiAnTm8nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuXHJcbiAgIFxyXG5cclxuICAgXHJcblxyXG4gICAgZnVuY3Rpb24gcmVhZEZsb2F0KGJhLCBvZmZzZXQpIHtcclxuXHJcbiAgICAgICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJhLmJ1ZmZlciksXHJcbiAgICAgICAgICAgIGxpdHRsZUVuZGlhbiA9IHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhVmlldy5nZXRGbG9hdDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBCYW1GaWx0ZXJ7XHJcblxyXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XHJcbiAgICAgICAgdGhpcy52ZW5kb3JGYWlsZWQgPSBvcHRpb25zLnZlbmRvckZhaWxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMudmVuZG9yRmFpbGVkO1xyXG4gICAgICAgIHRoaXMuZHVwbGljYXRlcyA9IG9wdGlvbnMuZHVwbGljYXRlcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuZHVwbGljYXRlcztcclxuICAgICAgICB0aGlzLnNlY29uZGFyeSA9IG9wdGlvbnMuc2Vjb25kYXJ5IHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3VwcGxlbWVudGFyeSA9IG9wdGlvbnMuc3VwcGxlbWVudGFyeSB8fCBmYWxzZTtcclxuICAgICAgICB0aGlzLm1xVGhyZXNob2xkID0gb3B0aW9ucy5tcVRocmVzaG9sZCA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdGlvbnMubXFUaHJlc2hvbGQ7XHJcbiAgICB9XHJcblxyXG4gICAgcGFzcyhhbGlnbm1lbnQpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudmVuZG9yRmFpbGVkICYmIGFsaWdubWVudC5pc0ZhaWxzVmVuZG9yUXVhbGl0eUNoZWNrKCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5kdXBsaWNhdGVzICYmIGFsaWdubWVudC5pc0R1cGxpY2F0ZSgpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5ICYmIGFsaWdubWVudC5pc1NlY29uZGFyeSgpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuc3VwcGxlbWVudGFyeSAmJiBhbGlnbm1lbnQuaXNTdXBwbGVtZW50YXJ5KCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoYWxpZ25tZW50Lm1xIDwgdGhpcy5tcVRocmVzaG9sZCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcblxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcblxyXG4gICAgdmFyIEJMT0NLX0hFQURFUl9MRU5HVEggPSAxODtcclxuICAgIHZhciBCTE9DS19MRU5HVEhfT0ZGU0VUID0gMTY7ICAvLyBMb2NhdGlvbiBpbiB0aGUgZ3ppcCBibG9jayBvZiB0aGUgdG90YWwgYmxvY2sgc2l6ZSAoYWN0dWFsbHkgdG90YWwgYmxvY2sgc2l6ZSAtIDEpXHJcbiAgICB2YXIgQkxPQ0tfRk9PVEVSX0xFTkdUSCA9IDg7IC8vIE51bWJlciBvZiBieXRlcyB0aGF0IGZvbGxvdyB0aGUgZGVmbGF0ZWQgZGF0YVxyXG4gICAgdmFyIE1BWF9DT01QUkVTU0VEX0JMT0NLX1NJWkUgPSA2NCAqIDEwMjQ7IC8vIFdlIHJlcXVpcmUgdGhhdCBhIGNvbXByZXNzZWQgYmxvY2sgKGluY2x1ZGluZyBoZWFkZXIgYW5kIGZvb3RlciwgYmUgPD0gdGhpcylcclxuICAgIHZhciBHWklQX09WRVJIRUFEID0gQkxPQ0tfSEVBREVSX0xFTkdUSCArIEJMT0NLX0ZPT1RFUl9MRU5HVEggKyAyOyAvLyBHemlwIG92ZXJoZWFkIGlzIHRoZSBoZWFkZXIsIHRoZSBmb290ZXIsIGFuZCB0aGUgYmxvY2sgc2l6ZSAoZW5jb2RlZCBhcyBhIHNob3J0KS5cclxuICAgIHZhciBHWklQX0lEMSA9IDMxOyAgIC8vIE1hZ2ljIG51bWJlclxyXG4gICAgdmFyIEdaSVBfSUQyID0gMTM5OyAgLy8gTWFnaWMgbnVtYmVyXHJcbiAgICB2YXIgR1pJUF9GTEcgPSA0OyAvLyBGRVhUUkEgZmxhZyBtZWFucyB0aGVyZSBhcmUgb3B0aW9uYWwgZmllbGRzXHJcblxyXG5cclxuICAgIC8vIFVuY29tcHJlc3MgZGF0YSwgIGFzc3VtZWQgdG8gYmUgc2VyaWVzIG9mIGJnemlwcGVkIGJsb2Nrc1xyXG4gICAgLy8gQ29kZSBpcyBiYXNlZCBoZWF2aWx5IG9uIGJhbS5qcywgcGFydCBvZiB0aGUgRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlciwgIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMDEuXHJcbmNsYXNzIHVuYmd6ZntcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGxpbSkge1xyXG4gICAgICAgIGZvciAobGV0IGEgaW4gZGF0YSl7XHJcbiAgICAgICAgICAgY29uc29sZS5sb2coYSk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICB2YXIgb0Jsb2NrTGlzdCA9IFtdLFxyXG4gICAgICAgICAgICBwdHIgPSBbMF0sXHJcbiAgICAgICAgICAgIHRvdGFsU2l6ZSA9IDA7XHJcblxyXG4gICAgICAgIGxpbSA9IGxpbSB8fCBkYXRhLmJ5dGVMZW5ndGggLSAxODtcclxuXHJcbiAgICAgICAgd2hpbGUgKHB0clswXSA8IGxpbSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgcHRyWzBdLCAxOCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgeGxlbiA9IChiYVsxMV0gPDwgOCkgfCAoYmFbMTBdKTtcclxuICAgICAgICAgICAgdmFyIHNpMSA9IGJhWzEyXTtcclxuICAgICAgICAgICAgdmFyIHNpMiA9IGJhWzEzXTtcclxuICAgICAgICAgICAgdmFyIHNsZW4gPSAoYmFbMTVdIDw8IDgpIHwgKGJhWzE0XSk7XHJcbiAgICAgICAgICAgIHZhciBic2l6ZSA9IChiYVsxN10gPDwgOCkgfCAoYmFbMTZdKSArIDE7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSAxMiArIHhsZW4gKyBwdHJbMF07ICAgIC8vIFN0YXJ0IG9mIENEQVRBXHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGggLSBzdGFydDtcclxuXHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPCAoYnNpemUgKyA4KSkgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB2YXIgdW5jID0ganN6bGliX2luZmxhdGVfYnVmZmVyKGRhdGEsIHN0YXJ0LCBsZW5ndGgsIHB0cik7XHJcblxyXG4gICAgICAgICAgICBwdHJbMF0gKz0gODsgICAgLy8gU2tpcHBpbmcgQ1JDLTMyIGFuZCBzaXplIG9mIHVuY29tcHJlc3NlZCBkYXRhXHJcblxyXG4gICAgICAgICAgICB0b3RhbFNpemUgKz0gdW5jLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgIG9CbG9ja0xpc3QucHVzaCh1bmMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29uY2F0ZW5hdGUgZGVjb21wcmVzc2VkIGJsb2Nrc1xyXG4gICAgICAgIGlmIChvQmxvY2tMaXN0Lmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvQmxvY2tMaXN0WzBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSh0b3RhbFNpemUpO1xyXG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvQmxvY2tMaXN0Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KG9CbG9ja0xpc3RbaV0pO1xyXG4gICAgICAgICAgICAgICAgYXJyYXlDb3B5KGIsIDAsIG91dCwgY3Vyc29yLCBiLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBjdXJzb3IgKz0gYi5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG91dC5idWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmNsYXNzIEFsaWdubWVudENvbnRhaW5lcntcclxuICAgIGNvbnN0cnVjdG9yKGNociwgc3RhcnQsIGVuZCwgc2FtcGxpbmdXaW5kb3dTaXplLCBzYW1wbGluZ0RlcHRoLCBwYWlyc1N1cHBvcnRlZCkge1xyXG5cclxuICAgICAgICB0aGlzLmNociA9IGNocjtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAoZW5kIC0gc3RhcnQpO1xyXG5cclxuICAgICAgICB0aGlzLmNvdmVyYWdlTWFwID0gbmV3IENvdmVyYWdlTWFwKGNociwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5kb3duc2FtcGxlZEludGVydmFscyA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLnNhbXBsaW5nV2luZG93U2l6ZSA9IHNhbXBsaW5nV2luZG93U2l6ZSA9PT0gdW5kZWZpbmVkID8gMTAwIDogc2FtcGxpbmdXaW5kb3dTaXplO1xyXG4gICAgICAgIHRoaXMuc2FtcGxpbmdEZXB0aCA9IHNhbXBsaW5nRGVwdGggPT09IHVuZGVmaW5lZCA/IDUwIDogc2FtcGxpbmdEZXB0aDtcclxuXHJcbiAgICAgICAgdGhpcy5wYWlyc1N1cHBvcnRlZCA9IHBhaXJzU3VwcG9ydGVkO1xyXG4gICAgICAgIHRoaXMucGFpcmVkID0gZmFsc2U7ICAvLyBmYWxzZSB1bnRpbCBwcm92ZW4gb3RoZXJ3aXNlXHJcbiAgICAgICAgdGhpcy5wYWlyc0NhY2hlID0ge307ICAvLyB3b3JraW5nIGNhY2hlIG9mIHBhaXJlZCBhbGlnbm1lbnRzIGJ5IHJlYWQgbmFtZVxyXG5cclxuICAgICAgICB0aGlzLmRvd25zYW1wbGVkUmVhZHMgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudEJ1Y2tldCA9IG5ldyBEb3duc2FtcGxlQnVja2V0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnQgKyB0aGlzLnNhbXBsaW5nV2luZG93U2l6ZSwgdGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGFsaWdubWVudCkgeyAgICAgICAgIC8vIFRPRE8gLS0gcGFzcyB0aGlzIGluXHJcbiAgICAgICAgICAgIHJldHVybiBhbGlnbm1lbnQuaXNNYXBwZWQoKSAmJiAhYWxpZ25tZW50LmlzRmFpbHNWZW5kb3JRdWFsaXR5Q2hlY2soKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1c2goYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcihhbGlnbm1lbnQpID09PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLmNvdmVyYWdlTWFwLmluY0NvdW50cyhhbGlnbm1lbnQpOyAgIC8vIENvdW50IGNvdmVyYWdlIGJlZm9yZSBhbnkgZG93bnNhbXBsaW5nXHJcblxyXG4gICAgICAgIGlmICh0aGlzLnBhaXJzU3VwcG9ydGVkICYmIHRoaXMuZG93bnNhbXBsZWRSZWFkcy5oYXMoYWxpZ25tZW50LnJlYWROYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm47ICAgLy8gTWF0ZSBhbHJlYWR5IGRvd25zYW1wbGVkIC0tIHBhaXJzIGFyZSB0cmVhdGVkIGFzIGEgc2luZ2xlIGFsaWdubWVudCBmb3IgZG93bnNhbXBsaW5nXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYWxpZ25tZW50LnN0YXJ0ID49IHRoaXMuY3VycmVudEJ1Y2tldC5lbmQpIHtcclxuICAgICAgICAgICAgZmluaXNoQnVja2V0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJ1Y2tldCA9IG5ldyBEb3duc2FtcGxlQnVja2V0KGFsaWdubWVudC5zdGFydCwgYWxpZ25tZW50LnN0YXJ0ICsgdGhpcy5zYW1wbGluZ1dpbmRvd1NpemUsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50QnVja2V0LmFkZEFsaWdubWVudChhbGlnbm1lbnQpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmb3JFYWNoKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRzLmZvckVhY2goY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmlzaCgpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJ1Y2tldCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaEJ1Y2tldC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTmVlZCB0byByZW1vdmUgcGFydGlhbCBwYWlycyB3aG9zZSBtYXRlIHdhcyBkb3duc2FtcGxlZFxyXG4gICAgICAgIGlmKHRoaXMucGFpcnNTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgdmFyIHRtcCA9IFtdLCBkcyA9IHRoaXMuZG93bnNhbXBsZWRSZWFkcztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRzLmhhcyhhLnJlYWROYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB0aGlzLmFsaWdubWVudHMgPSB0bXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmFsaWdubWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnRcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5wYWlyc0NhY2hlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZG93bnNhbXBsZWRSZWFkcyA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBjb250YWlucyhjaHIsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaHIgPT0gY2hyICYmXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPD0gc3RhcnQgJiZcclxuICAgICAgICAgICAgdGhpcy5lbmQgPj0gZW5kO1xyXG4gICAgfVxyXG5cclxuICAgIGhhc0Rvd25zYW1wbGVkSW50ZXJ2YWxzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvd25zYW1wbGVkSW50ZXJ2YWxzICYmIHRoaXMuZG93bnNhbXBsZWRJbnRlcnZhbHMubGVuZ3RoID4gMDtcclxuICAgIH1cclxufVxyXG4gICAgZnVuY3Rpb24gZmluaXNoQnVja2V0KCkge1xyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50cyA9IHRoaXMuYWxpZ25tZW50cy5jb25jYXQodGhpcy5jdXJyZW50QnVja2V0LmFsaWdubWVudHMpO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRCdWNrZXQuZG93bnNhbXBsZWRDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5kb3duc2FtcGxlZEludGVydmFscy5wdXNoKG5ldyBEb3duc2FtcGxlZEludGVydmFsKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QnVja2V0LnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QnVja2V0LmVuZCxcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEJ1Y2tldC5kb3duc2FtcGxlZENvdW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGFpcmVkID0gdGhpcy5wYWlyZWQgfHwgdGhpcy5jdXJyZW50QnVja2V0LnBhaXJlZDtcclxuICAgIH1cclxuXHJcbmNsYXNzIERvd25zYW1wbGVCdWNrZXR7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kLCBhbGlnbm1lbnRDb250YWluZXIpIHtcclxuXHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZG93bnNhbXBsZWRDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5zYW1wbGluZ0RlcHRoID0gYWxpZ25tZW50Q29udGFpbmVyLnNhbXBsaW5nRGVwdGg7XHJcbiAgICAgICAgdGhpcy5wYWlyc1N1cHBvcnRlZCA9IGFsaWdubWVudENvbnRhaW5lci5wYWlyc1N1cHBvcnRlZDtcclxuICAgICAgICB0aGlzLmRvd25zYW1wbGVkUmVhZHMgPSBhbGlnbm1lbnRDb250YWluZXIuZG93bnNhbXBsZWRSZWFkcztcclxuICAgICAgICB0aGlzLnBhaXJzQ2FjaGUgPSBhbGlnbm1lbnRDb250YWluZXIucGFpcnNDYWNoZTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRBbGlnbm1lbnQoYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgIHZhciBzYW1wbGluZ1Byb2IsIGlkeCwgcmVwbGFjZWRBbGlnbm1lbnQsIHBhaXJlZEFsaWdubWVudDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYWxpZ25tZW50cy5sZW5ndGggPCB0aGlzLnNhbXBsaW5nRGVwdGgpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhaXJzU3VwcG9ydGVkICYmIGNhbkJlUGFpcmVkKGFsaWdubWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHBhaXJlZEFsaWdubWVudCA9IHRoaXMucGFpcnNDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhaXJlZEFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vTm90IHN1YmplY3QgdG8gZG93bnNhbXBsaW5nLCBqdXN0IHVwZGF0ZSB0aGUgZXhpc3RpbmcgYWxpZ25tZW50XHJcbiAgICAgICAgICAgICAgICAgICAgcGFpcmVkQWxpZ25tZW50LnNldFNlY29uZEFsaWdubWVudChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnNDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdID0gdW5kZWZpbmVkOyAgIC8vIERvbid0IG5lZWQgdG8gdHJhY2sgdGhpcyBhbnltb3JlLiBOT1RFOiBEb24ndCBcImRlbGV0ZVwiLCBjYXVzZXMgcnVudGltZSBwZXJmb3JtYW5jZSBpc3N1ZXNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IGFsaWdubWVudCBpbiBhIHBhaXJcclxuICAgICAgICAgICAgICAgICAgICBwYWlyZWRBbGlnbm1lbnQgPSBuZXcgUGFpcmVkQWxpZ25tZW50KGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWlyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnNDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdID0gcGFpcmVkQWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50cy5wdXNoKHBhaXJlZEFsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsaWdubWVudHMucHVzaChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBzYW1wbGluZ1Byb2IgPSB0aGlzLnNhbXBsaW5nRGVwdGggLyAodGhpcy5zYW1wbGluZ0RlcHRoICsgdGhpcy5kb3duc2FtcGxlZENvdW50ICsgMSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IHNhbXBsaW5nUHJvYikge1xyXG5cclxuICAgICAgICAgICAgICAgIGlkeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICh0aGlzLmFsaWdubWVudHMubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgICAgICAgICAgcmVwbGFjZWRBbGlnbm1lbnQgPSB0aGlzLmFsaWdubWVudHNbaWR4XTsgICAvLyBUbyBiZSByZXBsYWNlZFxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhaXJzU3VwcG9ydGVkICYmIGNhbkJlUGFpcmVkKGFsaWdubWVudCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5wYWlyc0NhY2hlW3JlcGxhY2VkQWxpZ25tZW50LnJlYWROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnNDYWNoZVtyZXBsYWNlZEFsaWdubWVudC5yZWFkTmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYWlyZWRBbGlnbm1lbnQgPSBuZXcgUGFpcmVkQWxpZ25tZW50KGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWlyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnNDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdID0gcGFpcmVkQWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50c1tpZHhdID0gcGFpcmVkQWxpZ25tZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50c1tpZHhdID0gYWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kb3duc2FtcGxlZFJlYWRzLmFkZChyZXBsYWNlZEFsaWdubWVudC5yZWFkTmFtZSk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb3duc2FtcGxlZFJlYWRzLmFkZChhbGlnbm1lbnQucmVhZE5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRvd25zYW1wbGVkQ291bnQrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuICAgIC8vIFRPRE8gLS0gcmVmYWN0b3IgdGhpcyB0byB1c2UgYW4gb2JqZWN0LCByYXRoZXIgdGhhbiBhbiBhcnJheSwgIGlmIGVuZC1zdGFydCBpcyA+IHNvbWUgdGhyZXNob2xkXHJcbmNsYXNzIENvdmVyYWdlTWFwe1xyXG4gICAgY29uc3RydWN0b3IoY2hyLCBzdGFydCwgZW5kKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY2hyID0gY2hyO1xyXG4gICAgICAgIHRoaXMuYnBTdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gKGVuZCAtIHN0YXJ0KTtcclxuXHJcbiAgICAgICAgdGhpcy5jb3ZlcmFnZSA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIHRoaXMubWF4aW11bSA9IDA7XHJcblxyXG4gICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgaW5jQ291bnRzKGFsaWdubWVudCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIGlmIChhbGlnbm1lbnQuYmxvY2tzID09PSB1bmRlZmluZWQpIHtcclxuXHJcbiAgICAgICAgICAgIGluY0Jsb2NrQ291bnQoYWxpZ25tZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFsaWdubWVudC5ibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcclxuICAgICAgICAgICAgICAgIGluY0Jsb2NrQ291bnQoYmxvY2spO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGluY0Jsb2NrQ291bnQoYmxvY2spIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBrZXksXHJcbiAgICAgICAgICAgICAgICBiYXNlLFxyXG4gICAgICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgICAgIGosXHJcbiAgICAgICAgICAgICAgICBxO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gYmxvY2suc3RhcnQgLSBzZWxmLmJwU3RhcnQsIGogPSAwOyBqIDwgYmxvY2subGVuOyBpKyssIGorKykge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghc2VsZi5jb3ZlcmFnZVtpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY292ZXJhZ2VbaV0gPSBuZXcgQ292ZXJhZ2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBiYXNlID0gYmxvY2suc2VxLmNoYXJBdChqKTtcclxuICAgICAgICAgICAgICAgIGtleSA9IChhbGlnbm1lbnQuc3RyYW5kKSA/IFwicG9zXCIgKyBiYXNlIDogXCJuZWdcIiArIGJhc2U7XHJcbiAgICAgICAgICAgICAgICBxID0gYmxvY2sucXVhbFtqXTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLmNvdmVyYWdlW2ldW2tleV0gKz0gMTtcclxuICAgICAgICAgICAgICAgIHNlbGYuY292ZXJhZ2VbaV1bXCJxdWFsXCIgKyBiYXNlXSArPSBxO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuY292ZXJhZ2VbaV0udG90YWwgKz0gMTtcclxuICAgICAgICAgICAgICAgIHNlbGYuY292ZXJhZ2VbaV0ucXVhbCArPSBxO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYubWF4aW11bSA9IE1hdGgubWF4KHNlbGYuY292ZXJhZ2VbaV0udG90YWwsIHNlbGYubWF4aW11bSk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5Db3ZlcmFnZU1hcC50aHJlc2hvbGQgPSAwLjI7XHJcbkNvdmVyYWdlTWFwLnF1YWxpdHlXZWlnaHQgPSB0cnVlO1xyXG5cclxuY2xhc3MgQ292ZXJhZ2V7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnBvc0EgPSAwO1xyXG4gICAgICAgIHRoaXMubmVnQSA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucG9zVCA9IDA7XHJcbiAgICAgICAgdGhpcy5uZWdUID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5wb3NDID0gMDtcclxuICAgICAgICB0aGlzLm5lZ0MgPSAwO1xyXG4gICAgICAgIHRoaXMucG9zRyA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMubmVnRyA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucG9zTiA9IDA7XHJcbiAgICAgICAgdGhpcy5uZWdOID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xyXG4gICAgICAgIHRoaXMubmVnID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5xdWFsQSA9IDA7XHJcbiAgICAgICAgdGhpcy5xdWFsVCA9IDA7XHJcbiAgICAgICAgdGhpcy5xdWFsQyA9IDA7XHJcbiAgICAgICAgdGhpcy5xdWFsRyA9IDA7XHJcbiAgICAgICAgdGhpcy5xdWFsTiA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucXVhbCA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMudG90YWwgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzTWlzbWF0Y2gocmVmQmFzZSkge1xyXG5cclxuICAgICAgICB2YXIgbXlzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgbWlzbWF0Y2hRdWFsaXR5U3VtLFxyXG4gICAgICAgICAgICB0aHJlc2hvbGQgPSBDb3ZlcmFnZU1hcC50aHJlc2hvbGQgKiAoKENvdmVyYWdlTWFwLnF1YWxpdHlXZWlnaHQgJiYgdGhpcy5xdWFsKSA/IHRoaXMucXVhbCA6IHRoaXMudG90YWwpO1xyXG5cclxuICAgICAgICBtaXNtYXRjaFF1YWxpdHlTdW0gPSAwO1xyXG4gICAgICAgIFtcIkFcIiwgXCJUXCIsIFwiQ1wiLCBcIkdcIl0uZm9yRWFjaChmdW5jdGlvbiAoYmFzZSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKGJhc2UgIT09IHJlZkJhc2UpIHtcclxuICAgICAgICAgICAgICAgIG1pc21hdGNoUXVhbGl0eVN1bSArPSAoKENvdmVyYWdlTWFwLnF1YWxpdHlXZWlnaHQgJiYgbXlzZWxmLnF1YWwpID8gbXlzZWxmW1wicXVhbFwiICsgYmFzZV0gOiAobXlzZWxmW1wicG9zXCIgKyBiYXNlXSArIG15c2VsZltcIm5lZ1wiICsgYmFzZV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbWlzbWF0Y2hRdWFsaXR5U3VtID49IHRocmVzaG9sZDtcclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIERvd25zYW1wbGVkSW50ZXJ2YWx7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kLCBjb3VudHMpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5jb3VudHMgPSBjb3VudHM7XHJcbiAgICB9XHJcblxyXG4gICAgcG9wdXBEYXRhKGdlbm9taWNMb2NhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtuYW1lOiBcInN0YXJ0XCIsIHZhbHVlOiB0aGlzLnN0YXJ0ICsgMX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcImVuZFwiLCB2YWx1ZTogdGhpcy5lbmR9LFxyXG4gICAgICAgICAgICB7bmFtZTogXCIjIGRvd25zYW1wbGVkOlwiLCB2YWx1ZTogdGhpcy5jb3VudHN9XVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuY2xhc3MgUGFpcmVkQWxpZ25tZW50e1xyXG4gICAgY29uc3RydWN0b3IoZmlyc3RBbGlnbm1lbnQpIHtcclxuXHJcbiAgICAgICAgdGhpcy5maXJzdEFsaWdubWVudCA9IGZpcnN0QWxpZ25tZW50O1xyXG4gICAgICAgIHRoaXMuY2hyID0gZmlyc3RBbGlnbm1lbnQuY2hyO1xyXG4gICAgICAgIHRoaXMucmVhZE5hbWUgPSBmaXJzdEFsaWdubWVudC5yZWFkTmFtZTtcclxuXHJcbiAgICAgICAgaWYgKGZpcnN0QWxpZ25tZW50LnN0YXJ0IDwgZmlyc3RBbGlnbm1lbnQubWF0ZS5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gZmlyc3RBbGlnbm1lbnQuc3RhcnQ7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kID0gTWF0aC5tYXgoZmlyc3RBbGlnbm1lbnQubWF0ZS5wb3NpdGlvbiwgZmlyc3RBbGlnbm1lbnQuc3RhcnQgKyBmaXJzdEFsaWdubWVudC5sZW5ndGhPblJlZik7ICAvLyBBcHByb3hpbWF0ZVxyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdTdGFydCA9IGZpcnN0QWxpZ25tZW50LnN0YXJ0ICsgZmlyc3RBbGlnbm1lbnQubGVuZ3RoT25SZWY7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ0VuZCA9IGZpcnN0QWxpZ25tZW50Lm1hdGUucG9zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gZmlyc3RBbGlnbm1lbnQubWF0ZS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5lbmQgPSBmaXJzdEFsaWdubWVudC5zdGFydCArIGZpcnN0QWxpZ25tZW50Lmxlbmd0aE9uUmVmO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdTdGFydCA9IGZpcnN0QWxpZ25tZW50Lm1hdGUucG9zaXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ0VuZCA9IGZpcnN0QWxpZ25tZW50LnN0YXJ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxlbmd0aE9uUmVmID0gdGhpcy5lbmQgLSB0aGlzLnN0YXJ0O1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzZXRTZWNvbmRBbGlnbm1lbnQoYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgIC8vIFRPRE8gLS0gY2hlY2sgdGhlIGNocnMgYXJlIGVxdWFsLCAgZXJyb3Igb3RoZXJ3aXNlXHJcbiAgICAgICAgdGhpcy5zZWNvbmRBbGlnbm1lbnQgPSBhbGlnbm1lbnQ7XHJcblxyXG4gICAgICAgIGlmIChhbGlnbm1lbnQuc3RhcnQgPiB0aGlzLmZpcnN0QWxpZ25tZW50LnN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kID0gYWxpZ25tZW50LnN0YXJ0ICsgYWxpZ25tZW50Lmxlbmd0aE9uUmVmO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdFbmQgPSBhbGlnbm1lbnQuc3RhcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gYWxpZ25tZW50LnN0YXJ0O1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdTdGFydCA9IGFsaWdubWVudC5zdGFydCArIGFsaWdubWVudC5sZW5ndGhPblJlZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZW5ndGhPblJlZiA9IHRoaXMuZW5kIC0gdGhpcy5zdGFydDtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHBvcHVwRGF0YShnZW5vbWljTG9jYXRpb24pIHtcclxuXHJcbiAgICAgICAgdmFyIG5hbWVWYWx1ZXMgPSBbXTtcclxuXHJcbiAgICAgICAgbmFtZVZhbHVlcyA9IG5hbWVWYWx1ZXMuY29uY2F0KHRoaXMuZmlyc3RBbGlnbm1lbnQucG9wdXBEYXRhKGdlbm9taWNMb2NhdGlvbikpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zZWNvbmRBbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcclxuICAgICAgICAgICAgbmFtZVZhbHVlcyA9IG5hbWVWYWx1ZXMuY29uY2F0KHRoaXMuc2Vjb25kQWxpZ25tZW50LnBvcHVwRGF0YShnZW5vbWljTG9jYXRpb24pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5hbWVWYWx1ZXM7XHJcbiAgICB9XHJcblxyXG4gICAgaXNQYWlyZWQgKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBCeSBkZWZpbml0aW9uXHJcbiAgICB9XHJcblxyXG4gICAgZmlyc3RPZlBhaXJTdHJhbmQgKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZpcnN0QWxpZ25tZW50LmlzRmlyc3RPZlBhaXIoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdEFsaWdubWVudC5zdHJhbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2Vjb25kQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlY29uZEFsaWdubWVudC5zdHJhbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdEFsaWdubWVudC5zdHJhbmQ7ICAgICAgICAgIC8vIFRoaXMgYXNzdW1lcyBpbndhcmQgcG9pbnRpbmcgcGFpcnNcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5jbGFzcyBCYW1BbGlnbm1lbnRSb3cge1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLmFsaWdubWVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLnNjb3JlID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmRDZW50ZXJBbGlnbm1lbnQoYnBTdGFydCwgYnBFbmQpIHtcclxuXHJcbiAgICAgICAgdmFyIGNlbnRlckFsaWdubWVudCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLy8gZmluZCBzaW5nbGUgYWxpZ25tZW50IHRoYXQgb3ZlcmxhcHMgc29ydCBsb2NhdGlvblxyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGEpe1xyXG5cclxuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gY2VudGVyQWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKChhLnN0YXJ0ICsgYS5sZW5ndGhPblJlZikgPCBicFN0YXJ0IHx8IGEuc3RhcnQgPiBicEVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyQWxpZ25tZW50ID0gYTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjZW50ZXJBbGlnbm1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlU2NvcmUoZ2Vub21pY0xvY2F0aW9uLCBnZW5vbWljSW50ZXJ2YWwsIHNvcnRPcHRpb24pIHtcclxuXHJcbiAgICAgICAgdGhpcy5zY29yZSA9IHRoaXMuY2FjdWxhdGVTY29yZShnZW5vbWljTG9jYXRpb24sICgxICsgZ2Vub21pY0xvY2F0aW9uKSwgZ2Vub21pY0ludGVydmFsLCBzb3J0T3B0aW9uKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIGNhY3VsYXRlU2NvcmUoYnBTdGFydCwgYnBFbmQsIGdlbm9taWNJbnRlcnZhbCwgc29ydE9wdGlvbikge1xyXG5cclxuICAgICAgICB2YXIgYmFzZVNjb3JlLFxyXG4gICAgICAgICAgICBhbGlnbm1lbnQ7XHJcblxyXG4gICAgICAgIGFsaWdubWVudCA9IHRoaXMuZmluZENlbnRlckFsaWdubWVudChicFN0YXJ0LCBicEVuZCk7XHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gYWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKFwiTlVDTEVPVElERVwiID09PSBzb3J0T3B0aW9uLnNvcnQpIHtcclxuXHJcbiAgICAgICAgICAgIGJhc2VTY29yZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIGFsaWdubWVudC5ibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2VxdWVuY2UgPSBnZW5vbWljSW50ZXJ2YWwuc2VxdWVuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY292ZXJhZ2VNYXAgPSBnZW5vbWljSW50ZXJ2YWwuY292ZXJhZ2VNYXAsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY292ZXJhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgcGhyZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKFwiKlwiICE9PSBibG9jay5zZXEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGluZGV4UmVmZXJlbmNlU2VxdWVuY2UgPSBibG9jay5zdGFydCAtIGdlbm9taWNJbnRlcnZhbC5zdGFydCwgYnBCbG9ja1NlcXVlbmNlID0gYmxvY2suc3RhcnQsIGxlbmd0aEJsb2NrU2VxdWVuY2UgPSBibG9jay5zZXEubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgaSA8IGxlbmd0aEJsb2NrU2VxdWVuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBpKyssIGluZGV4UmVmZXJlbmNlU2VxdWVuY2UrKywgYnBCbG9ja1NlcXVlbmNlKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChicFN0YXJ0ID09PSBicEJsb2NrU2VxdWVuY2UpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2UgPSBzZXF1ZW5jZS5jaGFyQXQoaW5kZXhSZWZlcmVuY2VTZXF1ZW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmxvY2suc2VxLmNoYXJBdChpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZSA9PT0gXCI9XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gcmVmZXJlbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXNlID09PSAnTicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlU2NvcmUgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYmFzZSA9PT0gcmVmZXJlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVNjb3JlID0gMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJhc2UgPT09IFwiWFwiIHx8IGJhc2UgIT09IHJlZmVyZW5jZSl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyYWdlID0gY292ZXJhZ2VNYXAuY292ZXJhZ2VbIChicEJsb2NrU2VxdWVuY2UgLSBjb3ZlcmFnZU1hcC5icFN0YXJ0KSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gY292ZXJhZ2VbIFwicG9zXCIgKyBiYXNlIF0gKyBjb3ZlcmFnZVsgXCJuZWdcIiArIGJhc2UgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaHJlZCA9IChjb3ZlcmFnZS5xdWFsKSA/IGNvdmVyYWdlLnF1YWwgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VTY29yZSA9IC0oY291bnQgKyAocGhyZWQgLyAxMDAwLjApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJCYW1BbGlnbm1lbnRSb3cuY2FjdWxhdGVTY29yZSAtIGh1aD9cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IC8vIGJwU3RhcnQgPT09IGJwQmxvY2tTZXF1ZW5jZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IC8vIGJsb2NrLnNlcS5sZW5ndGhcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlU2NvcmUgPSAzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKHVuZGVmaW5lZCA9PT0gYmFzZVNjb3JlKSA/IE51bWJlci5NQVhfVkFMVUUgOiBiYXNlU2NvcmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFwiU1RSQU5EXCIgPT09IHNvcnRPcHRpb24uc29ydCkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFsaWdubWVudC5zdHJhbmQgPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFwiU1RBUlRcIiA9PT0gc29ydE9wdGlvbi5zb3J0KSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYWxpZ25tZW50LnN0YXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQge2xvYWRCYW1JbmRleCxCYW1SZWFkZXIsQmFtU291cmNlLEJhbUZpbHRlcixCYW1BbGlnbm1lbnQsUGFpcmVkQWxpZ25tZW50fTsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBOzs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7Ozs7OztBQVFBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF0Q0E7QUF3Q0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBSUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFHQTs7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBSUE7Ozs7OztBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/bam.js\n");

/***/ }),

/***/ "./src/bigwig.js":
/*!***********************!*\
  !*** ./src/bigwig.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Zlib) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.BinaryParser = exports.BWSource = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _igvxhr = __webpack_require__(/*! ./igvxhr.js */ \"./src/igvxhr.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//***********js/bigwig/bufferedReader.js*****************\nvar BufferedReader = function () {\n    function BufferedReader(config, contentLength, bufferSize) {\n        _classCallCheck(this, BufferedReader);\n\n        this.path = config.url;\n        this.contentLength = contentLength;\n        this.bufferSize = bufferSize ? bufferSize : 512000;\n        this.range = { start: -1, size: -1 };\n        this.config = config;\n    }\n\n    /**\r\n     *\r\n     * @param requestedRange - byte rangeas {start, size}\r\n     * @param fulfill - function to receive result\r\n     * @param asUint8 - optional flag to return result as an UInt8Array\r\n     */\n\n\n    _createClass(BufferedReader, [{\n        key: \"dataViewForRange\",\n        value: function dataViewForRange(requestedRange, asUint8) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var hasData = self.data && self.range.start <= requestedRange.start && self.range.start + self.range.size >= requestedRange.start + requestedRange.size,\n                    bufferSize,\n                    loadRange;\n\n                if (hasData) {\n                    subbuffer(self, requestedRange, asUint8);\n                } else {\n                    // Expand buffer size if needed, but not beyond content length\n                    bufferSize = Math.max(self.bufferSize, requestedRange.size);\n\n                    if (self.contentLength > 0 && requestedRange.start + bufferSize > self.contentLength) {\n                        loadRange = { start: requestedRange.start };\n                    } else {\n                        loadRange = { start: requestedRange.start, size: bufferSize };\n                    }\n\n                    _igvxhr.igvxhr.loadArrayBuffer(self.path, Object.assign(self.config, { range: loadRange })).then(function (arrayBuffer) {\n                        self.data = arrayBuffer;\n                        self.range = loadRange;\n                        subbuffer(self, requestedRange, asUint8);\n                    }).catch(reject);\n                }\n\n                function subbuffer(bufferedReader, requestedRange, asUint8) {\n\n                    var len = bufferedReader.data.byteLength,\n                        bufferStart = requestedRange.start - bufferedReader.range.start,\n                        result = asUint8 ? new Uint8Array(bufferedReader.data, bufferStart, len - bufferStart) : new DataView(bufferedReader.data, bufferStart, len - bufferStart);\n                    fulfill(result);\n                }\n            });\n        }\n    }]);\n\n    return BufferedReader;\n}();\n\n//**********js/bigwig/bwSource.js***************\n\n\nvar BWSource = function () {\n    function BWSource(config, create_feature_function) {\n        _classCallCheck(this, BWSource);\n\n        this.reader = new BWReader(config);\n        this.bufferedReader = new BufferedReader(config);\n        if (!create_feature_function) {\n            this.create_feature = BWSource.createFeature;\n        } else {\n            this.create_feature = create_feature_function;\n        }\n    }\n\n    /**\r\n    * Creates a panel\r\n    * @param {string} chr - The chromosome\r\n    * @param {int} bpStart The starting postition \r\n    * @param {int} bpEnd - The end of the region to show\r\n    * @param {boolean} use_existing - If true then the cached feature will be used- only used\r\n    * if the co-oridinates have not changed. Although, the BWreader has a cache, it is sometimes\r\n    * ignored and features are re-fetched for the same region\r\n    * @param {object} data - Should contain pixelWidth- the width of the entire canvas and \r\n    * bpPerPixel.\r\n    */\n\n\n    _createClass(BWSource, [{\n        key: \"getFeatures\",\n        value: function getFeatures(chr, bpStart, bpEnd, use_existing, data) {\n            this.st = new Date().getTime();\n            var self = this;\n            return new Promise(function (fulfill, reject) {\n                if (self.features && use_existing) {\n                    fulfill(self.features);\n                    return;\n                }\n                self.reader.getZoomHeaders().then(function (zoomLevelHeaders) {\n\n                    // Select a biwig \"zoom level\" appropriate for the current resolution\n                    var bwReader = self.reader,\n                        bufferedReader = self.bufferedReader,\n                        bpp = data.bpPerPixel,\n                        zoomLevelHeader = BWSource.zoomLevelForScale(bpp, zoomLevelHeaders),\n                        treeOffset;\n\n                    if (zoomLevelHeader && bwReader.type === \"BigWig\") {\n                        treeOffset = zoomLevelHeader.indexOffset;\n                        self.decodeFunction = BWSource.decodeZoomData;\n                    } else {\n                        treeOffset = bwReader.header.fullIndexOffset;\n                        if (bwReader.type === \"BigWig\") {\n                            self.decodeFunction = BWSource.decodeWigData;\n                        } else {\n                            self.decodeFunction = self.decodeBedData;\n                        }\n                    }\n\n                    bwReader.loadRPTree(treeOffset).then(function (rpTree) {\n\n                        var chrIdx = self.reader.chromTree.dictionary[chr];\n                        if (chrIdx === undefined) {\n                            fulfill(null);\n                        } else {\n\n                            rpTree.findLeafItemsOverlapping(chrIdx, bpStart, bpEnd).then(function (leafItems) {\n\n                                var promises = [];\n\n                                if (!leafItems || leafItems.length == 0) fulfill([]);\n\n                                leafItems.forEach(function (item) {\n\n                                    promises.push(new Promise(function (fulfill, reject) {\n                                        var features = [];\n\n                                        bufferedReader.dataViewForRange({\n                                            start: item.dataOffset,\n                                            size: item.dataSize\n                                        }, true).then(function (uint8Array) {\n\n                                            var inflate = new Zlib.Zlib.Inflate(uint8Array);\n                                            var plain = inflate.decompress();\n                                            //var inflate = new pako.Inflate();\n                                            //inflate.push(uint8Array, true);\n                                            //var plain = inflate.result;\n                                            self.decodeFunction(new DataView(plain.buffer), chr, chrIdx, bpStart, bpEnd, features);\n\n                                            fulfill(features);\n                                        }).catch(reject);\n                                    }));\n                                });\n\n                                Promise.all(promises).then(function (featureArrays) {\n                                    var en = new Date().getTime();\n                                    var e = en - self.st;\n                                    var a = bpp;\n                                    console.log(e);\n                                    var i,\n                                        allFeatures = featureArrays[0];\n                                    if (featureArrays.length > 1) {\n                                        for (i = 1; i < featureArrays.length; i++) {\n                                            allFeatures = allFeatures.concat(featureArrays[i]);\n                                        }\n                                    }\n                                    allFeatures.sort(function (a, b) {\n                                        return a.start - b.start;\n                                    });\n                                    self.features = allFeatures;\n                                    fulfill(allFeatures);\n                                }).catch(reject);\n                            }).catch(reject);\n                        }\n                    }).catch(reject);\n                }).catch(reject);\n            });\n        }\n    }, {\n        key: \"getDefaultRange\",\n        value: function getDefaultRange() {\n\n            if (this.reader.totalSummary != undefined) {\n                return this.reader.totalSummary.defaultRange;\n            } else {\n                return undefined;\n            }\n        }\n    }, {\n        key: \"decodeBedData\",\n        value: function decodeBedData(data, chr, chrIdx, bpStart, bpEnd, featureArray) {\n\n            var binaryParser = new BinaryParser(data),\n                minSize = 3 * 4 + 1,\n                // Minimum # of bytes required for a bed record\n            chromId,\n                chromStart,\n                chromEnd,\n                rest,\n                tokens,\n                feature,\n                exonCount,\n                exonSizes,\n                exonStarts,\n                exons,\n                eStart,\n                eEnd;\n\n            while (binaryParser.remLength() >= minSize) {\n\n                chromId = binaryParser.getInt();\n                if (chromId != chrIdx) continue;\n\n                chromStart = binaryParser.getInt();\n                chromEnd = binaryParser.getInt();\n                rest = binaryParser.getString();\n\n                feature = { chr: chr, start: chromStart, end: chromEnd };\n\n                if (chromStart < bpEnd && chromEnd >= bpStart) {\n                    featureArray.push(feature);\n\n                    tokens = rest.split(\"\\t\");\n                    this.create_feature(tokens, feature);\n                }\n            }\n        }\n    }], [{\n        key: \"zoomLevelForScale\",\n        value: function zoomLevelForScale(bpPerPixel, zoomLevelHeaders) {\n\n            var level = null,\n                i,\n                zl;\n\n            for (i = 0; i < zoomLevelHeaders.length; i++) {\n\n                zl = zoomLevelHeaders[i];\n\n                if (zl.reductionLevel > bpPerPixel) {\n                    level = zl;\n                    break;\n                }\n            }\n\n            if (null == level) {\n                level = zoomLevelHeaders[zoomLevelHeaders.length - 1];\n            }\n\n            return level && level.reductionLevel < 4 * bpPerPixel ? level : null;\n        }\n    }, {\n        key: \"decodeWigData\",\n        value: function decodeWigData(data, chr, chrIdx, bpStart, bpEnd, featureArray) {\n\n            var binaryParser = new BinaryParser(data),\n                chromId = binaryParser.getInt(),\n                chromStart = binaryParser.getInt(),\n                chromEnd = binaryParser.getInt(),\n                itemStep = binaryParser.getInt(),\n                itemSpan = binaryParser.getInt(),\n                type = binaryParser.getByte(),\n                reserved = binaryParser.getByte(),\n                itemCount = binaryParser.getUShort(),\n                value;\n\n            if (chromId === chrIdx) {\n\n                while (itemCount-- > 0) {\n\n                    switch (type) {\n                        case 1:\n                            chromStart = binaryParser.getInt();\n                            chromEnd = binaryParser.getInt();\n                            value = binaryParser.getFloat();\n                            break;\n                        case 2:\n                            chromStart = binaryParser.getInt();\n                            value = binaryParser.getFloat();\n                            chromEnd = chromStart + itemSpan;\n                            break;\n                        case 3:\n                            // Fixed step\n                            value = binaryParser.getFloat();\n                            chromEnd = chromStart + itemSpan;\n                            chromStart += itemStep;\n                            break;\n\n                    }\n\n                    if (chromStart >= bpEnd) {\n                        break; // Out of interval\n                    } else if (chromEnd > bpStart && Number.isFinite(value)) {\n                        featureArray.push({ chr: chr, start: chromStart, end: chromEnd, value: value });\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"decodeZoomData\",\n        value: function decodeZoomData(data, chr, chrIdx, bpStart, bpEnd, featureArray) {\n\n            var binaryParser = new BinaryParser(data),\n                minSize = 8 * 4,\n                // Minimum # of bytes required for a zoom record\n            chromId,\n                chromStart,\n                chromEnd,\n                validCount,\n                minVal,\n                maxVal,\n                sumData,\n                sumSquares,\n                value;\n\n            while (binaryParser.remLength() >= minSize) {\n                chromId = binaryParser.getInt();\n                if (chromId === chrIdx) {\n\n                    chromStart = binaryParser.getInt();\n                    chromEnd = binaryParser.getInt();\n                    validCount = binaryParser.getInt();\n                    minVal = binaryParser.getFloat();\n                    maxVal = binaryParser.getFloat();\n                    sumData = binaryParser.getFloat();\n                    sumSquares = binaryParser.getFloat();\n                    value = validCount == 0 ? 0 : sumData / validCount;\n\n                    if (chromStart >= bpEnd) {\n                        break; // Out of interval\n                    } else if (chromEnd > bpStart && Number.isFinite(value)) {\n                        featureArray.push({ chr: chr, start: chromStart, end: chromEnd, value: value });\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"createFeature\",\n        value: function createFeature(tokens, feature) {\n            if (tokens.length > 0) {\n                feature.name = tokens[0];\n            }\n\n            if (tokens.length > 1) {\n                feature.score = parseFloat(tokens[1]);\n            }\n            if (tokens.length > 2) {\n                feature.strand = tokens[2];\n            }\n            if (tokens.length > 3) {\n                feature.cdStart = parseInt(tokens[3]);\n            }\n            if (tokens.length > 4) {\n                feature.cdEnd = parseInt(tokens[4]);\n            }\n            if (tokens.length > 5) {\n                if (tokens[5] !== \".\" && tokens[5] !== \"0\") feature.color = igv.createColorString(tokens[5]);\n            }\n            if (tokens.length > 8) {\n                exonCount = parseInt(tokens[6]);\n                exonSizes = tokens[7].split(',');\n                exonStarts = tokens[8].split(',');\n                exons = [];\n\n                for (var i = 0; i < exonCount; i++) {\n                    eStart = start + parseInt(exonStarts[i]);\n                    eEnd = eStart + parseInt(exonSizes[i]);\n                    exons.push({ start: eStart, end: eEnd });\n                }\n\n                feature.exons = exons;\n            }\n        }\n    }]);\n\n    return BWSource;\n}();\n\n//************js/bigwig/bwReader.js*****************\n\n\nvar BIGWIG_MAGIC_LTH = 0x888FFC26; // BigWig Magic Low to High\nvar BIGWIG_MAGIC_HTL = 0x26FC8F66; // BigWig Magic High to Low\nvar BIGBED_MAGIC_LTH = 0x8789F2EB; // BigBed Magic Low to High\nvar BIGBED_MAGIC_HTL = 0xEBF28987; // BigBed Magic High to Low\nvar BBFILE_HEADER_SIZE = 64;\n\nvar BWReader = function () {\n    function BWReader(config) {\n        _classCallCheck(this, BWReader);\n\n        this.path = config.url;\n        this.headPath = config.headURL || this.path;\n        this.rpTreeCache = {};\n        this.config = config;\n    }\n\n    _createClass(BWReader, [{\n        key: \"getZoomHeaders\",\n        value: function getZoomHeaders() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                if (self.zoomLevelHeaders) {\n                    fulfill(self.zoomLevelHeaders);\n                } else {\n                    self.loadHeader().then(function () {\n                        fulfill(self.zoomLevelHeaders);\n                    }).catch(function (error) {\n                        reject(error);\n                    });\n                }\n            });\n        }\n    }, {\n        key: \"loadHeader\",\n        value: function loadHeader() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                _igvxhr.igvxhr.loadArrayBuffer(self.path, Object.assign(self.config, { range: { start: 0, size: BBFILE_HEADER_SIZE } })).then(function (data) {\n\n                    if (!data) return;\n\n                    // Assume low-to-high unless proven otherwise\n                    self.littleEndian = true;\n\n                    var binaryParser = new BinaryParser(new DataView(data));\n\n                    var magic = binaryParser.getUInt();\n\n                    if (magic === BIGWIG_MAGIC_LTH) {\n                        self.type = \"BigWig\";\n                    } else if (magic == BIGBED_MAGIC_LTH) {\n                        self.type = \"BigBed\";\n                    } else {\n                        //Try big endian order\n                        self.littleEndian = false;\n\n                        binaryParser.littleEndian = false;\n                        binaryParser.position = 0;\n                        var magic = binaryParser.getUInt();\n\n                        if (magic === BIGWIG_MAGIC_HTL) {\n                            self.type = \"BigWig\";\n                        } else if (magic == BIGBED_MAGIC_HTL) {\n                            self.type = \"BigBed\";\n                        } else {\n                            // TODO -- error, unknown file type  or BE\n                        }\n                    }\n                    // Table 5  \"Common header for BigWig and BigBed files\"\n                    self.header = {};\n                    self.header.bwVersion = binaryParser.getUShort();\n                    self.header.nZoomLevels = binaryParser.getUShort();\n                    self.header.chromTreeOffset = binaryParser.getLong();\n                    self.header.fullDataOffset = binaryParser.getLong();\n                    self.header.fullIndexOffset = binaryParser.getLong();\n                    self.header.fieldCount = binaryParser.getUShort();\n                    self.header.definedFieldCount = binaryParser.getUShort();\n                    self.header.autoSqlOffset = binaryParser.getLong();\n                    self.header.totalSummaryOffset = binaryParser.getLong();\n                    self.header.uncompressBuffSize = binaryParser.getInt();\n                    self.header.reserved = binaryParser.getLong();\n\n                    self.loadZoomHeadersAndChrTree().then(fulfill).catch(reject);\n                }).catch(function (error) {\n                    reject(error);\n                });\n            });\n        }\n    }, {\n        key: \"loadZoomHeadersAndChrTree\",\n        value: function loadZoomHeadersAndChrTree() {\n\n            var startOffset = BBFILE_HEADER_SIZE,\n                self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                var range = { start: startOffset, size: self.header.fullDataOffset - startOffset + 5 };\n\n                _igvxhr.igvxhr.loadArrayBuffer(self.path, Object.assign(self.config, { range: range })).then(function (data) {\n\n                    var nZooms = self.header.nZoomLevels,\n                        binaryParser = new BinaryParser(new DataView(data)),\n                        i,\n                        len,\n                        zoomNumber,\n                        zlh;\n\n                    self.zoomLevelHeaders = [];\n\n                    self.firstZoomDataOffset = Number.MAX_VALUE;\n                    for (i = 0; i < nZooms; i++) {\n                        zoomNumber = nZooms - i;\n                        zlh = new ZoomLevelHeader(zoomNumber, binaryParser);\n                        self.firstZoomDataOffset = Math.min(zlh.dataOffset, self.firstZoomDataOffset);\n                        self.zoomLevelHeaders.push(zlh);\n                    }\n\n                    // Autosql\n                    if (self.header.autoSqlOffset > 0) {\n                        binaryParser.position = self.header.autoSqlOffset - startOffset;\n                        self.autoSql = binaryParser.getString();\n                    }\n\n                    // Total summary\n                    if (self.header.totalSummaryOffset > 0) {\n                        binaryParser.position = self.header.totalSummaryOffset - startOffset;\n                        self.totalSummary = new BWTotalSummary(binaryParser);\n                    }\n\n                    // Chrom data index\n                    if (self.header.chromTreeOffset > 0) {\n                        binaryParser.position = self.header.chromTreeOffset - startOffset;\n                        self.chromTree = new BPTree(binaryParser, startOffset);\n                    } else {}\n                    // TODO -- this is an error, not expected\n\n\n                    //Finally total data count\n                    binaryParser.position = self.header.fullDataOffset - startOffset;\n                    self.dataCount = binaryParser.getInt();\n\n                    fulfill();\n                }).catch(reject);\n            });\n        }\n    }, {\n        key: \"loadRPTree\",\n        value: function loadRPTree(offset) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var rpTree = self.rpTreeCache[offset];\n                if (rpTree) {\n                    fulfill(rpTree);\n                } else {\n                    rpTree = new RPTree(offset, self.contentLength, self.config, self.littleEndian);\n                    self.rpTreeCache[offset] = rpTree;\n                    rpTree.load().then(function () {\n                        fulfill(rpTree);\n                    }).catch(reject);\n                }\n            });\n        }\n    }]);\n\n    return BWReader;\n}();\n\nvar ZoomLevelHeader = function ZoomLevelHeader(index, byteBuffer) {\n    _classCallCheck(this, ZoomLevelHeader);\n\n    this.index = index;\n    this.reductionLevel = byteBuffer.getInt();\n    this.reserved = byteBuffer.getInt();\n    this.dataOffset = byteBuffer.getLong();\n    this.indexOffset = byteBuffer.getLong();\n};\n\nvar RPTREE_MAGIC_LTH = 0x2468ACE0;\nvar RPTREE_MAGIC_HTL = 0xE0AC6824;\nvar RPTREE_HEADER_SIZE = 48;\nvar RPTREE_NODE_LEAF_ITEM_SIZE = 32; // leaf item size\nvar RPTREE_NODE_CHILD_ITEM_SIZE = 24; // child item size\nvar BUFFER_SIZE = 512000;\n\n//***********js/bigwig/RPTree*******************\n\n\n//  buffer\n\nvar RPTree = function () {\n    function RPTree(fileOffset, contentLength, config, littleEndian) {\n        _classCallCheck(this, RPTree);\n\n        this.config = config;\n        this.filesize = contentLength;\n        this.fileOffset = fileOffset; // File offset to beginning of tree\n        this.path = config.url;\n        this.littleEndian = littleEndian;\n    }\n\n    _createClass(RPTree, [{\n        key: \"load\",\n        value: function load() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var rootNodeOffset = self.fileOffset + RPTREE_HEADER_SIZE,\n                    bufferedReader = new BufferedReader(self.config, self.filesize, BUFFER_SIZE);\n\n                self.readNode(rootNodeOffset, bufferedReader).then(function (node) {\n                    self.rootNode = node;\n                    fulfill(self);\n                }).catch(reject);\n            });\n        }\n    }, {\n        key: \"readNode\",\n        value: function readNode(filePosition, bufferedReader) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                bufferedReader.dataViewForRange({ start: filePosition, size: 4 }, false).then(function (dataView) {\n                    var binaryParser = new BinaryParser(dataView, self.littleEndian);\n\n                    var type = binaryParser.getByte();\n                    var isLeaf = type === 1 ? true : false;\n                    var reserved = binaryParser.getByte();\n                    var count = binaryParser.getUShort();\n\n                    filePosition += 4;\n\n                    var bytesRequired = count * (isLeaf ? RPTREE_NODE_LEAF_ITEM_SIZE : RPTREE_NODE_CHILD_ITEM_SIZE);\n                    var range2 = { start: filePosition, size: bytesRequired };\n\n                    bufferedReader.dataViewForRange(range2, false).then(function (dataView) {\n\n                        var i,\n                            items = new Array(count),\n                            binaryParser = new BinaryParser(dataView);\n\n                        if (isLeaf) {\n                            for (i = 0; i < count; i++) {\n                                var item = {\n                                    isLeaf: true,\n                                    startChrom: binaryParser.getInt(),\n                                    startBase: binaryParser.getInt(),\n                                    endChrom: binaryParser.getInt(),\n                                    endBase: binaryParser.getInt(),\n                                    dataOffset: binaryParser.getLong(),\n                                    dataSize: binaryParser.getLong()\n                                };\n                                items[i] = item;\n                            }\n                            fulfill(new RPTreeNode(items));\n                        } else {\n                            // non-leaf\n                            for (i = 0; i < count; i++) {\n\n                                var item = {\n                                    isLeaf: false,\n                                    startChrom: binaryParser.getInt(),\n                                    startBase: binaryParser.getInt(),\n                                    endChrom: binaryParser.getInt(),\n                                    endBase: binaryParser.getInt(),\n                                    childOffset: binaryParser.getLong()\n                                };\n                                items[i] = item;\n                            }\n\n                            fulfill(new RPTreeNode(items));\n                        }\n                    }).catch(reject);\n                }).catch(reject);\n            });\n        }\n    }, {\n        key: \"findLeafItemsOverlapping\",\n        value: function findLeafItemsOverlapping(chrIdx, startBase, endBase) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                var leafItems = [],\n                    processing = new Set(),\n                    bufferedReader = new BufferedReader(self.config, self.filesize, BUFFER_SIZE);\n\n                processing.add(0); // Zero represents the root node\n                findLeafItems(self.rootNode, 0);\n\n                function findLeafItems(node, nodeId) {\n\n                    if (RPTree.overlaps(node, chrIdx, startBase, endBase)) {\n\n                        var items = node.items;\n\n                        items.forEach(function (item) {\n\n                            if (RPTree.overlaps(item, chrIdx, startBase, endBase)) {\n\n                                if (item.isLeaf) {\n                                    leafItems.push(item);\n                                } else {\n                                    if (item.childNode) {\n                                        findLeafItems(item.childNode);\n                                    } else {\n                                        processing.add(item.childOffset); // Represent node to-be-loaded by its file position\n                                        self.readNode(item.childOffset, bufferedReader).then(function (node) {\n                                            item.childNode = node;\n                                            findLeafItems(node, item.childOffset);\n                                        }).catch(reject);\n                                    }\n                                }\n                            }\n                        });\n                    }\n\n                    if (nodeId != undefined) processing.delete(nodeId);\n\n                    // Wait until all nodes are processed\n                    if (processing.size === 0) {\n                        fulfill(leafItems);\n                    }\n                }\n            });\n        }\n\n        /**\r\n         * Return true if {chrIdx:startBase-endBase} overlaps item's interval\r\n         * @returns {boolean}\r\n         */\n\n    }], [{\n        key: \"overlaps\",\n        value: function overlaps(item, chrIdx, startBase, endBase) {\n\n            //  if (chrIdx > item.endChrom || chrIdx < item.startChrom) return false;\n\n            if (!item) {\n                console.log(\"null item\");\n                return false;\n            }\n\n            return (chrIdx > item.startChrom || chrIdx == item.startChrom && endBase >= item.startBase) && (chrIdx < item.endChrom || chrIdx == item.endChrom && startBase < item.endBase);\n        }\n    }]);\n\n    return RPTree;\n}();\n\nvar RPTreeNode = function RPTreeNode(items) {\n    _classCallCheck(this, RPTreeNode);\n\n    this.items = items;\n\n    var minChromId = Number.MAX_VALUE,\n        maxChromId = 0,\n        minStartBase = Number.MAX_VALUE,\n        maxEndBase = 0,\n        i,\n        item;\n\n    for (i = 0; i < items.length; i++) {\n        item = items[i];\n        minChromId = Math.min(minChromId, item.startChrom);\n        maxChromId = Math.max(maxChromId, item.endChrom);\n        minStartBase = Math.min(minStartBase, item.startBase);\n        maxEndBase = Math.max(maxEndBase, item.endBase);\n    }\n\n    this.startChrom = minChromId;\n    this.endChrom = maxChromId;\n    this.startBase = minStartBase;\n    this.endBase = maxEndBase;\n};\n\n//*******************js/binary.js******************\n\n\nvar BinaryParser = function () {\n    function BinaryParser(dataView, littleEndian) {\n        _classCallCheck(this, BinaryParser);\n\n        this.littleEndian = littleEndian ? littleEndian : true;\n        this.position = 0;\n        this.view = dataView;\n        this.length = dataView.byteLength;\n    }\n\n    _createClass(BinaryParser, [{\n        key: \"available\",\n        value: function available() {\n            return this.length - this.position;\n        }\n    }, {\n        key: \"remLength\",\n        value: function remLength() {\n            return this.length - this.position;\n        }\n    }, {\n        key: \"hasNext\",\n        value: function hasNext() {\n            return this.position < this.length - 1;\n        }\n    }, {\n        key: \"getByte\",\n        value: function getByte() {\n            var retValue = this.view.getUint8(this.position, this.littleEndian);\n            this.position++;\n            return retValue;\n        }\n    }, {\n        key: \"getShort\",\n        value: function getShort() {\n\n            var retValue = this.view.getInt16(this.position, this.littleEndian);\n            this.position += 2;\n            return retValue;\n        }\n    }, {\n        key: \"getUShort\",\n        value: function getUShort() {\n\n            // var byte1 = this.getByte(),\n            //     byte2 = this.getByte(),\n            //     retValue = ((byte2 << 24 >>> 16) + (byte1 << 24 >>> 24));\n            //     return retValue;\n\n            //\n            var retValue = this.view.getUint16(this.position, this.littleEndian);\n            this.position += 2;\n            return retValue;\n        }\n    }, {\n        key: \"getInt\",\n        value: function getInt() {\n\n            var retValue = this.view.getInt32(this.position, this.littleEndian);\n            this.position += 4;\n            return retValue;\n        }\n    }, {\n        key: \"getUInt\",\n        value: function getUInt() {\n            var retValue = this.view.getUint32(this.position, this.littleEndian);\n            this.position += 4;\n            return retValue;\n        }\n    }, {\n        key: \"getLong\",\n        value: function getLong() {\n\n            // DataView doesn't support long. So we'll try manually\n\n            var b = [];\n            b[0] = this.view.getUint8(this.position);\n            b[1] = this.view.getUint8(this.position + 1);\n            b[2] = this.view.getUint8(this.position + 2);\n            b[3] = this.view.getUint8(this.position + 3);\n            b[4] = this.view.getUint8(this.position + 4);\n            b[5] = this.view.getUint8(this.position + 5);\n            b[6] = this.view.getUint8(this.position + 6);\n            b[7] = this.view.getUint8(this.position + 7);\n\n            var value = 0;\n            if (this.littleEndian) {\n                for (var i = b.length - 1; i >= 0; i--) {\n                    value = value * 256 + b[i];\n                }\n            } else {\n                for (var i = 0; i < b.length; i++) {\n                    value = value * 256 + b[i];\n                }\n            }\n\n            this.position += 8;\n            return value;\n        }\n    }, {\n        key: \"getString\",\n        value: function getString(len) {\n\n            var s = \"\";\n            var c;\n            while ((c = this.view.getUint8(this.position++)) != 0) {\n                s += String.fromCharCode(c);\n                if (len && s.length == len) break;\n            }\n            return s;\n        }\n    }, {\n        key: \"getFixedLengthString\",\n        value: function getFixedLengthString(len) {\n\n            var s = \"\";\n            var i;\n            var c;\n            for (i = 0; i < len; i++) {\n                c = this.view.getUint8(this.position++);\n                if (c > 0) {\n                    s += String.fromCharCode(c);\n                }\n            }\n            return s;\n        }\n    }, {\n        key: \"getFixedLengthTrimmedString\",\n        value: function getFixedLengthTrimmedString(len) {\n\n            var s = \"\";\n            var i;\n            var c;\n            for (i = 0; i < len; i++) {\n                c = this.view.getUint8(this.position++);\n                if (c > 32) {\n                    s += String.fromCharCode(c);\n                }\n            }\n            return s;\n        }\n    }, {\n        key: \"getFloat\",\n        value: function getFloat() {\n\n            var retValue = this.view.getFloat32(this.position, this.littleEndian);\n            this.position += 4;\n            return retValue;\n        }\n    }, {\n        key: \"getDouble\",\n        value: function getDouble() {\n\n            var retValue = this.view.getFloat64(this.position, this.littleEndian);\n            this.position += 8;\n            return retValue;\n        }\n    }, {\n        key: \"skip\",\n        value: function skip(n) {\n\n            this.position += n;\n            return this.position;\n        }\n\n        /**\r\n         * Return a bgzip (bam and tabix) virtual pointer\r\n         * TODO -- why isn't 8th byte used ?\r\n         * @returns {*}\r\n         */\n\n    }, {\n        key: \"getVPointer\",\n        value: function getVPointer() {\n\n            var position = this.position,\n                offset = this.view.getUint8(position + 1) << 8 | this.view.getUint8(position),\n                byte6 = (this.view.getUint8(position + 6) & 0xff) * 0x100000000,\n                byte5 = (this.view.getUint8(position + 5) & 0xff) * 0x1000000,\n                byte4 = (this.view.getUint8(position + 4) & 0xff) * 0x10000,\n                byte3 = (this.view.getUint8(position + 3) & 0xff) * 0x100,\n                byte2 = this.view.getUint8(position + 2) & 0xff,\n                block = byte6 + byte5 + byte4 + byte3 + byte2;\n            this.position += 8;\n\n            //       if (block == 0 && offset == 0) {\n            //           return null;\n            //       } else {\n            return new VPointer(block, offset);\n            //       }\n        }\n    }]);\n\n    return BinaryParser;\n}();\n\nvar VPointer = function () {\n    function VPointer(block, offset) {\n        _classCallCheck(this, VPointer);\n\n        this.block = block;\n        this.offset = offset;\n    }\n\n    _createClass(VPointer, [{\n        key: \"isLessThan\",\n        value: function isLessThan(vp) {\n            return this.block < vp.block || this.block === vp.block && this.offset < vp.offset;\n        }\n    }, {\n        key: \"isGreaterThan\",\n        value: function isGreaterThan(vp) {\n            return this.block > vp.block || this.block === vp.block && this.offset > vp.offset;\n        }\n    }, {\n        key: \"print\",\n        value: function print() {\n            return \"\" + this.block + \":\" + this.offset;\n        }\n    }]);\n\n    return VPointer;\n}();\n\n//*******js/bigwig/bwTotalSummary.js*************\n\n\nvar BWTotalSummary = function () {\n    function BWTotalSummary(byteBuffer) {\n        _classCallCheck(this, BWTotalSummary);\n\n        if (byteBuffer) {\n\n            this.basesCovered = byteBuffer.getLong();\n            this.minVal = byteBuffer.getDouble();\n            this.maxVal = byteBuffer.getDouble();\n            this.sumData = byteBuffer.getDouble();\n            this.sumSquares = byteBuffer.getDouble();\n\n            this.computeStats();\n        } else {\n            this.basesCovered = 0;\n            this.minVal = 0;\n            this.maxVal = 0;\n            this.sumData = 0;\n            this.sumSquares = 0;\n            this.mean = 0;\n            this.stddev = 0;\n        }\n    }\n\n    _createClass(BWTotalSummary, [{\n        key: \"computeStats\",\n        value: function computeStats() {\n            var n = this.basesCovered;\n            if (n > 0) {\n                this.mean = this.sumData / n;\n                this.stddev = Math.sqrt(this.sumSquares / (n - 1));\n\n                var min = this.minVal < 0 ? this.mean - 2 * this.stddev : 0,\n                    max = this.maxVal > 0 ? this.mean + 2 * this.stddev : 0;\n\n                this.defaultRange = {\n                    min: 0,\n                    max: this.mean + 3 * this.stddev\n                };\n            }\n        }\n    }, {\n        key: \"updateStats\",\n        value: function updateStats(stats) {\n\n            this.basesCovered += stats.count;\n            this.sumData += status.sumData;\n            this.sumSquares += sumSquares;\n            this.minVal = MIN(_minVal, min);\n            this.maxVal = MAX(_maxVal, max);\n\n            computeStats.call(this);\n        }\n    }]);\n\n    return BWTotalSummary;\n}();\n\n//***************js/bigwig/bwBPTree.js**************\n\n\nvar BPTREE_MAGIC_LTH = 0x78CA8C91;\nvar BPTREE_MAGIC_HTL = 0x918CCA78;\nvar BPTREE_HEADER_SIZE = 32;\n\nvar BPTree = function BPTree(binaryParser, startOffset) {\n    _classCallCheck(this, BPTree);\n\n    var self = this,\n        genome = null;\n\n    this.header = {};\n    this.header.magic = binaryParser.getInt();\n    this.header.blockSize = binaryParser.getInt();\n    this.header.keySize = binaryParser.getInt();\n    this.header.valSize = binaryParser.getInt();\n    this.header.itemCount = binaryParser.getLong();\n    this.header.reserved = binaryParser.getLong();\n\n    this.dictionary = {};\n\n    // Recursively walk tree to populate dictionary\n    readTreeNode(binaryParser, -1, this.header.keySize, this.dictionary);\n\n    var itemSize = 8 + this.header.keySize;\n    var minSize = 4 + itemSize; // Bytes for a node with 1 item\n\n    function readTreeNode(byteBuffer, offset, keySize, dictionary) {\n\n        if (offset >= 0) byteBuffer.position = offset;\n\n        var type = byteBuffer.getByte(),\n            reserved = byteBuffer.getByte(),\n            count = byteBuffer.getUShort(),\n            i,\n            key,\n            chromId,\n            chromSize,\n            childOffset,\n            bufferOffset,\n            currOffset;\n\n        if (type == 1) {\n\n            for (i = 0; i < count; i++) {\n\n                key = byteBuffer.getFixedLengthTrimmedString(keySize);\n                chromId = byteBuffer.getInt();\n                chromSize = byteBuffer.getInt();\n\n                if (genome) key = genome.getChromosomeName(key); // Translate to canonical chr name\n                dictionary[key] = chromId;\n            }\n        } else {\n            // non-leaf\n\n            for (i = 0; i < count; i++) {\n\n                key = byteBuffer.getFixedLengthTrimmedString(keySize);\n                childOffset = byteBuffer.getLong();\n                bufferOffset = childOffset - startOffset;\n                currOffset = byteBuffer.position;\n                readTreeNode(byteBuffer, bufferOffset, keySize, dictionary);\n                byteBuffer.position = currOffset;\n            }\n        }\n    }\n};\n\nexports.BWSource = BWSource;\nexports.BinaryParser = BinaryParser;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/vendor/zlib_and_gzip.min.js */ \"./src/vendor/zlib_and_gzip.min.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmlnd2lnLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9iaWd3aWcuanM/MzkwZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IEJyb2FkIEluc3RpdHV0ZVxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xyXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gKiBUSEUgU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtpZ3Z4aHJ9IGZyb20gXCIuL2lndnhoci5qc1wiO1xyXG5cclxuXHJcbi8vKioqKioqKioqKipqcy9iaWd3aWcvYnVmZmVyZWRSZWFkZXIuanMqKioqKioqKioqKioqKioqKlxyXG5jbGFzcyBCdWZmZXJlZFJlYWRlcntcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgY29udGVudExlbmd0aCwgYnVmZmVyU2l6ZSkge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IGNvbmZpZy51cmw7XHJcbiAgICAgICAgdGhpcy5jb250ZW50TGVuZ3RoID0gY29udGVudExlbmd0aDtcclxuICAgICAgICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplID8gYnVmZmVyU2l6ZSA6IDUxMjAwMDtcclxuICAgICAgICB0aGlzLnJhbmdlID0ge3N0YXJ0OiAtMSwgc2l6ZTogLTF9O1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZXF1ZXN0ZWRSYW5nZSAtIGJ5dGUgcmFuZ2VhcyB7c3RhcnQsIHNpemV9XHJcbiAgICAgKiBAcGFyYW0gZnVsZmlsbCAtIGZ1bmN0aW9uIHRvIHJlY2VpdmUgcmVzdWx0XHJcbiAgICAgKiBAcGFyYW0gYXNVaW50OCAtIG9wdGlvbmFsIGZsYWcgdG8gcmV0dXJuIHJlc3VsdCBhcyBhbiBVSW50OEFycmF5XHJcbiAgICAgKi9cclxuICAgIGRhdGFWaWV3Rm9yUmFuZ2UocmVxdWVzdGVkUmFuZ2UsIGFzVWludDgpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgaGFzRGF0YSA9IChzZWxmLmRhdGEgJiYgKHNlbGYucmFuZ2Uuc3RhcnQgPD0gcmVxdWVzdGVkUmFuZ2Uuc3RhcnQpICYmXHJcbiAgICAgICAgICAgICAgICAoKHNlbGYucmFuZ2Uuc3RhcnQgKyBzZWxmLnJhbmdlLnNpemUpID49IChyZXF1ZXN0ZWRSYW5nZS5zdGFydCArIHJlcXVlc3RlZFJhbmdlLnNpemUpKSksXHJcbiAgICAgICAgICAgICAgICBidWZmZXJTaXplLFxyXG4gICAgICAgICAgICAgICAgbG9hZFJhbmdlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGhhc0RhdGEpIHtcclxuICAgICAgICAgICAgICAgIHN1YmJ1ZmZlcihzZWxmLCByZXF1ZXN0ZWRSYW5nZSwgYXNVaW50OCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFeHBhbmQgYnVmZmVyIHNpemUgaWYgbmVlZGVkLCBidXQgbm90IGJleW9uZCBjb250ZW50IGxlbmd0aFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyU2l6ZSA9IE1hdGgubWF4KHNlbGYuYnVmZmVyU2l6ZSwgcmVxdWVzdGVkUmFuZ2Uuc2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29udGVudExlbmd0aCA+IDAgJiYgcmVxdWVzdGVkUmFuZ2Uuc3RhcnQgKyBidWZmZXJTaXplID4gc2VsZi5jb250ZW50TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZFJhbmdlID0ge3N0YXJ0OiByZXF1ZXN0ZWRSYW5nZS5zdGFydH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2FkUmFuZ2UgPSB7c3RhcnQ6IHJlcXVlc3RlZFJhbmdlLnN0YXJ0LCBzaXplOiBidWZmZXJTaXplfTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZEFycmF5QnVmZmVyKHNlbGYucGF0aCwgT2JqZWN0LmFzc2lnbihzZWxmLmNvbmZpZywge3JhbmdlOiBsb2FkUmFuZ2V9KSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRhdGEgPSBhcnJheUJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnJhbmdlID0gbG9hZFJhbmdlO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YmJ1ZmZlcihzZWxmLCByZXF1ZXN0ZWRSYW5nZSwgYXNVaW50OCk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN1YmJ1ZmZlcihidWZmZXJlZFJlYWRlciwgcmVxdWVzdGVkUmFuZ2UsIGFzVWludDgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gYnVmZmVyZWRSZWFkZXIuZGF0YS5ieXRlTGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclN0YXJ0ID0gcmVxdWVzdGVkUmFuZ2Uuc3RhcnQgLSBidWZmZXJlZFJlYWRlci5yYW5nZS5zdGFydCxcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhc1VpbnQ4ID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoYnVmZmVyZWRSZWFkZXIuZGF0YSwgYnVmZmVyU3RhcnQsIGxlbiAtIGJ1ZmZlclN0YXJ0KSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEYXRhVmlldyhidWZmZXJlZFJlYWRlci5kYXRhLCBidWZmZXJTdGFydCwgbGVuIC0gYnVmZmVyU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcbi8vKioqKioqKioqKmpzL2JpZ3dpZy9id1NvdXJjZS5qcyoqKioqKioqKioqKioqKlxyXG5jbGFzcyBCV1NvdXJjZXtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsY3JlYXRlX2ZlYXR1cmVfZnVuY3Rpb24pIHtcclxuICAgICAgICB0aGlzLnJlYWRlciA9IG5ldyBCV1JlYWRlcihjb25maWcpO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyZWRSZWFkZXIgPSBuZXcgQnVmZmVyZWRSZWFkZXIoY29uZmlnKTtcclxuICAgICAgICBpZiAoIWNyZWF0ZV9mZWF0dXJlX2Z1bmN0aW9uKXtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVfZmVhdHVyZT1CV1NvdXJjZS5jcmVhdGVGZWF0dXJlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZV9mZWF0dXJlPWNyZWF0ZV9mZWF0dXJlX2Z1bmN0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcblx0KiBDcmVhdGVzIGEgcGFuZWxcclxuXHQqIEBwYXJhbSB7c3RyaW5nfSBjaHIgLSBUaGUgY2hyb21vc29tZVxyXG5cdCogQHBhcmFtIHtpbnR9IGJwU3RhcnQgVGhlIHN0YXJ0aW5nIHBvc3RpdGlvbiBcclxuXHQqIEBwYXJhbSB7aW50fSBicEVuZCAtIFRoZSBlbmQgb2YgdGhlIHJlZ2lvbiB0byBzaG93XHJcblx0KiBAcGFyYW0ge2Jvb2xlYW59IHVzZV9leGlzdGluZyAtIElmIHRydWUgdGhlbiB0aGUgY2FjaGVkIGZlYXR1cmUgd2lsbCBiZSB1c2VkLSBvbmx5IHVzZWRcclxuXHQqIGlmIHRoZSBjby1vcmlkaW5hdGVzIGhhdmUgbm90IGNoYW5nZWQuIEFsdGhvdWdoLCB0aGUgQldyZWFkZXIgaGFzIGEgY2FjaGUsIGl0IGlzIHNvbWV0aW1lc1xyXG5cdCogaWdub3JlZCBhbmQgZmVhdHVyZXMgYXJlIHJlLWZldGNoZWQgZm9yIHRoZSBzYW1lIHJlZ2lvblxyXG5cdCogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBTaG91bGQgY29udGFpbiBwaXhlbFdpZHRoLSB0aGUgd2lkdGggb2YgdGhlIGVudGlyZSBjYW52YXMgYW5kIFxyXG5cdCogYnBQZXJQaXhlbC5cclxuXHQqL1xyXG4gICAgZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCx1c2VfZXhpc3RpbmcsZGF0YSkge1xyXG4gICAgICAgIHRoaXMuc3QgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHNlbGYuZmVhdHVyZXMgJiYgdXNlX2V4aXN0aW5nKXtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5mZWF0dXJlcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5yZWFkZXIuZ2V0Wm9vbUhlYWRlcnMoKS50aGVuKGZ1bmN0aW9uICh6b29tTGV2ZWxIZWFkZXJzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2VsZWN0IGEgYml3aWcgXCJ6b29tIGxldmVsXCIgYXBwcm9wcmlhdGUgZm9yIHRoZSBjdXJyZW50IHJlc29sdXRpb25cclxuICAgICAgICAgICAgICAgIHZhciBid1JlYWRlciA9IHNlbGYucmVhZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcmVkUmVhZGVyID0gc2VsZi5idWZmZXJlZFJlYWRlcixcclxuICAgICAgICAgICAgICAgICAgICBicHAgPWRhdGEuYnBQZXJQaXhlbCxcclxuICAgICAgICAgICAgICAgICAgICB6b29tTGV2ZWxIZWFkZXI9QldTb3VyY2Uuem9vbUxldmVsRm9yU2NhbGUoYnBwLCB6b29tTGV2ZWxIZWFkZXJzKSxcclxuICAgICAgICAgICAgICAgICAgICB0cmVlT2Zmc2V0XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoem9vbUxldmVsSGVhZGVyICYmIGJ3UmVhZGVyLnR5cGU9PT1cIkJpZ1dpZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJlZU9mZnNldCA9IHpvb21MZXZlbEhlYWRlci5pbmRleE9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29kZUZ1bmN0aW9uID0gQldTb3VyY2UuZGVjb2RlWm9vbURhdGE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyZWVPZmZzZXQgPSBid1JlYWRlci5oZWFkZXIuZnVsbEluZGV4T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChid1JlYWRlci50eXBlID09PSBcIkJpZ1dpZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb2RlRnVuY3Rpb24gPUJXU291cmNlLmRlY29kZVdpZ0RhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29kZUZ1bmN0aW9uID1zZWxmLmRlY29kZUJlZERhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJ3UmVhZGVyLmxvYWRSUFRyZWUodHJlZU9mZnNldCkudGhlbihmdW5jdGlvbiAocnBUcmVlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaHJJZHggPSBzZWxmLnJlYWRlci5jaHJvbVRyZWUuZGljdGlvbmFyeVtjaHJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHJJZHggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJwVHJlZS5maW5kTGVhZkl0ZW1zT3ZlcmxhcHBpbmcoY2hySWR4LCBicFN0YXJ0LCBicEVuZCkudGhlbihmdW5jdGlvbiAobGVhZkl0ZW1zKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWFmSXRlbXMgfHwgbGVhZkl0ZW1zLmxlbmd0aCA9PSAwKSBmdWxmaWxsKFtdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFmSXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJlZFJlYWRlci5kYXRhVmlld0ZvclJhbmdlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBpdGVtLmRhdGFPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBpdGVtLmRhdGFTaXplXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpLnRoZW4oZnVuY3Rpb24gKHVpbnQ4QXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbGF0ZSA9IG5ldyBabGliLlpsaWIuSW5mbGF0ZSh1aW50OEFycmF5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBsYWluPSBpbmZsYXRlLmRlY29tcHJlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgaW5mbGF0ZSA9IG5ldyBwYWtvLkluZmxhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pbmZsYXRlLnB1c2godWludDhBcnJheSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciBwbGFpbiA9IGluZmxhdGUucmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvZGVGdW5jdGlvbihuZXcgRGF0YVZpZXcocGxhaW4uYnVmZmVyKSwgY2hyLCBjaHJJZHgsIGJwU3RhcnQsIGJwRW5kLCBmZWF0dXJlcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChmZWF0dXJlcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoZmVhdHVyZUFycmF5cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbiA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gZW4tc2VsZi5zdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGJwcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSwgYWxsRmVhdHVyZXMgPSBmZWF0dXJlQXJyYXlzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZlYXR1cmVBcnJheXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihpPTE7IGk8ZmVhdHVyZUFycmF5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcyA9IGFsbEZlYXR1cmVzLmNvbmNhdChmZWF0dXJlQXJyYXlzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZlYXR1cmVzPWFsbEZlYXR1cmVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoYWxsRmVhdHVyZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG5cclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG4gICAgZ2V0RGVmYXVsdFJhbmdlKCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHRoaXMucmVhZGVyLnRvdGFsU3VtbWFyeSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLnRvdGFsU3VtbWFyeS5kZWZhdWx0UmFuZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcblxyXG4gICAgc3RhdGljIHpvb21MZXZlbEZvclNjYWxlKGJwUGVyUGl4ZWwsIHpvb21MZXZlbEhlYWRlcnMpIHtcclxuXHJcbiAgICAgICAgdmFyIGxldmVsID0gbnVsbCwgaSwgemw7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB6b29tTGV2ZWxIZWFkZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICB6bCA9IHpvb21MZXZlbEhlYWRlcnNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoemwucmVkdWN0aW9uTGV2ZWwgPiBicFBlclBpeGVsKSB7XHJcbiAgICAgICAgICAgICAgICBsZXZlbCA9IHpsO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChudWxsID09IGxldmVsKSB7XHJcbiAgICAgICAgICAgIGxldmVsID0gem9vbUxldmVsSGVhZGVyc1t6b29tTGV2ZWxIZWFkZXJzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChsZXZlbCAmJiBsZXZlbC5yZWR1Y3Rpb25MZXZlbCA8IDQgKiBicFBlclBpeGVsKSA/IGxldmVsIDogbnVsbDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgc3RhdGljIGRlY29kZVdpZ0RhdGEoZGF0YSwgY2hyLCBjaHJJZHgsIGJwU3RhcnQsIGJwRW5kLCBmZWF0dXJlQXJyYXkpIHtcclxuXHJcbiAgICAgICAgdmFyIGJpbmFyeVBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIoZGF0YSksXHJcbiAgICAgICAgICAgIGNocm9tSWQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgIGNocm9tU3RhcnQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgIGNocm9tRW5kID0gYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICBpdGVtU3RlcCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKSxcclxuICAgICAgICAgICAgaXRlbVNwYW4gPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgIHR5cGUgPSBiaW5hcnlQYXJzZXIuZ2V0Qnl0ZSgpLFxyXG4gICAgICAgICAgICByZXNlcnZlZCA9IGJpbmFyeVBhcnNlci5nZXRCeXRlKCksXHJcbiAgICAgICAgICAgIGl0ZW1Db3VudCA9IGJpbmFyeVBhcnNlci5nZXRVU2hvcnQoKSxcclxuICAgICAgICAgICAgdmFsdWU7XHJcblxyXG4gICAgICAgIGlmIChjaHJvbUlkID09PSBjaHJJZHgpIHtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChpdGVtQ291bnQtLSA+IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tU3RhcnQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tRW5kID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJpbmFyeVBhcnNlci5nZXRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tU3RhcnQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tRW5kID0gY2hyb21TdGFydCArIGl0ZW1TcGFuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6ICAvLyBGaXhlZCBzdGVwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tRW5kID0gY2hyb21TdGFydCArIGl0ZW1TcGFuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHJvbVN0YXJ0ICs9IGl0ZW1TdGVwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNocm9tU3RhcnQgPj0gYnBFbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gT3V0IG9mIGludGVydmFsXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNocm9tRW5kID4gYnBTdGFydCAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUFycmF5LnB1c2goe2NocjogY2hyLCBzdGFydDogY2hyb21TdGFydCwgZW5kOiBjaHJvbUVuZCwgdmFsdWU6IHZhbHVlfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRlY29kZVpvb21EYXRhKGRhdGEsIGNociwgY2hySWR4LCBicFN0YXJ0LCBicEVuZCwgZmVhdHVyZUFycmF5KSB7XHJcblxyXG4gICAgICAgIHZhciBiaW5hcnlQYXJzZXIgPSBuZXcgQmluYXJ5UGFyc2VyKGRhdGEpLFxyXG4gICAgICAgICAgICBtaW5TaXplID0gOCAqIDQsICAgLy8gTWluaW11bSAjIG9mIGJ5dGVzIHJlcXVpcmVkIGZvciBhIHpvb20gcmVjb3JkXHJcbiAgICAgICAgICAgIGNocm9tSWQsXHJcbiAgICAgICAgICAgIGNocm9tU3RhcnQsXHJcbiAgICAgICAgICAgIGNocm9tRW5kLFxyXG4gICAgICAgICAgICB2YWxpZENvdW50LFxyXG4gICAgICAgICAgICBtaW5WYWwsXHJcbiAgICAgICAgICAgIG1heFZhbCxcclxuICAgICAgICAgICAgc3VtRGF0YSxcclxuICAgICAgICAgICAgc3VtU3F1YXJlcyxcclxuICAgICAgICAgICAgdmFsdWU7XHJcblxyXG4gICAgICAgIHdoaWxlIChiaW5hcnlQYXJzZXIucmVtTGVuZ3RoKCkgPj0gbWluU2l6ZSkge1xyXG4gICAgICAgICAgICBjaHJvbUlkID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICBpZiAoY2hyb21JZCA9PT0gY2hySWR4KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2hyb21TdGFydCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgIGNocm9tRW5kID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgdmFsaWRDb3VudCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgIG1pblZhbCA9IGJpbmFyeVBhcnNlci5nZXRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgbWF4VmFsID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICBzdW1EYXRhID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICBzdW1TcXVhcmVzID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbGlkQ291bnQgPT0gMCA/IDAgOiBzdW1EYXRhIC8gdmFsaWRDb3VudDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hyb21TdGFydCA+PSBicEVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBPdXQgb2YgaW50ZXJ2YWxcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNocm9tRW5kID4gYnBTdGFydCAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUFycmF5LnB1c2goe2NocjogY2hyLCBzdGFydDogY2hyb21TdGFydCwgZW5kOiBjaHJvbUVuZCwgdmFsdWU6IHZhbHVlfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICBkZWNvZGVCZWREYXRhKGRhdGEsIGNociwgY2hySWR4LCBicFN0YXJ0LCBicEVuZCwgZmVhdHVyZUFycmF5KSB7XHJcblxyXG4gICAgICAgIHZhciBiaW5hcnlQYXJzZXIgPSBuZXcgQmluYXJ5UGFyc2VyKGRhdGEpLFxyXG4gICAgICAgICAgICBtaW5TaXplID0gMyAqIDQgKyAxLCAgIC8vIE1pbmltdW0gIyBvZiBieXRlcyByZXF1aXJlZCBmb3IgYSBiZWQgcmVjb3JkXHJcbiAgICAgICAgICAgIGNocm9tSWQsXHJcbiAgICAgICAgICAgIGNocm9tU3RhcnQsXHJcbiAgICAgICAgICAgIGNocm9tRW5kLFxyXG4gICAgICAgICAgICByZXN0LFxyXG4gICAgICAgICAgICB0b2tlbnMsXHJcbiAgICAgICAgICAgIGZlYXR1cmUsXHJcbiAgICAgICAgICAgIGV4b25Db3VudCwgZXhvblNpemVzLCBleG9uU3RhcnRzLCBleG9ucywgZVN0YXJ0LCBlRW5kO1xyXG5cclxuXHJcbiAgICAgICAgd2hpbGUgKGJpbmFyeVBhcnNlci5yZW1MZW5ndGgoKSA+PSBtaW5TaXplKSB7XHJcblxyXG4gICAgICAgICAgICBjaHJvbUlkID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICBpZiAoY2hyb21JZCAhPSBjaHJJZHgpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgY2hyb21TdGFydCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgY2hyb21FbmQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgIHJlc3QgPSBiaW5hcnlQYXJzZXIuZ2V0U3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICBmZWF0dXJlID0ge2NocjogY2hyLCBzdGFydDogY2hyb21TdGFydCwgZW5kOiBjaHJvbUVuZH07XHJcblxyXG4gICAgICAgICAgICBpZiAoY2hyb21TdGFydCA8IGJwRW5kICYmIGNocm9tRW5kID49IGJwU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIGZlYXR1cmVBcnJheS5wdXNoKGZlYXR1cmUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRva2VucyA9IHJlc3Quc3BsaXQoXCJcXHRcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZV9mZWF0dXJlKHRva2VucyxmZWF0dXJlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHN0YXRpYyBjcmVhdGVGZWF0dXJlKHRva2VucyxmZWF0dXJlKXtcclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLm5hbWUgPSB0b2tlbnNbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5zY29yZSA9IHBhcnNlRmxvYXQodG9rZW5zWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuc3RyYW5kID0gdG9rZW5zWzJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5jZFN0YXJ0ID0gcGFyc2VJbnQodG9rZW5zWzNdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuY2RFbmQgPSBwYXJzZUludCh0b2tlbnNbNF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2Vuc1s1XSAhPT0gXCIuXCIgJiYgdG9rZW5zWzVdICE9PSBcIjBcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5jb2xvciA9IGlndi5jcmVhdGVDb2xvclN0cmluZyh0b2tlbnNbNV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhvbkNvdW50ID0gcGFyc2VJbnQodG9rZW5zWzZdKTtcclxuICAgICAgICAgICAgICAgICAgICBleG9uU2l6ZXMgPSB0b2tlbnNbN10uc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgICAgICAgICBleG9uU3RhcnRzID0gdG9rZW5zWzhdLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleG9uQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlU3RhcnQgPSBzdGFydCArIHBhcnNlSW50KGV4b25TdGFydHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlRW5kID0gZVN0YXJ0ICsgcGFyc2VJbnQoZXhvblNpemVzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhvbnMucHVzaCh7c3RhcnQ6IGVTdGFydCwgZW5kOiBlRW5kfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLmV4b25zID0gZXhvbnM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbi8vKioqKioqKioqKioqanMvYmlnd2lnL2J3UmVhZGVyLmpzKioqKioqKioqKioqKioqKipcclxuXHJcblxyXG5jb25zdCBCSUdXSUdfTUFHSUNfTFRIID0gMHg4ODhGRkMyNjsgLy8gQmlnV2lnIE1hZ2ljIExvdyB0byBIaWdoXHJcbmNvbnN0IEJJR1dJR19NQUdJQ19IVEwgPSAweDI2RkM4RjY2OyAvLyBCaWdXaWcgTWFnaWMgSGlnaCB0byBMb3dcclxuY29uc3QgQklHQkVEX01BR0lDX0xUSCA9IDB4ODc4OUYyRUI7IC8vIEJpZ0JlZCBNYWdpYyBMb3cgdG8gSGlnaFxyXG5jb25zdCBCSUdCRURfTUFHSUNfSFRMID0gMHhFQkYyODk4NzsgLy8gQmlnQmVkIE1hZ2ljIEhpZ2ggdG8gTG93XHJcbmNvbnN0IEJCRklMRV9IRUFERVJfU0laRSA9IDY0O1xyXG5cclxuXHJcbmNsYXNzIEJXUmVhZGVye1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gY29uZmlnLnVybDtcclxuICAgICAgICB0aGlzLmhlYWRQYXRoID0gY29uZmlnLmhlYWRVUkwgfHwgdGhpcy5wYXRoO1xyXG4gICAgICAgIHRoaXMucnBUcmVlQ2FjaGUgPSB7fTtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIH07XHJcblxyXG4gICAgZ2V0Wm9vbUhlYWRlcnMoKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHNlbGYuem9vbUxldmVsSGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLnpvb21MZXZlbEhlYWRlcnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5sb2FkSGVhZGVyKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLnpvb21MZXZlbEhlYWRlcnMpO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZEhlYWRlcigpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZ3Z4aHIubG9hZEFycmF5QnVmZmVyKHNlbGYucGF0aCwgT2JqZWN0LmFzc2lnbihzZWxmLmNvbmZpZywge3JhbmdlOiB7c3RhcnQ6IDAsIHNpemU6IEJCRklMRV9IRUFERVJfU0laRX19KSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXNzdW1lIGxvdy10by1oaWdoIHVubGVzcyBwcm92ZW4gb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgICAgICBzZWxmLmxpdHRsZUVuZGlhbiA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGJpbmFyeVBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIobmV3IERhdGFWaWV3KGRhdGEpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbWFnaWMgPSBiaW5hcnlQYXJzZXIuZ2V0VUludCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtYWdpYyA9PT0gQklHV0lHX01BR0lDX0xUSCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudHlwZSA9IFwiQmlnV2lnXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYWdpYyA9PSBCSUdCRURfTUFHSUNfTFRIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50eXBlID0gXCJCaWdCZWRcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVHJ5IGJpZyBlbmRpYW4gb3JkZXJcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmxpdHRsZUVuZGlhbiA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIubGl0dGxlRW5kaWFuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5UGFyc2VyLnBvc2l0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWFnaWMgPSBiaW5hcnlQYXJzZXIuZ2V0VUludCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFnaWMgPT09IEJJR1dJR19NQUdJQ19IVEwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi50eXBlID0gXCJCaWdXaWdcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWFnaWMgPT0gQklHQkVEX01BR0lDX0hUTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnR5cGUgPSBcIkJpZ0JlZFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyAtLSBlcnJvciwgdW5rbm93biBmaWxlIHR5cGUgIG9yIEJFXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFRhYmxlIDUgIFwiQ29tbW9uIGhlYWRlciBmb3IgQmlnV2lnIGFuZCBCaWdCZWQgZmlsZXNcIlxyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIgPSB7fTtcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyLmJ3VmVyc2lvbiA9IGJpbmFyeVBhcnNlci5nZXRVU2hvcnQoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyLm5ab29tTGV2ZWxzID0gYmluYXJ5UGFyc2VyLmdldFVTaG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIuY2hyb21UcmVlT2Zmc2V0ID0gYmluYXJ5UGFyc2VyLmdldExvbmcoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyLmZ1bGxEYXRhT2Zmc2V0ID0gYmluYXJ5UGFyc2VyLmdldExvbmcoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyLmZ1bGxJbmRleE9mZnNldCA9IGJpbmFyeVBhcnNlci5nZXRMb25nKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5maWVsZENvdW50ID0gYmluYXJ5UGFyc2VyLmdldFVTaG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIuZGVmaW5lZEZpZWxkQ291bnQgPSBiaW5hcnlQYXJzZXIuZ2V0VVNob3J0KCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5hdXRvU3FsT2Zmc2V0ID0gYmluYXJ5UGFyc2VyLmdldExvbmcoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyLnRvdGFsU3VtbWFyeU9mZnNldCA9IGJpbmFyeVBhcnNlci5nZXRMb25nKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci51bmNvbXByZXNzQnVmZlNpemUgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5yZXNlcnZlZCA9IGJpbmFyeVBhcnNlci5nZXRMb25nKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5sb2FkWm9vbUhlYWRlcnNBbmRDaHJUcmVlKCkudGhlbihmdWxmaWxsKS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgIGxvYWRab29tSGVhZGVyc0FuZENoclRyZWUoKSB7XHJcblxyXG5cclxuICAgICAgICB2YXIgc3RhcnRPZmZzZXQgPSBCQkZJTEVfSEVBREVSX1NJWkUsXHJcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHJhbmdlID0ge3N0YXJ0OiBzdGFydE9mZnNldCwgc2l6ZTogKHNlbGYuaGVhZGVyLmZ1bGxEYXRhT2Zmc2V0IC0gc3RhcnRPZmZzZXQgKyA1KX07XHJcblxyXG4gICAgICAgICAgICBpZ3Z4aHIubG9hZEFycmF5QnVmZmVyKHNlbGYucGF0aCwgT2JqZWN0LmFzc2lnbihzZWxmLmNvbmZpZywge3JhbmdlOiByYW5nZX0pKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgblpvb21zID0gc2VsZi5oZWFkZXIublpvb21MZXZlbHMsXHJcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5UGFyc2VyID0gbmV3IEJpbmFyeVBhcnNlcihuZXcgRGF0YVZpZXcoZGF0YSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuLFxyXG4gICAgICAgICAgICAgICAgICAgIHpvb21OdW1iZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgemxoO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuem9vbUxldmVsSGVhZGVycyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuZmlyc3Rab29tRGF0YU9mZnNldCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgblpvb21zOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB6b29tTnVtYmVyID0gblpvb21zIC0gaTtcclxuICAgICAgICAgICAgICAgICAgICB6bGggPSBuZXcgWm9vbUxldmVsSGVhZGVyKHpvb21OdW1iZXIsIGJpbmFyeVBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5maXJzdFpvb21EYXRhT2Zmc2V0ID0gTWF0aC5taW4oemxoLmRhdGFPZmZzZXQsIHNlbGYuZmlyc3Rab29tRGF0YU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi56b29tTGV2ZWxIZWFkZXJzLnB1c2goemxoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBdXRvc3FsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oZWFkZXIuYXV0b1NxbE9mZnNldCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIucG9zaXRpb24gPSBzZWxmLmhlYWRlci5hdXRvU3FsT2Zmc2V0IC0gc3RhcnRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hdXRvU3FsID0gYmluYXJ5UGFyc2VyLmdldFN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRvdGFsIHN1bW1hcnlcclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmhlYWRlci50b3RhbFN1bW1hcnlPZmZzZXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5UGFyc2VyLnBvc2l0aW9uID0gc2VsZi5oZWFkZXIudG90YWxTdW1tYXJ5T2Zmc2V0IC0gc3RhcnRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50b3RhbFN1bW1hcnkgPSBuZXcgQldUb3RhbFN1bW1hcnkoYmluYXJ5UGFyc2VyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDaHJvbSBkYXRhIGluZGV4XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oZWFkZXIuY2hyb21UcmVlT2Zmc2V0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeVBhcnNlci5wb3NpdGlvbiA9IHNlbGYuaGVhZGVyLmNocm9tVHJlZU9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2hyb21UcmVlID0gbmV3IEJQVHJlZShiaW5hcnlQYXJzZXIsIHN0YXJ0T2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gLS0gdGhpcyBpcyBhbiBlcnJvciwgbm90IGV4cGVjdGVkXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9GaW5hbGx5IHRvdGFsIGRhdGEgY291bnRcclxuICAgICAgICAgICAgICAgIGJpbmFyeVBhcnNlci5wb3NpdGlvbiA9IHNlbGYuaGVhZGVyLmZ1bGxEYXRhT2Zmc2V0IC0gc3RhcnRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmRhdGFDb3VudCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKCk7XHJcblxyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGxvYWRSUFRyZWUob2Zmc2V0KSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIHJwVHJlZSA9IHNlbGYucnBUcmVlQ2FjaGVbb2Zmc2V0XTtcclxuICAgICAgICAgICAgaWYgKHJwVHJlZSkge1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChycFRyZWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcnBUcmVlID0gbmV3IFJQVHJlZShvZmZzZXQsIHNlbGYuY29udGVudExlbmd0aCwgc2VsZi5jb25maWcsIHNlbGYubGl0dGxlRW5kaWFuKTtcclxuICAgICAgICAgICAgICAgIHNlbGYucnBUcmVlQ2FjaGVbb2Zmc2V0XSA9IHJwVHJlZTtcclxuICAgICAgICAgICAgICAgIHJwVHJlZS5sb2FkKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChycFRyZWUpO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4gY2xhc3MgWm9vbUxldmVsSGVhZGVye1xyXG4gICAgIGNvbnN0cnVjdG9yKGluZGV4LCBieXRlQnVmZmVyKSB7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMucmVkdWN0aW9uTGV2ZWwgPSBieXRlQnVmZmVyLmdldEludCgpO1xyXG4gICAgICAgIHRoaXMucmVzZXJ2ZWQgPSBieXRlQnVmZmVyLmdldEludCgpO1xyXG4gICAgICAgIHRoaXMuZGF0YU9mZnNldCA9IGJ5dGVCdWZmZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhPZmZzZXQgPSBieXRlQnVmZmVyLmdldExvbmcoKTtcclxuICAgIH1cclxuIH1cclxuXHJcblxyXG5jb25zdCBSUFRSRUVfTUFHSUNfTFRIID0gMHgyNDY4QUNFMDtcclxuY29uc3QgUlBUUkVFX01BR0lDX0hUTCA9IDB4RTBBQzY4MjQ7XHJcbmNvbnN0IFJQVFJFRV9IRUFERVJfU0laRSA9IDQ4O1xyXG5jb25zdCBSUFRSRUVfTk9ERV9MRUFGX0lURU1fU0laRSA9IDMyOyAgIC8vIGxlYWYgaXRlbSBzaXplXHJcbmNvbnN0IFJQVFJFRV9OT0RFX0NISUxEX0lURU1fU0laRSA9IDI0OyAgLy8gY2hpbGQgaXRlbSBzaXplXHJcbmNvbnN0IEJVRkZFUl9TSVpFID0gNTEyMDAwOyBcclxuXHJcbi8vKioqKioqKioqKipqcy9iaWd3aWcvUlBUcmVlKioqKioqKioqKioqKioqKioqKlxyXG5cclxuXHJcbiAgICAgLy8gIGJ1ZmZlclxyXG5cclxuY2xhc3MgUlBUcmVle1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChmaWxlT2Zmc2V0LCBjb250ZW50TGVuZ3RoLCBjb25maWcsIGxpdHRsZUVuZGlhbikge1xyXG5cclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICB0aGlzLmZpbGVzaXplID0gY29udGVudExlbmd0aDtcclxuICAgICAgICB0aGlzLmZpbGVPZmZzZXQgPSBmaWxlT2Zmc2V0OyAvLyBGaWxlIG9mZnNldCB0byBiZWdpbm5pbmcgb2YgdHJlZVxyXG4gICAgICAgIHRoaXMucGF0aCA9IGNvbmZpZy51cmw7XHJcbiAgICAgICAgdGhpcy5saXR0bGVFbmRpYW4gPSBsaXR0bGVFbmRpYW47XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGxvYWQoKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIHJvb3ROb2RlT2Zmc2V0ID0gc2VsZi5maWxlT2Zmc2V0ICsgUlBUUkVFX0hFQURFUl9TSVpFLFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyZWRSZWFkZXIgPSBuZXcgQnVmZmVyZWRSZWFkZXIoc2VsZi5jb25maWcsIHNlbGYuZmlsZXNpemUsIEJVRkZFUl9TSVpFKTtcclxuXHJcbiAgICAgICAgICAgIHNlbGYucmVhZE5vZGUocm9vdE5vZGVPZmZzZXQsIGJ1ZmZlcmVkUmVhZGVyKS50aGVuKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJvb3ROb2RlID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZik7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHJlYWROb2RlKGZpbGVQb3NpdGlvbiwgYnVmZmVyZWRSZWFkZXIpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgYnVmZmVyZWRSZWFkZXIuZGF0YVZpZXdGb3JSYW5nZSh7c3RhcnQ6IGZpbGVQb3NpdGlvbiwgc2l6ZTogNH0sIGZhbHNlKS50aGVuKGZ1bmN0aW9uIChkYXRhVmlldykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJpbmFyeVBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIoZGF0YVZpZXcsIHNlbGYubGl0dGxlRW5kaWFuKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGJpbmFyeVBhcnNlci5nZXRCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNMZWFmID0gKHR5cGUgPT09IDEpID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc2VydmVkID0gYmluYXJ5UGFyc2VyLmdldEJ5dGUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IGJpbmFyeVBhcnNlci5nZXRVU2hvcnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmaWxlUG9zaXRpb24gKz0gNDtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZXNSZXF1aXJlZCA9IGNvdW50ICogKGlzTGVhZiA/IFJQVFJFRV9OT0RFX0xFQUZfSVRFTV9TSVpFIDogUlBUUkVFX05PREVfQ0hJTERfSVRFTV9TSVpFKTtcclxuICAgICAgICAgICAgICAgIHZhciByYW5nZTIgPSB7c3RhcnQ6IGZpbGVQb3NpdGlvbiwgc2l6ZTogYnl0ZXNSZXF1aXJlZH07XHJcblxyXG4gICAgICAgICAgICAgICAgYnVmZmVyZWRSZWFkZXIuZGF0YVZpZXdGb3JSYW5nZShyYW5nZTIsIGZhbHNlKS50aGVuKGZ1bmN0aW9uIChkYXRhVmlldykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSBuZXcgQXJyYXkoY291bnQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIgPSBuZXcgQmluYXJ5UGFyc2VyKGRhdGFWaWV3KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVhZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMZWFmOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q2hyb206IGJpbmFyeVBhcnNlci5nZXRJbnQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEJhc2U6IGJpbmFyeVBhcnNlci5nZXRJbnQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRDaHJvbTogYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEJhc2U6IGJpbmFyeVBhcnNlci5nZXRJbnQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0OiBiaW5hcnlQYXJzZXIuZ2V0TG9uZygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFTaXplOiBiaW5hcnlQYXJzZXIuZ2V0TG9uZygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0gPSBpdGVtO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKG5ldyBSUFRyZWVOb2RlKGl0ZW1zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBub24tbGVhZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTGVhZjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDaHJvbTogYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QmFzZTogYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZENocm9tOiBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQmFzZTogYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkT2Zmc2V0OiBiaW5hcnlQYXJzZXIuZ2V0TG9uZygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0gPSBpdGVtO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChuZXcgUlBUcmVlTm9kZShpdGVtcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZpbmRMZWFmSXRlbXNPdmVybGFwcGluZyhjaHJJZHgsIHN0YXJ0QmFzZSwgZW5kQmFzZSkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGVhZkl0ZW1zID0gW10sXHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nID0gbmV3IFNldCgpLFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyZWRSZWFkZXIgPSBuZXcgQnVmZmVyZWRSZWFkZXIoc2VsZi5jb25maWcsIHNlbGYuZmlsZXNpemUsIEJVRkZFUl9TSVpFKTtcclxuXHJcbiAgICAgICAgICAgIHByb2Nlc3NpbmcuYWRkKDApOyAgLy8gWmVybyByZXByZXNlbnRzIHRoZSByb290IG5vZGVcclxuICAgICAgICAgICAgZmluZExlYWZJdGVtcyhzZWxmLnJvb3ROb2RlLCAwKTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRMZWFmSXRlbXMobm9kZSwgbm9kZUlkKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKFJQVHJlZS5vdmVybGFwcyhub2RlLCBjaHJJZHgsIHN0YXJ0QmFzZSwgZW5kQmFzZSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1zID0gbm9kZS5pdGVtcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJQVHJlZS5vdmVybGFwcyhpdGVtLCBjaHJJZHgsIHN0YXJ0QmFzZSwgZW5kQmFzZSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5pc0xlYWYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFmSXRlbXMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluZExlYWZJdGVtcyhpdGVtLmNoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzaW5nLmFkZChpdGVtLmNoaWxkT2Zmc2V0KTsgIC8vIFJlcHJlc2VudCBub2RlIHRvLWJlLWxvYWRlZCBieSBpdHMgZmlsZSBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlYWROb2RlKGl0ZW0uY2hpbGRPZmZzZXQsIGJ1ZmZlcmVkUmVhZGVyKS50aGVuKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNoaWxkTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5kTGVhZkl0ZW1zKG5vZGUsIGl0ZW0uY2hpbGRPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZUlkICE9IHVuZGVmaW5lZCkgcHJvY2Vzc2luZy5kZWxldGUobm9kZUlkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXYWl0IHVudGlsIGFsbCBub2RlcyBhcmUgcHJvY2Vzc2VkXHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc2luZy5zaXplPT09MCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwobGVhZkl0ZW1zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYge2NocklkeDpzdGFydEJhc2UtZW5kQmFzZX0gb3ZlcmxhcHMgaXRlbSdzIGludGVydmFsXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIG92ZXJsYXBzKGl0ZW0sIGNocklkeCwgc3RhcnRCYXNlLCBlbmRCYXNlKSB7XHJcblxyXG4gICAgICAgIC8vICBpZiAoY2hySWR4ID4gaXRlbS5lbmRDaHJvbSB8fCBjaHJJZHggPCBpdGVtLnN0YXJ0Q2hyb20pIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKCFpdGVtKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibnVsbCBpdGVtXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKChjaHJJZHggPiBpdGVtLnN0YXJ0Q2hyb20pIHx8IChjaHJJZHggPT0gaXRlbS5zdGFydENocm9tICYmIGVuZEJhc2UgPj0gaXRlbS5zdGFydEJhc2UpKSAmJlxyXG4gICAgICAgICAgICAoKGNocklkeCA8IGl0ZW0uZW5kQ2hyb20pIHx8IChjaHJJZHggPT0gaXRlbS5lbmRDaHJvbSAmJiBzdGFydEJhc2UgPCBpdGVtLmVuZEJhc2UpKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmNsYXNzIFJQVHJlZU5vZGV7XHJcbiAgICBjb25zdHJ1Y3RvcihpdGVtcykge1xyXG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcclxuXHJcbiAgICAgICAgdmFyIG1pbkNocm9tSWQgPSBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICBtYXhDaHJvbUlkID0gMCxcclxuICAgICAgICAgICAgbWluU3RhcnRCYXNlID0gTnVtYmVyLk1BWF9WQUxVRSxcclxuICAgICAgICAgICAgbWF4RW5kQmFzZSA9IDAsXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIGl0ZW07XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpdGVtID0gaXRlbXNbaV07XHJcbiAgICAgICAgICAgIG1pbkNocm9tSWQgPSBNYXRoLm1pbihtaW5DaHJvbUlkLCBpdGVtLnN0YXJ0Q2hyb20pO1xyXG4gICAgICAgICAgICBtYXhDaHJvbUlkID0gTWF0aC5tYXgobWF4Q2hyb21JZCwgaXRlbS5lbmRDaHJvbSk7XHJcbiAgICAgICAgICAgIG1pblN0YXJ0QmFzZSA9IE1hdGgubWluKG1pblN0YXJ0QmFzZSwgaXRlbS5zdGFydEJhc2UpO1xyXG4gICAgICAgICAgICBtYXhFbmRCYXNlID0gTWF0aC5tYXgobWF4RW5kQmFzZSwgaXRlbS5lbmRCYXNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc3RhcnRDaHJvbSA9IG1pbkNocm9tSWQ7XHJcbiAgICAgICAgdGhpcy5lbmRDaHJvbSA9IG1heENocm9tSWQ7XHJcbiAgICAgICAgdGhpcy5zdGFydEJhc2UgPSBtaW5TdGFydEJhc2U7XHJcbiAgICAgICAgdGhpcy5lbmRCYXNlID0gbWF4RW5kQmFzZTtcclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbi8vKioqKioqKioqKioqKioqKioqKmpzL2JpbmFyeS5qcyoqKioqKioqKioqKioqKioqKlxyXG5jbGFzcyBCaW5hcnlQYXJzZXJ7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhVmlldywgbGl0dGxlRW5kaWFuKSB7XHJcblxyXG4gICAgICAgIHRoaXMubGl0dGxlRW5kaWFuID0gKGxpdHRsZUVuZGlhbiA/IGxpdHRsZUVuZGlhbiA6IHRydWUpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAwO1xyXG4gICAgICAgIHRoaXMudmlldyA9IGRhdGFWaWV3O1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gZGF0YVZpZXcuYnl0ZUxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBhdmFpbGFibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoIC0gdGhpcy5wb3NpdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICByZW1MZW5ndGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoIC0gdGhpcy5wb3NpdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBoYXNOZXh0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uIDwgdGhpcy5sZW5ndGggLSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEJ5dGUoKSB7XHJcbiAgICAgICAgdmFyIHJldFZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24sIHRoaXMubGl0dGxlRW5kaWFuKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uKys7XHJcbiAgICAgICAgcmV0dXJuIHJldFZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFNob3J0KCkge1xyXG5cclxuICAgICAgICB2YXIgcmV0VmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50MTYodGhpcy5wb3NpdGlvbiwgdGhpcy5saXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMlxyXG4gICAgICAgIHJldHVybiByZXRWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRVU2hvcnQoKXtcclxuXHJcbiAgICAgICAgLy8gdmFyIGJ5dGUxID0gdGhpcy5nZXRCeXRlKCksXHJcbiAgICAgICAgLy8gICAgIGJ5dGUyID0gdGhpcy5nZXRCeXRlKCksXHJcbiAgICAgICAgLy8gICAgIHJldFZhbHVlID0gKChieXRlMiA8PCAyNCA+Pj4gMTYpICsgKGJ5dGUxIDw8IDI0ID4+PiAyNCkpO1xyXG4gICAgICAgIC8vICAgICByZXR1cm4gcmV0VmFsdWU7XHJcblxyXG4gICAgICAgLy9cclxuICAgICAgICB2YXIgcmV0VmFsdWUgPSB0aGlzLnZpZXcuZ2V0VWludDE2ICh0aGlzLnBvc2l0aW9uLCB0aGlzLmxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyXHJcbiAgICAgICAgcmV0dXJuIHJldFZhbHVlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBnZXRJbnQoKSB7XHJcblxyXG4gICAgICAgIHZhciByZXRWYWx1ZSA9IHRoaXMudmlldy5nZXRJbnQzMih0aGlzLnBvc2l0aW9uLCB0aGlzLmxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA0O1xyXG4gICAgICAgIHJldHVybiByZXRWYWx1ZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2V0VUludCgpIHtcclxuICAgICAgICB2YXIgcmV0VmFsdWUgPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMucG9zaXRpb24sIHRoaXMubGl0dGxlRW5kaWFuKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDQ7XHJcbiAgICAgICAgcmV0dXJuIHJldFZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldExvbmcoKSB7XHJcblxyXG4gICAgICAgIC8vIERhdGFWaWV3IGRvZXNuJ3Qgc3VwcG9ydCBsb25nLiBTbyB3ZSdsbCB0cnkgbWFudWFsbHlcclxuXHJcbiAgICAgICAgdmFyIGIgPSBbXTtcclxuICAgICAgICBiWzBdID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIGJbMV0gPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbiArIDEpO1xyXG4gICAgICAgIGJbMl0gPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbiArIDIpO1xyXG4gICAgICAgIGJbM10gPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbiArIDMpO1xyXG4gICAgICAgIGJbNF0gPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbiArIDQpO1xyXG4gICAgICAgIGJbNV0gPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbiArIDUpO1xyXG4gICAgICAgIGJbNl0gPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbiArIDYpO1xyXG4gICAgICAgIGJbN10gPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbiArIDcpO1xyXG5cclxuICAgICAgICB2YXIgdmFsdWUgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gYi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgKiAyNTYpICsgYltpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgKiAyNTYpICsgYltpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gODtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U3RyaW5nKGxlbikge1xyXG5cclxuICAgICAgICB2YXIgcyA9IFwiXCI7XHJcbiAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgd2hpbGUgKChjID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24rKykpICE9IDApIHtcclxuICAgICAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xyXG4gICAgICAgICAgICBpZiAobGVuICYmIHMubGVuZ3RoID09IGxlbikgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEZpeGVkTGVuZ3RoU3RyaW5nKGxlbikge1xyXG5cclxuICAgICAgICB2YXIgcyA9IFwiXCI7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGMgPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbisrKTtcclxuICAgICAgICAgICAgaWYgKGMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Rml4ZWRMZW5ndGhUcmltbWVkU3RyaW5nKGxlbikge1xyXG5cclxuICAgICAgICB2YXIgcyA9IFwiXCI7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGMgPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbisrKTtcclxuICAgICAgICAgICAgaWYgKGMgPiAzMikge1xyXG4gICAgICAgICAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEZsb2F0KCkge1xyXG5cclxuICAgICAgICB2YXIgcmV0VmFsdWUgPSB0aGlzLnZpZXcuZ2V0RmxvYXQzMih0aGlzLnBvc2l0aW9uLCB0aGlzLmxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA0O1xyXG4gICAgICAgIHJldHVybiByZXRWYWx1ZTtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIGdldERvdWJsZSgpIHtcclxuXHJcbiAgICAgICAgdmFyIHJldFZhbHVlID0gdGhpcy52aWV3LmdldEZsb2F0NjQodGhpcy5wb3NpdGlvbiwgdGhpcy5saXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gODtcclxuICAgICAgICByZXR1cm4gcmV0VmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgc2tpcChuKSB7XHJcblxyXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gbjtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBiZ3ppcCAoYmFtIGFuZCB0YWJpeCkgdmlydHVhbCBwb2ludGVyXHJcbiAgICAgKiBUT0RPIC0tIHdoeSBpc24ndCA4dGggYnl0ZSB1c2VkID9cclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBnZXRWUG9pbnRlcigpIHtcclxuXHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbixcclxuICAgICAgICAgICAgb2Zmc2V0ID0gKHRoaXMudmlldy5nZXRVaW50OChwb3NpdGlvbiArIDEpIDw8IDgpIHwgKHRoaXMudmlldy5nZXRVaW50OChwb3NpdGlvbikpLFxyXG4gICAgICAgICAgICBieXRlNiA9ICgodGhpcy52aWV3LmdldFVpbnQ4KHBvc2l0aW9uICsgNikgJiAweGZmKSAqIDB4MTAwMDAwMDAwKSxcclxuICAgICAgICAgICAgYnl0ZTUgPSAoKHRoaXMudmlldy5nZXRVaW50OChwb3NpdGlvbiArIDUpICYgMHhmZikgKiAweDEwMDAwMDApLFxyXG4gICAgICAgICAgICBieXRlNCA9ICgodGhpcy52aWV3LmdldFVpbnQ4KHBvc2l0aW9uICsgNCkgJiAweGZmKSAqIDB4MTAwMDApLFxyXG4gICAgICAgICAgICBieXRlMyA9ICgodGhpcy52aWV3LmdldFVpbnQ4KHBvc2l0aW9uICsgMykgJiAweGZmKSAqIDB4MTAwKSxcclxuICAgICAgICAgICAgYnl0ZTIgPSAoKHRoaXMudmlldy5nZXRVaW50OChwb3NpdGlvbiArIDIpICYgMHhmZikpLFxyXG4gICAgICAgICAgICBibG9jayA9IGJ5dGU2ICsgYnl0ZTUgKyBieXRlNCArIGJ5dGUzICsgYnl0ZTI7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA4O1xyXG5cclxuICAgICAgICAvLyAgICAgICBpZiAoYmxvY2sgPT0gMCAmJiBvZmZzZXQgPT0gMCkge1xyXG4gICAgICAgIC8vICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAvLyAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBuZXcgVlBvaW50ZXIoYmxvY2ssIG9mZnNldCk7XHJcbiAgICAgICAgLy8gICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBWUG9pbnRlcntcclxuICAgIGNvbnN0cnVjdG9yKGJsb2NrLCBvZmZzZXQpIHtcclxuICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2s7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgaXNMZXNzVGhhbih2cCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NrIDwgdnAuYmxvY2sgfHxcclxuICAgICAgICAgICAgKHRoaXMuYmxvY2sgPT09IHZwLmJsb2NrICYmIHRoaXMub2Zmc2V0IDwgdnAub2Zmc2V0KTtcclxuICAgIH1cclxuXHJcbiAgICBpc0dyZWF0ZXJUaGFuKHZwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2sgPiB2cC5ibG9jayB8fFxyXG4gICAgICAgICAgICAodGhpcy5ibG9jayA9PT0gdnAuYmxvY2sgJiYgdGhpcy5vZmZzZXQgPiB2cC5vZmZzZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaW50KCkge1xyXG4gICAgICAgIHJldHVybiBcIlwiICsgdGhpcy5ibG9jayArIFwiOlwiICsgdGhpcy5vZmZzZXQ7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vLyoqKioqKipqcy9iaWd3aWcvYndUb3RhbFN1bW1hcnkuanMqKioqKioqKioqKioqXHJcblxyXG5cclxuXHJcbmNsYXNzIEJXVG90YWxTdW1tYXJ5e1xyXG4gICAgY29uc3RydWN0b3IoYnl0ZUJ1ZmZlcikge1xyXG5cclxuICAgICAgICBpZiAoYnl0ZUJ1ZmZlcikge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5iYXNlc0NvdmVyZWQgPSBieXRlQnVmZmVyLmdldExvbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5taW5WYWwgPSBieXRlQnVmZmVyLmdldERvdWJsZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm1heFZhbCA9IGJ5dGVCdWZmZXIuZ2V0RG91YmxlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3VtRGF0YSA9IGJ5dGVCdWZmZXIuZ2V0RG91YmxlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3VtU3F1YXJlcyA9IGJ5dGVCdWZmZXIuZ2V0RG91YmxlKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVTdGF0cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5iYXNlc0NvdmVyZWQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLm1pblZhbCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubWF4VmFsID0gMDtcclxuICAgICAgICAgICAgdGhpcy5zdW1EYXRhID0gMDtcclxuICAgICAgICAgICAgdGhpcy5zdW1TcXVhcmVzID0gMDtcclxuICAgICAgICAgICAgdGhpcy5tZWFuID0gMDtcclxuICAgICAgICAgICAgdGhpcy5zdGRkZXYgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgIGNvbXB1dGVTdGF0cygpIHtcclxuICAgICAgICB2YXIgbiA9IHRoaXMuYmFzZXNDb3ZlcmVkO1xyXG4gICAgICAgIGlmIChuID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm1lYW4gPSB0aGlzLnN1bURhdGEgLyBuO1xyXG4gICAgICAgICAgICB0aGlzLnN0ZGRldiA9IE1hdGguc3FydCh0aGlzLnN1bVNxdWFyZXMgLyAobiAtIDEpKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBtaW4gPSB0aGlzLm1pblZhbCA8IDAgPyB0aGlzLm1lYW4gLSAyICogdGhpcy5zdGRkZXYgOiAwLFxyXG4gICAgICAgICAgICAgICAgbWF4ID0gdGhpcy5tYXhWYWwgPiAwID8gdGhpcy5tZWFuICsgMiAqIHRoaXMuc3RkZGV2IDogMDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFJhbmdlID0ge1xyXG4gICAgICAgICAgICAgICAgbWluOiAwLFxyXG4gICAgICAgICAgICAgICAgbWF4OiB0aGlzLm1lYW4gKyAzICogdGhpcy5zdGRkZXZcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVTdGF0cyhzdGF0cykge1xyXG5cclxuICAgICAgICB0aGlzLmJhc2VzQ292ZXJlZCArPSBzdGF0cy5jb3VudDtcclxuICAgICAgICB0aGlzLnN1bURhdGEgKz0gc3RhdHVzLnN1bURhdGE7XHJcbiAgICAgICAgdGhpcy5zdW1TcXVhcmVzICs9IHN1bVNxdWFyZXM7XHJcbiAgICAgICAgdGhpcy5taW5WYWwgPSBNSU4oX21pblZhbCwgbWluKTtcclxuICAgICAgICB0aGlzLm1heFZhbCA9IE1BWChfbWF4VmFsLCBtYXgpO1xyXG5cclxuICAgICAgICBjb21wdXRlU3RhdHMuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5cclxuXHJcbi8vKioqKioqKioqKioqKioqanMvYmlnd2lnL2J3QlBUcmVlLmpzKioqKioqKioqKioqKipcclxuXHJcblxyXG5jb25zdCBCUFRSRUVfTUFHSUNfTFRIID0gMHg3OENBOEM5MTtcclxuY29uc3QgQlBUUkVFX01BR0lDX0hUTCA9IDB4OTE4Q0NBNzg7XHJcbmNvbnN0IEJQVFJFRV9IRUFERVJfU0laRSA9IDMyO1xyXG5cclxuXHJcbiBjbGFzcyBCUFRyZWV7XHJcbiAgICAgY29uc3RydWN0b3IoYmluYXJ5UGFyc2VyLCBzdGFydE9mZnNldCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICAgIGdlbm9tZSA9ICBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLmhlYWRlciA9IHt9O1xyXG4gICAgICAgIHRoaXMuaGVhZGVyLm1hZ2ljID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgIHRoaXMuaGVhZGVyLmJsb2NrU2l6ZSA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICB0aGlzLmhlYWRlci5rZXlTaXplID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgIHRoaXMuaGVhZGVyLnZhbFNpemUgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgdGhpcy5oZWFkZXIuaXRlbUNvdW50ID0gYmluYXJ5UGFyc2VyLmdldExvbmcoKTtcclxuICAgICAgICB0aGlzLmhlYWRlci5yZXNlcnZlZCA9IGJpbmFyeVBhcnNlci5nZXRMb25nKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZGljdGlvbmFyeSA9IHt9O1xyXG5cclxuICAgICAgICAvLyBSZWN1cnNpdmVseSB3YWxrIHRyZWUgdG8gcG9wdWxhdGUgZGljdGlvbmFyeVxyXG4gICAgICAgIHJlYWRUcmVlTm9kZShiaW5hcnlQYXJzZXIsIC0xLCB0aGlzLmhlYWRlci5rZXlTaXplLCB0aGlzLmRpY3Rpb25hcnkpO1xyXG5cclxuICAgICAgICB2YXIgaXRlbVNpemUgPSA4ICsgdGhpcy5oZWFkZXIua2V5U2l6ZTtcclxuICAgICAgICB2YXIgbWluU2l6ZSA9IDQgKyBpdGVtU2l6ZTsgICAvLyBCeXRlcyBmb3IgYSBub2RlIHdpdGggMSBpdGVtXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRUcmVlTm9kZShieXRlQnVmZmVyLCBvZmZzZXQsIGtleVNpemUsIGRpY3Rpb25hcnkpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPj0gMCkgYnl0ZUJ1ZmZlci5wb3NpdGlvbiA9IG9mZnNldDtcclxuXHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gYnl0ZUJ1ZmZlci5nZXRCeXRlKCksXHJcbiAgICAgICAgICAgICAgICByZXNlcnZlZCA9IGJ5dGVCdWZmZXIuZ2V0Qnl0ZSgpLFxyXG4gICAgICAgICAgICAgICAgY291bnQgPSBieXRlQnVmZmVyLmdldFVTaG9ydCgpLFxyXG4gICAgICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICAgIGNocm9tSWQsXHJcbiAgICAgICAgICAgICAgICBjaHJvbVNpemUsXHJcbiAgICAgICAgICAgICAgICBjaGlsZE9mZnNldCxcclxuICAgICAgICAgICAgICAgIGJ1ZmZlck9mZnNldCxcclxuICAgICAgICAgICAgICAgIGN1cnJPZmZzZXQ7XHJcblxyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGUgPT0gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGJ5dGVCdWZmZXIuZ2V0Rml4ZWRMZW5ndGhUcmltbWVkU3RyaW5nKGtleVNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNocm9tSWQgPSBieXRlQnVmZmVyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNocm9tU2l6ZSA9IGJ5dGVCdWZmZXIuZ2V0SW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGdlbm9tZSkga2V5ID0gZ2Vub21lLmdldENocm9tb3NvbWVOYW1lKGtleSk7ICAvLyBUcmFuc2xhdGUgdG8gY2Fub25pY2FsIGNociBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgZGljdGlvbmFyeVtrZXldID0gY2hyb21JZDtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7IC8vIG5vbi1sZWFmXHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gYnl0ZUJ1ZmZlci5nZXRGaXhlZExlbmd0aFRyaW1tZWRTdHJpbmcoa2V5U2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRPZmZzZXQgPSBieXRlQnVmZmVyLmdldExvbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXJPZmZzZXQgPSBjaGlsZE9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJPZmZzZXQgPSBieXRlQnVmZmVyLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRUcmVlTm9kZShieXRlQnVmZmVyLCBidWZmZXJPZmZzZXQsIGtleVNpemUsIGRpY3Rpb25hcnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVCdWZmZXIucG9zaXRpb24gPSBjdXJyT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHtCV1NvdXJjZSxCaW5hcnlQYXJzZXJ9O1xyXG5cclxuXHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7QUFtSEE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7OztBQWxKQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7O0FBeUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBQUE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/bigwig.js\n");

/***/ }),

/***/ "./src/feature.js":
/*!************************!*\
  !*** ./src/feature.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.BigBedFeatureSource = exports.FastaSequence = exports.FeatureSource = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _utils = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n\nvar _igvxhr = __webpack_require__(/*! ./igvxhr.js */ \"./src/igvxhr.js\");\n\nvar _bam = __webpack_require__(/*! ./bam.js */ \"./src/bam.js\");\n\nvar _bigwig = __webpack_require__(/*! ./bigwig.js */ \"./src/bigwig.js\");\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MAX_GZIP_BLOCK_SIZE = 1 << 16;\n\n/**\r\n * feature source for \"bed like\" files (tab delimited files with 1 feature per line: bed, gff, vcf, etc)\r\n *\r\n * @param config\r\n * @constructor\r\n */\n\nvar FeatureSource = function () {\n    function FeatureSource(config) {\n        _classCallCheck(this, FeatureSource);\n\n        this.config = config || {};\n\n        this.sourceType = config.sourceType === undefined ? \"file\" : config.sourceType;\n\n        if (config.sourceType === \"ga4gh\") {\n            this.reader = new igv.Ga4ghVariantReader(config);\n        } else if (config.sourceType === \"immvar\") {\n            this.reader = new igv.ImmVarReader(config);\n        } else if (config.type === \"eqtl\") {\n            if (config.sourceType === \"gtex-ws\") {\n                this.reader = new igv.GtexReader(config);\n            } else {\n                this.reader = new igv.GtexFileReader(config);\n            }\n        } else if (config.sourceType === \"bigquery\") {\n            this.reader = new igv.BigQueryFeatureReader(config);\n        } else {\n            // Default for all sorts of ascii tab-delimited file formts\n            this.reader = new FeatureFileReader(config);\n        }\n        this.visibilityWindow = config.visibilityWindow;\n    }\n\n    _createClass(FeatureSource, [{\n        key: \"getFileHeader\",\n        value: function getFileHeader() {\n\n            var self = this,\n                maxRows = this.config.maxRows || 500;\n\n            return new Promise(function (fulfill, reject) {\n\n                if (self.header) {\n                    fulfill(self.header);\n                } else {\n                    if (typeof self.reader.readHeader === \"function\") {\n\n                        self.reader.readHeader().then(function (header) {\n                            self.is_indexed = true;\n                            // Non-indexed readers will return features as a side effect.  This is an important,\n                            // if unfortunate, performance hack\n\n                            if (header) {\n                                var features = header.features;\n                                if (features) {\n\n                                    if (\"gtf\" === self.config.format || \"gff3\" === self.config.format || \"gff\" === self.config.format) {\n                                        features = new igv.GFFHelper(self.config.format).combineFeatures(features);\n                                    }\n\n                                    // Assign overlapping features to rows\n\n                                    packFeatures(features, maxRows);\n                                    self.featureCache = new FeatureCache(features);\n\n                                    // If track is marked \"searchable\"< cache features by name -- use this with caution, memory intensive\n                                    if (self.config.searchable) {\n                                        self.addFeaturesToDB(features);\n                                    }\n                                }\n                            }\n\n                            if (header && header.format) {\n                                self.config.format = header.format;\n                            }\n\n                            fulfill(header);\n                        }).catch(reject);\n                    } else {\n                        fulfill(null);\n                    }\n                }\n            });\n        }\n    }, {\n        key: \"getFeatures\",\n        value: function getFeatures(chr, start, end, force, data) {\n\n            //no need to get header\n            if (this.is_indexed) {\n                return this._getFeatures(chr, start, end, force, data);\n            }\n            //get headers/index then get features\n            var self = this;\n            return new Promise(function (fulfill, reject) {\n                self.getFileHeader().then(function () {\n                    self._getFeatures(chr, start, end, force, data).then(function (features) {\n                        fulfill(features);\n                    });\n                });\n            });\n        }\n        /**\r\n         * Required function fo all data source objects.  Fetches features for the\r\n         * range requested and passes them on to the success function.  Usually this is\r\n         * a function that renders the features on the canvas\r\n         *\r\n         * @param chr\r\n         * @param bpStart\r\n         * @param bpEnd\r\n         */\n\n    }, {\n        key: \"_getFeatures\",\n        value: function _getFeatures(chr, bpStart, bpEnd, force, data) {\n\n            var self = this;\n            self.time = Date.now();\n            return new Promise(function (fulfill, reject) {\n\n                var genomicInterval = new GenomicInterval(chr, bpStart, bpEnd),\n                    featureCache = self.featureCache,\n                    maxRows = self.config.maxRows || 500;\n\n                if (featureCache && (featureCache.range === undefined || featureCache.range.containsRange(genomicInterval))) {\n                    fulfill(self.featureCache.queryFeatures(chr, bpStart, bpEnd));\n                } else {\n                    // TODO -- reuse cached features that overelap new region\n\n                    /* if (self.sourceType === 'file' && (self.visibilityWindow === undefined || self.visibilityWindow <= 0)) {\r\n                         // Expand genomic interval to grab entire chromosome\r\n                         genomicInterval.start = 0;\r\n                         var chromosome =chr;\r\n                         genomicInterval.end = (chromosome === undefined ?  Number.MAX_VALUE : chromosome.bpLength);\r\n                     }\r\n                     */\n\n                    self.retrieveFeatures(chr, genomicInterval.start, genomicInterval.end, force, data).then(function (featureList) {\n                        if (featureList && typeof featureList.forEach === 'function') {\n                            // Have result AND its an array type\n\n                            var isIndexed = self.reader.indexed || self.config.sourceType === \"ga4gh\" || self.config.sourceType === \"immvar\" || self.config.sourceType === \"gtex\" || self.config.sourceType === \"bigquery\" || self.config.sourceType === \"custom\";\n\n                            // TODO -- COMBINE GFF FEATURES HERE\n                            // if(self.isGFF) featureList = combineFeatures(featureList);\n                            if (\"gtf\" === self.config.format || \"gff3\" === self.config.format || \"gff\" === self.config.format) {\n                                featureList = new igv.GFFHelper(self.config.format).combineFeatures(featureList);\n                            }\n\n                            self.featureCache = isIndexed ? new FeatureCache(featureList, genomicInterval) : new FeatureCache(featureList); // Note - replacing previous cache with new one\n\n\n                            // Assign overlapping features to rows\n                            FeatureSource.packFeatures(featureList, maxRows);\n\n                            // If track is marked \"searchable\"< cache features by name -- use this with caution, memory intensive\n                            if (self.config.searchable) {\n                                addFeaturesToDB(featureList);\n                            }\n\n                            // Finally pass features for query interval to continuation\n                            fulfill(self.featureCache.queryFeatures(chr, bpStart, bpEnd));\n                        } else {\n                            fulfill(null);\n                        }\n                    }).catch(reject);\n                }\n            });\n        }\n    }, {\n        key: \"retrieveFeatures\",\n        value: function retrieveFeatures(chr, start, end) {\n            return this.reader.readFeatures(chr, start, end);\n        }\n    }], [{\n        key: \"addFeaturesToDB\",\n        value: function addFeaturesToDB(featureList) {\n            featureList.forEach(function (feature) {\n                if (feature.name) {\n                    igv.browser.featureDB[feature.name.toUpperCase()] = feature;\n                }\n            });\n        }\n    }, {\n        key: \"packFeatures\",\n        value: function packFeatures(features, maxRows) {\n\n            if (features == null || features.length === 0) {\n                return;\n            }\n\n            // Segregate by chromosome\n\n            var chrFeatureMap = {},\n                chrs = [];\n            features.forEach(function (feature) {\n\n                var chr = feature.chr,\n                    flist = chrFeatureMap[chr];\n\n                if (!flist) {\n                    flist = [];\n                    chrFeatureMap[chr] = flist;\n                    chrs.push(chr);\n                }\n\n                flist.push(feature);\n            });\n\n            // Loop through chrosomosomes and pack features;\n\n            chrs.forEach(function (chr) {\n\n                pack(chrFeatureMap[chr], maxRows);\n            });\n\n            // Assigns a row # to each feature.  If the feature does not fit in any row and #rows == maxRows no\n            // row number is assigned.\n            function pack(featureList, maxRows) {\n\n                var rows = [];\n\n                featureList.sort(function (a, b) {\n                    return a.start - b.start;\n                });\n\n                rows.push(-1000);\n                featureList.forEach(function (feature) {\n\n                    var i,\n                        r,\n                        len = Math.min(rows.length, maxRows),\n                        start = feature.start;\n\n                    for (r = 0; r < len; r++) {\n                        if (start >= rows[r]) {\n                            feature.row = r;\n                            rows[r] = feature.end;\n                            return;\n                        }\n                    }\n                    feature.row = r;\n                    rows[r] = feature.end;\n                });\n            }\n        }\n    }]);\n\n    return FeatureSource;\n}();\n\nvar BigBedFeatureSource = function (_FeatureSource) {\n    _inherits(BigBedFeatureSource, _FeatureSource);\n\n    function BigBedFeatureSource(config, decode_function) {\n        _classCallCheck(this, BigBedFeatureSource);\n\n        config.sourceType = \"gtex\";\n\n        var _this = _possibleConstructorReturn(this, (BigBedFeatureSource.__proto__ || Object.getPrototypeOf(BigBedFeatureSource)).call(this, config));\n\n        _this.header = true;\n        _this.feature_source = new _bigwig.BWSource(config, decode_function);\n        return _this;\n    }\n\n    _createClass(BigBedFeatureSource, [{\n        key: \"retrieveFeatures\",\n        value: function retrieveFeatures(chr, bpStart, bpEnd, force, data) {\n            return this.feature_source.getFeatures(chr, bpStart, bpEnd, false, data);\n        }\n    }]);\n\n    return BigBedFeatureSource;\n}(FeatureSource);\n\n//********js/FeatureFileReader.js*****\n\n\nvar F_MAX_GZIP_BLOCK_SIZE = 1 << 16;\n\n/**\r\n * Reader for \"bed like\" files (tab delimited files with 1 feature per line: bed, gff, vcf, etc)\r\n *\r\n * @param config\r\n * @constructor\r\n */\n\nvar FeatureFileReader = function () {\n    function FeatureFileReader(config) {\n        _classCallCheck(this, FeatureFileReader);\n\n        this.config = config || {};\n\n        if (config.localFile) {\n            this.localFile = config.localFile;\n            this.filename = config.localFile.name;\n        } else {\n            this.url = config.url;\n            this.indexURL = config.indexURL;\n            this.headURL = config.headURL || this.filename;\n\n            var uriParts = _utils.Utils.parseUri(config.url);\n            this.filename = uriParts.file;\n            this.path = uriParts.path;\n        }\n\n        this.format = config.format;\n\n        this.parser = this.getParser(this.format, config.decode);\n    }\n\n    _createClass(FeatureFileReader, [{\n        key: \"getParser\",\n        value: function getParser(format, decode) {\n            switch (format) {\n                case \"vcf\":\n                    return new VcfParser();\n                case \"seg\":\n                    return new SegParser();\n                default:\n                    return new FeatureParser(format, decode, this.config);\n            }\n        }\n\n        // seg files don't have an index\n\n    }, {\n        key: \"isIndexable\",\n        value: function isIndexable() {\n            var configIndexURL = this.config.indexURL,\n                type = this.type,\n                configIndexed = this.config.indexed;\n\n            return configIndexURL || type != \"wig\" && configIndexed != false;\n        }\n\n        /**\r\n         * Return a Promise for the async loaded index\r\n         */\n\n    }, {\n        key: \"loadIndex\",\n        value: function loadIndex() {\n            var idxFile = this.indexURL;\n            if (this.filename.endsWith(\".gz\")) {\n                if (!idxFile) idxFile = this.url + \".tbi\";\n                return (0, _bam.loadBamIndex)(idxFile, this.config, true);\n            } else {\n                if (!idxFile) idxFile = this.url + \".idx\";\n                return loadTribbleIndex(idxFile, this.config);\n            }\n        }\n    }, {\n        key: \"loadFeaturesNoIndex\",\n        value: function loadFeaturesNoIndex() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var parser = self.parser,\n                    options = {\n                    headers: self.config.headers, // http headers, not file header\n                    withCredentials: self.config.withCredentials\n                };\n\n                if (self.localFile) {\n                    _igvxhr.igvxhr.loadStringFromFile(self.localFile, options).then(parseData).catch(reject);\n                } else {\n                    _igvxhr.igvxhr.loadString(self.url, options).then(parseData).catch(reject);\n                }\n\n                function parseData(data) {\n                    self.header = parser.parseHeader(data);\n                    if (self.header instanceof String && self.header.startsWith(\"##gff-version 3\")) {\n                        self.format = 'gff3';\n                    }\n                    fulfill(parser.parseFeatures(data)); // <= PARSING DONE HERE\n                };\n            });\n        }\n    }, {\n        key: \"loadFeaturesWithIndex\",\n        value: function loadFeaturesWithIndex(chr, start, end) {\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                var blocks,\n                    index = self.index,\n                    tabix = index && index.tabix,\n                    refId = tabix ? index.sequenceIndexMap[chr] : chr,\n                    promises = [];\n\n                blocks = index.blocksForRange(refId, start, end);\n\n                if (!blocks || blocks.length === 0) {\n                    fulfill(null); // TODO -- is this correct?  Should it return an empty array?\n                } else {\n\n                    blocks.forEach(function (block) {\n\n                        promises.push(new Promise(function (fulfill, reject) {\n\n                            var startPos = block.minv.block,\n                                startOffset = block.minv.offset,\n                                endPos = block.maxv.block + (index.tabix ? F_MAX_GZIP_BLOCK_SIZE : 0),\n                                options = {\n                                headers: self.config.headers, // http headers, not file header\n                                range: { start: startPos, size: endPos - startPos + 1 },\n                                withCredentials: self.config.withCredentials\n                            },\n                                success;\n\n                            success = function success(data) {\n\n                                var inflated, slicedData;\n\n                                if (index.tabix) {\n\n                                    inflated = _igvxhr.igvxhr.arrayBufferToString((0, _igvxhr.unbgzf)(data));\n                                    // need to decompress data\n                                } else {\n                                    inflated = data;\n                                }\n\n                                slicedData = startOffset ? inflated.slice(startOffset) : inflated;\n                                var f = self.parser.parseFeatures(slicedData);\n                                fulfill(f);\n                            };\n\n                            // Async load\n                            if (self.localFile) {\n                                _igvxhr.igvxhr.loadStringFromFile(self.localFile, options).then(success).catch(reject);\n                            } else {\n                                if (index.tabix) {\n                                    _igvxhr.igvxhr.loadArrayBuffer(self.url, options).then(success).catch(reject);\n                                } else {\n                                    _igvxhr.igvxhr.loadString(self.url, options).then(success).catch(reject);\n                                }\n                            }\n                        }));\n                    });\n\n                    Promise.all(promises).then(function (featureArrays) {\n\n                        var i, allFeatures;\n\n                        if (featureArrays.length === 1) {\n                            allFeatures = featureArrays[0];\n                        } else {\n                            allFeatures = featureArrays[0];\n\n                            for (i = 1; i < featureArrays.length; i++) {\n                                allFeatures = allFeatures.concat(featureArrays[i]);\n                            }\n\n                            allFeatures.sort(function (a, b) {\n                                return a.start - b.start;\n                            });\n                        }\n\n                        fulfill(allFeatures);\n                    }).catch(reject);\n                }\n            });\n        }\n    }, {\n        key: \"getIndex\",\n        value: function getIndex() {\n\n            var self = this,\n                isIndeedIndexible = this.isIndexable();\n            return new Promise(function (fulfill, reject) {\n\n                if (self.indexed === undefined && isIndeedIndexible) {\n                    self.loadIndex().then(function (index) {\n                        if (index) {\n                            self.index = index;\n                            self.indexed = true;\n                        } else {\n                            self.indexed = false;\n                        }\n                        fulfill(self.index);\n                    });\n                } else {\n                    fulfill(self.index); // Is either already loaded, or there isn't one\n                }\n            });\n        }\n    }, {\n        key: \"readHeader\",\n        value: function readHeader() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                if (self.header) {\n                    fulfill(self.header);\n                } else {\n\n                    // We force a load of the index first\n\n                    self.getIndex().then(function (index) {\n\n                        if (index) {\n                            // Load the file header (not HTTP header) for an indexed file.\n                            // TODO -- note this will fail if the file header is > 65kb in size\n                            var options = {\n                                headers: self.config.headers, // http headers, not file header\n                                bgz: index.tabix,\n                                range: { start: 0, size: 65000 },\n                                withCredentials: self.config.withCredentials\n                            },\n                                success = function success(data) {\n                                self.header = self.parser.parseHeader(data);\n                                fulfill(self.header);\n                            };\n\n                            if (self.localFile) {\n                                _igvxhr.igvxhr.loadStringFromFile(self.localFile, options).then(success);\n                            } else {\n                                _igvxhr.igvxhr.loadString(self.url, options).then(success).catch(reject);\n                            }\n                        } else {\n                            self.loadFeaturesNoIndex(undefined).then(function (features) {\n                                var header = self.header || {};\n                                header.features = features;\n                                fulfill(header);\n                            }).catch(reject);\n                        }\n                    });\n                }\n            });\n        }\n\n        /**\r\n         *\r\n         * @param fulfill\r\n         * @param range -- genomic range to load.  For use with indexed source (optional)\r\n         */\n\n    }, {\n        key: \"readFeatures\",\n        value: function readFeatures(chr, start, end) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                if (self.index) {\n                    self.loadFeaturesWithIndex(chr, start, end).then(packFeatures);\n                } else {\n                    self.loadFeaturesNoIndex().then(packFeatures);\n                }\n\n                function packFeatures(features) {\n                    // TODO pack\n                    fulfill(features);\n                }\n            });\n        }\n    }]);\n\n    return FeatureFileReader;\n}();\n\n//***js/feature/FeatureParsers.js**************\n\n\nvar maxFeatureCount = Number.MAX_VALUE; // For future use,  controls downsampling\n\nvar gffNameFields = [\"Name\", \"gene_name\", \"gene\", \"gene_id\", \"alias\", \"locus\"];\n\n/**\r\n * A factory function.  Return a parser for the given file format.\r\n */\n\nvar FeatureParser = function () {\n    function FeatureParser(format, decode, config) {\n        _classCallCheck(this, FeatureParser);\n\n        var customFormat;\n\n        this.format = format;\n        this.nameField = config ? config.nameField : undefined;\n        this.skipRows = 0; // The number of fixed header rows to skip.  Override for specific types as needed\n\n        if (decode) {\n            this.decode = decode;\n        }\n\n        switch (format) {\n            case \"narrowpeak\":\n            case \"broadpeak\":\n            case \"peaks\":\n                this.decode = this.decodePeak;\n                this.delimiter = /\\s+/;\n                break;\n            case \"bedgraph\":\n                this.decode = this.decodeBedGraph;\n                this.delimiter = /\\s+/;\n                break;\n            case \"wig\":\n                this.decode = this.decodeWig;\n                this.delimiter = /\\s+/;\n                break;\n            case \"gff3\":\n            case \"gff\":\n            case \"gtf\":\n                this.decode = this.decodeGFF;\n                this.delimiter = \"\\t\";\n                break;\n            case \"aneu\":\n                this.decode = this.decodeAneu;\n                this.delimiter = \"\\t\";\n                break;\n            case \"fusionjuncspan\":\n                // bhaas, needed for FusionInspector view\n                this.decode = this.decodeFusionJuncSpan;\n                this.delimiter = /\\s+/;\n                break;\n            case \"gtexgwas\":\n                this.skipRows = 1;\n                this.decode = this.decodeGtexGWAS;\n                this.delimiter = \"\\t\";\n                break;\n            case \"refflat\":\n                this.decode = this.decodeRefflat;\n                this.delimiter = \"\\t\";\n                break;\n            default:\n\n                /* customFormat = igv.browser.getFormat(format);\r\n                 if (customFormat !== undefined) {\r\n                     this.decode = decodeCustom;\r\n                     this.format = customFormat;\r\n                     this.delimiter = customFormat.delimiter || \"\\t\";\r\n                 }\r\n                   else {\r\n                                                 */\n                this.decode = FeatureParser.decodeBed;\n                this.delimiter = /\\s+/;\n            // }\n\n        }\n    }\n\n    _createClass(FeatureParser, [{\n        key: \"parseHeader\",\n        value: function parseHeader(data) {\n\n            var lines = data.split(\"\\n\"),\n                len = lines.length,\n                line,\n                i,\n                header;\n\n            for (i = 0; i < len; i++) {\n                line = lines[i];\n                if (line.startsWith(\"track\") || line.startsWith(\"#\") || line.startsWith(\"browser\")) {\n                    if (line.startsWith(\"track\")) {\n                        header = this.parseTrackLine(line);\n                    } else if (line.startsWith(\"##gff-version 3\")) {\n                        this.format = \"gff3\";\n                        if (!header) header = {};\n                        header[\"format\"] = \"gff3\";\n                    }\n                } else {\n                    header = {};\n                    break;\n                }\n            }\n            return header;\n        }\n    }, {\n        key: \"parseFeatures\",\n        value: function parseFeatures(data) {\n\n            if (!data) return null;\n\n            var wig,\n                feature,\n                lines = data.split(\"\\n\"),\n                len = lines.length,\n                tokens,\n                allFeatures = [],\n                line,\n                i,\n                cnt = 0,\n                j,\n                decode = this.decode,\n                format = this.format,\n                delimiter = this.delimiter || \"\\t\";\n\n            for (i = this.skipRows; i < len; i++) {\n                line = lines[i];\n                if (line.startsWith(\"track\") || line.startsWith(\"#\") || line.startsWith(\"browser\")) {\n                    continue;\n                } else if (format === \"wig\" && line.startsWith(\"fixedStep\")) {\n                    wig = this.parseFixedStep(line);\n                    continue;\n                } else if (format === \"wig\" && line.startsWith(\"variableStep\")) {\n                    wig = this.parseVariableStep(line);\n                    continue;\n                }\n\n                tokens = lines[i].split(delimiter);\n                if (tokens.length < 1) continue;\n\n                feature = this.decode(tokens, wig);\n\n                if (feature) {\n                    if (allFeatures.length < maxFeatureCount) {\n                        allFeatures.push(feature);\n                    } else {\n                        // Reservoir sampling,  conditionally replace existing feature with new one.\n                        j = Math.floor(Math.random() * cnt);\n                        if (j < maxFeatureCount) {\n                            allFeatures[j] = feature;\n                        }\n                    }\n                    cnt++;\n                }\n            }\n\n            return allFeatures;\n        }\n    }, {\n        key: \"decodeCustom\",\n\n\n        /**\r\n         * Decode the \"standard\" UCSC bed format\r\n         * @param tokens\r\n         * @param ignore\r\n         * @returns decoded feature, or null if this is not a valid record\r\n         */\n        value: function decodeCustom(tokens, ignore) {\n\n            var feature,\n                chr,\n                start,\n                end,\n                format = this.format,\n                // \"this\" refers to FeatureParser instance\n            coords = format.coords || 0;\n\n            if (tokens.length < 3) return null;\n\n            chr = tokens[format.chr];\n            start = parseInt(tokens[format.start]) - coords;\n            end = format.end !== undefined ? parseInt(tokens[format.end]) : start + 1;\n\n            feature = { chr: chr, start: start, end: end };\n\n            if (format.fields) {\n                format.fields.forEach(function (field, index) {\n                    if (index != format.chr && index != format.start && index != format.end) {\n                        feature[field] = tokens[index];\n                    }\n                });\n            }\n\n            return feature;\n        }\n    }], [{\n        key: \"parseFixedStep\",\n        value: function parseFixedStep(line) {\n\n            var tokens = line.split(/\\s+/),\n                cc = tokens[1].split(\"=\")[1],\n                ss = parseInt(tokens[2].split(\"=\")[1], 10),\n                step = parseInt(tokens[3].split(\"=\")[1], 10),\n                span = tokens.length > 4 ? parseInt(tokens[4].split(\"=\")[1], 10) : 1;\n\n            return { format: \"fixedStep\", chrom: cc, start: ss, step: step, span: span, index: 0 };\n        }\n    }, {\n        key: \"parseVariableStep\",\n        value: function parseVariableStep(line) {\n\n            var tokens = line.split(/\\s+/),\n                cc = tokens[1].split(\"=\")[1],\n                span = tokens.length > 2 ? parseInt(tokens[2].split(\"=\")[1], 10) : 1;\n            return { format: \"variableStep\", chrom: cc, span: span };\n        }\n    }, {\n        key: \"parseTrackLine\",\n        value: function parseTrackLine(line) {\n            var properties = {},\n                tokens = line.split(/(?:\")([^\"]+)(?:\")|([^\\s\"]+)(?=\\s+|$)/g),\n                tmp = [],\n                i,\n                tk,\n                curr;\n\n            // Clean up tokens array\n            for (i = 1; i < tokens.length; i++) {\n                if (!tokens[i] || tokens[i].trim().length === 0) continue;\n\n                tk = tokens[i].trim();\n\n                if (tk.endsWith(\"=\") > 0) {\n                    curr = tk;\n                } else if (curr) {\n                    tmp.push(curr + tk);\n                    curr = undefined;\n                } else {\n                    tmp.push(tk);\n                }\n            }\n\n            tmp.forEach(function (str) {\n                if (!str) return;\n                var kv = str.split('=', 2);\n                if (kv.length == 2) {\n                    properties[kv[0]] = kv[1];\n                }\n            });\n\n            return properties;\n        }\n\n        /**\r\n         * Decode the \"standard\" UCSC bed format\r\n         * @param tokens\r\n         * @param ignore\r\n         * @returns decoded feature, or null if this is not a valid record\r\n         */\n\n    }, {\n        key: \"decodeBed\",\n        value: function decodeBed(tokens, ignore) {\n\n            var chr, start, end, id, name, tmp, idName, exonCount, exonSizes, exonStarts, exons, exon, feature, eStart, eEnd;\n\n            if (tokens.length < 3) return null;\n\n            chr = tokens[0];\n            start = parseInt(tokens[1]);\n            end = tokens.length > 2 ? parseInt(tokens[2]) : start + 1;\n\n            feature = { chr: chr, start: start, end: end, score: 1000 };\n\n            if (tokens.length > 3) {\n                // Note: these are very special rules for the gencode gene files.\n                tmp = tokens[3].replace(/\"/g, '');\n                idName = tmp.split(';');\n                for (var i = 0; i < idName.length; i++) {\n                    var kv = idName[i].split('=');\n                    if (kv[0] == \"gene_id\") {\n                        id = kv[1];\n                    }\n                    if (kv[0] == \"gene_name\") {\n                        name = kv[1];\n                    }\n                }\n                feature.id = id ? id : tmp;\n                feature.name = name ? name : tmp;\n            }\n\n            if (tokens.length > 4) {\n                feature.score = parseFloat(tokens[4]);\n            }\n            if (tokens.length > 5) {\n                feature.strand = tokens[5];\n            }\n            if (tokens.length > 6) {\n                feature.cdStart = parseInt(tokens[6]);\n            }\n            if (tokens.length > 7) {\n                feature.cdEnd = parseInt(tokens[7]);\n            }\n            if (tokens.length > 8) {\n                if (tokens[8] !== \".\" && tokens[8] !== \"0\") feature.color = igv.createColorString(tokens[8]);\n            }\n            if (tokens.length > 11) {\n                exonCount = parseInt(tokens[9]);\n                exonSizes = tokens[10].split(',');\n                exonStarts = tokens[11].split(',');\n                exons = [];\n\n                for (var i = 0; i < exonCount; i++) {\n                    eStart = start + parseInt(exonStarts[i]);\n                    eEnd = eStart + parseInt(exonSizes[i]);\n                    var exon = { start: eStart, end: eEnd };\n\n                    if (feature.cdStart > eEnd || feature.cdEnd < feature.cdStart) exon.utr = true; // Entire exon is UTR\n                    if (feature.cdStart >= eStart && feature.cdStart <= eEnd) exon.cdStart = feature.cdStart;\n                    if (feature.cdEnd >= eStart && feature.cdEnd <= eEnd) exon.cdEnd = feature.cdEnd;\n\n                    exons.push(exon);\n                }\n\n                feature.exons = exons;\n            }\n\n            feature.popupData = function () {\n                var data = [];\n                if (feature.name) data.push({ name: \"Name\", value: feature.name });\n                if (\"+\" === feature.strand || \"-\" === feature.strand) data.push({ name: \"Strand\", value: feature.strand });\n                return data;\n            };\n\n            return feature;\n        }\n\n        /**\r\n         * Decode a UCSC \"refflat\" record\r\n         * @param tokens\r\n         * @param ignore\r\n         * @returns {*}\r\n         */\n\n    }, {\n        key: \"decodeRefflat\",\n        value: function decodeRefflat(tokens, ignore) {\n\n            if (tokens.length < 10) return null;\n\n            var feature = {\n                chr: tokens[2],\n                start: parseInt(tokens[4]),\n                end: parseInt(tokens[5]),\n                id: tokens[1],\n                name: tokens[0],\n                strand: tokens[3],\n                cdStart: parseInt(tokens[6]),\n                cdEnd: parseInt(tokens[7])\n            },\n                exonCount = parseInt(tokens[8]),\n                exonStarts = tokens[9].split(','),\n                exonEnds = tokens[10].split(','),\n                exons = [];\n\n            for (var i = 0; i < exonCount; i++) {\n                exons.push({ start: parseInt(exonStarts[i]), end: parseInt(exonEnds[i]) });\n            }\n\n            feature.exons = exons;\n\n            feature.popupData = function () {\n                return [{ name: \"Name\", value: feature.name }];\n            };\n\n            return feature;\n        }\n    }, {\n        key: \"decodePeak\",\n        value: function decodePeak(tokens, ignore) {\n\n            var tokenCount, chr, start, end, strand, name, score, qValue, signal, pValue;\n\n            tokenCount = tokens.length;\n            if (tokenCount < 9) {\n                return null;\n            }\n\n            chr = tokens[0];\n            start = parseInt(tokens[1]);\n            end = parseInt(tokens[2]);\n            name = tokens[3];\n            score = parseFloat(tokens[4]);\n            strand = tokens[5].trim();\n            signal = parseFloat(tokens[6]);\n            pValue = parseFloat(tokens[7]);\n            qValue = parseFloat(tokens[8]);\n\n            if (score === 0) score = signal;\n\n            return {\n                chr: chr, start: start, end: end, name: name, score: score, strand: strand, signal: signal,\n                pValue: pValue, qValue: qValue\n            };\n        }\n    }, {\n        key: \"decodeBedGraph\",\n        value: function decodeBedGraph(tokens, ignore) {\n\n            var chr, start, end, value;\n\n            if (tokens.length < 3) return null;\n\n            chr = tokens[0];\n            start = parseInt(tokens[1]);\n            end = parseInt(tokens[2]);\n\n            value = parseFloat(tokens[3]);\n\n            return { chr: chr, start: start, end: end, value: value };\n        }\n    }, {\n        key: \"decodeWig\",\n        value: function decodeWig(tokens, wig) {\n\n            var ss, ee, value;\n\n            if (wig.format === \"fixedStep\") {\n\n                ss = wig.index * wig.step + wig.start;\n                ee = ss + wig.span;\n                value = parseFloat(tokens[0]);\n                ++wig.index;\n                return isNaN(value) ? null : { chr: wig.chrom, start: ss, end: ee, value: value };\n            } else if (wig.format === \"variableStep\") {\n\n                if (tokens.length < 2) return null;\n\n                ss = parseInt(tokens[0], 10);\n                ee = ss + wig.span;\n                value = parseFloat(tokens[1]);\n                return isNaN(value) ? null : { chr: wig.chrom, start: ss, end: ee, value: value };\n            } else {\n                return decodeBedGraph(tokens);\n            }\n        }\n    }, {\n        key: \"decodeAneu\",\n        value: function decodeAneu(tokens, ignore) {\n\n            var chr, start, end, feature;\n\n            if (tokens.length < 4) return null;\n\n            chr = tokens[1];\n            start = parseInt(tokens[2]);\n            end = tokens.length > 3 ? parseInt(tokens[3]) : start + 1;\n\n            feature = { chr: chr, start: start, end: end };\n\n            if (tokens.length > 4) {\n                feature.score = parseFloat(tokens[4]);\n                feature.value = feature.score;\n            }\n\n            feature.popupData = function () {\n                return [{ name: \"Name\", value: feature.name }];\n            };\n\n            return feature;\n        }\n    }, {\n        key: \"decodeFusionJuncSpan\",\n        value: function decodeFusionJuncSpan(tokens, ignore) {\n\n            /*\r\n             Format:\r\n               0       #scaffold\r\n             1       fusion_break_name\r\n             2       break_left\r\n             3       break_right\r\n             4       num_junction_reads\r\n             5       num_spanning_frags\r\n             6       spanning_frag_coords\r\n               0       B3GNT1--NPSR1\r\n             1       B3GNT1--NPSR1|2203-10182\r\n             2       2203\r\n             3       10182\r\n             4       189\r\n             5       1138\r\n             6       1860-13757,1798-13819,1391-18127,1443-17174,...\r\n               */\n\n            var chr = tokens[0];\n            var fusion_name = tokens[1];\n            var junction_left = parseInt(tokens[2]);\n            var junction_right = parseInt(tokens[3]);\n            var num_junction_reads = parseInt(tokens[4]);\n            var num_spanning_frags = parseInt(tokens[5]);\n\n            var spanning_frag_coords_text = tokens[6];\n\n            var feature = {\n                chr: chr,\n                name: fusion_name,\n                junction_left: junction_left,\n                junction_right: junction_right,\n                num_junction_reads: num_junction_reads,\n                num_spanning_frags: num_spanning_frags,\n                spanning_frag_coords: [],\n\n                start: -1,\n                end: -1\n            }; // set start and end later based on min/max of span coords\n\n            var min_coord = junction_left;\n            var max_coord = junction_right;\n\n            if (num_spanning_frags > 0) {\n\n                var coord_pairs = spanning_frag_coords_text.split(',');\n\n                for (var i = 0; i < coord_pairs.length; i++) {\n                    var split_coords = coord_pairs[i].split('-');\n\n                    var span_left = split_coords[0];\n                    var span_right = split_coords[1];\n\n                    if (span_left < min_coord) {\n                        min_coord = span_left;\n                    }\n                    if (span_right > max_coord) {\n                        max_coord = span_right;\n                    }\n                    feature.spanning_frag_coords.push({ left: span_left, right: span_right });\n                }\n            }\n\n            feature.start = min_coord;\n            feature.end = max_coord;\n\n            feature.popupData = function () {\n                return [{ name: \"Name\", value: feature.name }];\n            };\n\n            return feature;\n        }\n    }, {\n        key: \"decodeGtexGWAS\",\n        value: function decodeGtexGWAS(tokens, ignore) {\n\n            var tokenCount, chr, start, end, strand, name, score, qValue, signal, pValue;\n\n            tokenCount = tokens.length;\n            if (tokenCount < 8) {\n                return null;\n            }\n\n            chr = tokens[0];\n            start = parseInt(tokens[1]) - 1;\n            end = parseInt(tokens[3].split(':')[1]);\n            //name = tokens[3];\n            //score = parseFloat(tokens[4]);\n            //strand = tokens[5].trim();\n            //signal = parseFloat(tokens[6]);\n            pValue = parseFloat(tokens[5]);\n            //qValue = parseFloat(tokens[8]);\n\n            //return {chr: chr, start: start, end: end, name: name, score: score, strand: strand, signal: signal,\n            //    pValue: pValue, qValue: qValue};\n            return { chr: chr, start: start, end: end, pvalue: pValue };\n        }\n\n        /**\r\n         * Decode a single gff record (1 line in file).  Aggregations such as gene models are constructed at a higher level.\r\n         *      ctg123 . mRNA            1050  9000  .  +  .  ID=mRNA00001;Parent=gene00001\r\n         * @param tokens\r\n         * @param ignore\r\n         * @returns {*}\r\n         */\n\n    }, {\n        key: \"decodeGFF\",\n        value: function decodeGFF(tokens, ignore) {\n\n            var tokenCount,\n                chr,\n                start,\n                end,\n                strand,\n                type,\n                score,\n                phase,\n                attributeString,\n                id,\n                parent,\n                color,\n                name,\n                transcript_id,\n                i,\n                format = this.format;\n\n            tokenCount = tokens.length;\n            if (tokenCount < 9) {\n                return null; // Not a valid gff record\n            }\n\n            chr = tokens[0];\n            type = tokens[2];\n            start = parseInt(tokens[3]) - 1;\n            end = parseInt(tokens[4]);\n            score = \".\" === tokens[5] ? 0 : parseFloat(tokens[5]);\n            strand = tokens[6];\n            phase = \".\" === tokens[7] ? 0 : parseInt(tokens[7]);\n            attributeString = tokens[8];\n\n            // Find ID and Parent, or transcript_id\n            var delim = 'gff3' === format ? '=' : /\\s+/;\n            var attributes = {};\n            attributeString.split(';').forEach(function (kv) {\n                var t = kv.trim().split(delim, 2),\n                    key,\n                    value;\n                if (t.length == 2) {\n                    key = t[0].trim();\n                    value = t[1].trim();\n                    //Strip off quotes, if any\n                    if (value.startsWith('\"') && value.endsWith('\"')) {\n                        value = value.substr(1, value.length - 2);\n                    }\n                    if (\"ID\" === t[0]) id = t[1];else if (\"Parent\" === t[0]) parent = t[1];else if (\"color\" === t[0].toLowerCase()) color = igv.createColorString(t[1]);else if (\"transcript_id\" === t[0]) id = t[1]; // gtf format\n                    attributes[key] = value;\n                }\n            });\n\n            // Find name (label) property\n            if (this.nameField) {\n                name = attributes[this.nameField];\n            } else {\n                for (i = 0; i < gffNameFields.length; i++) {\n                    if (attributes.hasOwnProperty(gffNameFields[i])) {\n                        this.nameField = gffNameFields[i];\n                        name = attributes[this.nameField];\n\n                        break;\n                    }\n                }\n            }\n\n            return {\n                id: id,\n                parent: parent,\n                name: name,\n                type: type,\n                chr: chr,\n                start: start,\n                end: end,\n                score: score,\n                strand: strand,\n                color: color,\n                attributeString: attributeString,\n                popupData: function popupData() {\n                    var kvs = this.attributeString.split(';'),\n                        pd = [],\n                        key,\n                        value;\n                    kvs.forEach(function (kv) {\n                        var t = kv.trim().split(delim, 2);\n                        if (t.length === 2 && t[1] !== undefined) {\n                            key = t[0].trim();\n                            value = t[1].trim();\n                            //Strip off quotes, if any\n                            if (value.startsWith('\"') && value.endsWith('\"')) {\n                                value = value.substr(1, value.length - 2);\n                            }\n                            pd.push({ name: key, value: value });\n                        }\n                    });\n                    return pd;\n                }\n\n            };\n        }\n    }]);\n\n    return FeatureParser;\n}();\n\n//*******js/feature/featureCache.js**********************\n\n\n/**\r\n * Object for caching lists of features.  Supports effecient queries for sub-range  (chr, start, end)\r\n *\r\n * @param featureList\r\n * @param The genomic range spanned by featureList (optional)\r\n * @constructor\r\n */\n\nvar FeatureCache = function () {\n    function FeatureCache(featureList, range) {\n        _classCallCheck(this, FeatureCache);\n\n        this.treeMap = FeatureCache.buildTreeMap(featureList);\n        this.range = range;\n    }\n\n    _createClass(FeatureCache, [{\n        key: \"queryFeatures\",\n        value: function queryFeatures(chr, start, end) {\n\n            var featureList, intervalFeatures, feature, len, i, tree, intervals;\n\n            tree = this.treeMap[chr];\n\n            if (!tree) return [];\n\n            intervals = tree.findOverlapping(start, end);\n\n            if (intervals.length == 0) {\n                return [];\n            } else {\n                // Trim the list of features in the intervals to those\n                // overlapping the requested range.\n                // Assumption: features are sorted by start position\n\n                featureList = [];\n\n                intervals.forEach(function (interval) {\n                    intervalFeatures = interval.value;\n                    len = intervalFeatures.length;\n                    for (i = 0; i < len; i++) {\n                        feature = intervalFeatures[i];\n                        if (feature.start > end) break;else if (feature.end >= start) {\n                            featureList.push(feature);\n                        }\n                    }\n                });\n                return featureList;\n            }\n        }\n    }, {\n        key: \"allFeatures\",\n        value: function allFeatures() {\n\n            var allFeatures = [];\n            var treeMap = this.treeMap;\n            if (treeMap) {\n                for (var key in treeMap) {\n                    if (treeMap.hasOwnProperty(key)) {\n\n                        var tree = treeMap[key];\n                        tree.mapIntervals(function (interval) {\n                            allFeatures = allFeatures.concat(interval.value);\n                        });\n                    }\n                }\n            }\n            return allFeatures;\n        }\n    }], [{\n        key: \"buildTreeMap\",\n        value: function buildTreeMap(featureList) {\n\n            var featureCache = {},\n                chromosomes = [],\n                treeMap = {},\n                genome = null;\n\n            if (featureList) {\n\n                featureList.forEach(function (feature) {\n\n                    var chr = feature.chr,\n                        geneList;\n\n                    // Translate to \"official\" name\n                    if (genome) chr = genome.getChromosomeName(chr);\n\n                    geneList = featureCache[chr];\n\n                    if (!geneList) {\n                        chromosomes.push(chr);\n                        geneList = [];\n                        featureCache[chr] = geneList;\n                    }\n\n                    geneList.push(feature);\n                });\n\n                // Now build interval tree for each chromosome\n\n                for (var i = 0; i < chromosomes.length; i++) {\n                    var chr = chromosomes[i];\n                    treeMap[chr] = FeatureCache.buildIntervalTree(featureCache[chr]);\n                }\n            }\n\n            return treeMap;\n        }\n    }, {\n        key: \"buildIntervalTree\",\n\n\n        /**\r\n         * Build an interval tree from the feature list for fast interval based queries.   We lump features in groups\r\n         * of 10, or total size / 100,   to reduce size of the tree.\r\n         *\r\n         * @param featureList\r\n         */\n        value: function buildIntervalTree(featureList) {\n\n            var i, e, iStart, iEnd, tree, chunkSize, len, subArray;\n\n            tree = new IntervalTree();\n            len = featureList.length;\n\n            chunkSize = Math.max(10, Math.round(len / 100));\n\n            featureList.sort(function (f1, f2) {\n                return f1.start === f2.start ? 0 : f1.start > f2.start ? 1 : -1;\n            });\n\n            for (i = 0; i < len; i += chunkSize) {\n                e = Math.min(len, i + chunkSize);\n                subArray = featureList.slice(i, e);\n                iStart = subArray[0].start;\n                //\n                iEnd = iStart;\n                subArray.forEach(function (feature) {\n                    iEnd = Math.max(iEnd, feature.end);\n                });\n                tree.insert(iStart, iEnd, subArray);\n            }\n\n            return tree;\n        }\n    }]);\n\n    return FeatureCache;\n}();\n\n//*****js/intervalTree.js************\n\n\nvar BLACK = 1;\nvar RED = 2;\n\nvar NIL = {};\nNIL.color = BLACK;\nNIL.parent = NIL;\nNIL.left = NIL;\nNIL.right = NIL;\n\nvar IntervalTree = function () {\n    function IntervalTree() {\n        _classCallCheck(this, IntervalTree);\n\n        this.root = NIL;\n    }\n\n    _createClass(IntervalTree, [{\n        key: \"insert\",\n        value: function insert(start, end, value) {\n\n            var interval = new Interval(start, end, value);\n            var x = new Node(interval);\n            this.treeInsert(x);\n            x.color = RED;\n            while (x != this.root && x.parent.color == RED) {\n                if (x.parent == x.parent.parent.left) {\n                    var y = x.parent.parent.right;\n                    if (y.color == RED) {\n                        x.parent.color = BLACK;\n                        y.color = BLACK;\n                        x.parent.parent.color = RED;\n                        x = x.parent.parent;\n                    } else {\n                        if (x == x.parent.right) {\n                            x = x.parent;\n                            this.leftRotate(x);\n                        }\n                        x.parent.color = BLACK;\n                        x.parent.parent.color = RED;\n                        this.rightRotate(x.parent.parent);\n                    }\n                } else {\n                    var y = x.parent.parent.left;\n                    if (y.color == RED) {\n                        x.parent.color = BLACK;\n                        y.color = BLACK;\n                        x.parent.parent.color = RED;\n                        x = x.parent.parent;\n                    } else {\n                        if (x == x.parent.left) {\n                            x = x.parent;\n                            this.rightRotate(x);\n                        }\n                        x.parent.color = BLACK;\n                        x.parent.parent.color = RED;\n                        this.leftRotate(x.parent.parent);\n                    }\n                }\n            }\n            this.root.color = BLACK;\n        }\n\n        /**\r\n         *\r\n         * @param start - query interval\r\n         * @param end - query interval\r\n         * @returns Array of all intervals overlapping the query region\r\n         */\n\n    }, {\n        key: \"findOverlapping\",\n        value: function findOverlapping(start, end) {\n\n            var searchInterval = new Interval(start, end, 0);\n\n            if (this.root === NIL) return [];\n\n            var intervals = this.searchAll(searchInterval, this.root, []);\n\n            if (intervals.length > 1) {\n                intervals.sort(function (i1, i2) {\n                    return i1.low - i2.low;\n                });\n            }\n\n            return intervals;\n        }\n\n        /**\r\n         * Dump info on intervals to console.  For debugging.\r\n         */\n\n    }, {\n        key: \"logIntervals\",\n        value: function logIntervals() {\n\n            logNode(this.root, 0);\n\n            function logNode(node, indent) {\n\n                var space = \"\";\n                for (var i = 0; i < indent; i++) {\n                    space += \" \";\n                }console.log(space + node.interval.low + \" \" + node.interval.high); // + \" \" + (node.interval.value ? node.interval.value : \" null\"));\n\n                indent += 5;\n\n                if (node.left != NIL) logNode(node.left, indent);\n                if (node.right != NIL) logNode(node.right, indent);\n            }\n        }\n    }, {\n        key: \"mapIntervals\",\n        value: function mapIntervals(func) {\n\n            applyInterval(this.root);\n\n            function applyInterval(node) {\n\n                func(node.interval);\n\n                if (node.left != NIL) applyInterval(node.left);\n                if (node.right != NIL) applyInterval(node.right);\n            }\n        }\n    }, {\n        key: \"searchAll\",\n        value: function searchAll(interval, node, results) {\n\n            if (node.interval.overlaps(interval)) {\n                results.push(node.interval);\n            }\n\n            if (node.left != NIL && node.left.max >= interval.low) {\n                this.searchAll(interval, node.left, results);\n            }\n\n            if (node.right != NIL && node.right.min <= interval.high) {\n                this.searchAll(interval, node.right, results);\n            }\n\n            return results;\n        }\n    }, {\n        key: \"leftRotate\",\n        value: function leftRotate(x) {\n            var y = x.right;\n            x.right = y.left;\n            if (y.left != NIL) {\n                y.left.parent = x;\n            }\n            y.parent = x.parent;\n            if (x.parent == NIL) {\n                this.root = y;\n            } else {\n                if (x.parent.left == x) {\n                    x.parent.left = y;\n                } else {\n                    x.parent.right = y;\n                }\n            }\n            y.left = x;\n            x.parent = y;\n\n            this.applyUpdate(x);\n            // no need to apply update on y, since it'll y is an ancestor\n            // of x, and will be touched by applyUpdate().\n        }\n    }, {\n        key: \"rightRotate\",\n        value: function rightRotate(x) {\n            var y = x.left;\n            x.left = y.right;\n            if (y.right != NIL) {\n                y.right.parent = x;\n            }\n            y.parent = x.parent;\n            if (x.parent == NIL) {\n                this.root = y;\n            } else {\n                if (x.parent.right == x) {\n                    x.parent.right = y;\n                } else {\n                    x.parent.left = y;\n                }\n            }\n            y.right = x;\n            x.parent = y;\n\n            this.applyUpdate(x);\n            // no need to apply update on y, since it'll y is an ancestor\n            // of x, and will be touched by applyUpdate().\n        }\n\n        /**\r\n         * Note:  Does not maintain RB constraints,  this is done post insert\r\n         *\r\n         * @param x  a Node\r\n         */\n\n    }, {\n        key: \"treeInsert\",\n        value: function treeInsert(x) {\n            var node = this.root;\n            var y = NIL;\n            while (node != NIL) {\n                y = node;\n                if (x.interval.low <= node.interval.low) {\n                    node = node.left;\n                } else {\n                    node = node.right;\n                }\n            }\n            x.parent = y;\n\n            if (y == NIL) {\n                this.root = x;\n                x.left = x.right = NIL;\n            } else {\n                if (x.interval.low <= y.interval.low) {\n                    y.left = x;\n                } else {\n                    y.right = x;\n                }\n            }\n\n            this.applyUpdate(x);\n        }\n\n        // Applies the statistic update on the node and its ancestors.\n\n    }, {\n        key: \"applyUpdate\",\n        value: function applyUpdate(node) {\n            while (node != NIL) {\n                var nodeMax = node.left.max > node.right.max ? node.left.max : node.right.max;\n                var intervalHigh = node.interval.high;\n                node.max = nodeMax > intervalHigh ? nodeMax : intervalHigh;\n\n                var nodeMin = node.left.min < node.right.min ? node.left.min : node.right.min;\n                var intervalLow = node.interval.low;\n                node.min = nodeMin < intervalLow ? nodeMin : intervalLow;\n\n                node = node.parent;\n            }\n        }\n    }]);\n\n    return IntervalTree;\n}();\n\nvar Interval = function () {\n    function Interval(low, high, value) {\n        _classCallCheck(this, Interval);\n\n        this.low = low;\n        this.high = high;\n        this.value = value;\n    }\n\n    _createClass(Interval, [{\n        key: \"equals\",\n        value: function equals(other) {\n            if (!other) {\n                return false;\n            }\n            if (this == other) {\n                return true;\n            }\n            return this.low == otherInterval.low && this.high == otherInterval.high;\n        }\n    }, {\n        key: \"compareTo\",\n        value: function compareTo(other) {\n            if (this.low < other.low) return -1;\n            if (this.low > other.low) return 1;\n\n            if (this.high < other.high) return -1;\n            if (this.high > other.high) return 1;\n\n            return 0;\n        }\n\n        /**\r\n         * Returns true if this interval overlaps the other.\r\n         */\n\n    }, {\n        key: \"overlaps\",\n        value: function overlaps(other) {\n            try {\n                return this.low <= other.high && other.low <= this.high;\n            } catch (e) {\n                //alert(e);\n                igv.presentAlert(e);\n            }\n        }\n    }]);\n\n    return Interval;\n}();\n\nvar Node = function Node(interval) {\n    _classCallCheck(this, Node);\n\n    this.parent = NIL;\n    this.left = NIL;\n    this.right = NIL;\n    this.interval = interval;\n    this.color = RED;\n};\n\nvar GenomicInterval = function () {\n    function GenomicInterval(chr, start, end, features) {\n        _classCallCheck(this, GenomicInterval);\n\n        this.chr = chr;\n        this.start = start;\n        this.end = end;\n        this.features = features;\n    }\n\n    _createClass(GenomicInterval, [{\n        key: \"contains\",\n        value: function contains(chr, start, end) {\n            return this.chr == chr && this.start <= start && this.end >= end;\n        }\n    }, {\n        key: \"containsRange\",\n        value: function containsRange(range) {\n            return this.chr === range.chr && this.start <= range.start && this.end >= range.end;\n        }\n    }]);\n\n    return GenomicInterval;\n}();\n\nvar FastaSequence = function () {\n    function FastaSequence(url) {\n        _classCallCheck(this, FastaSequence);\n\n        this.file = url;\n        this.indexed = true;\n        if (this.indexed) {\n            this.indexFile = this.file + \".fai\";\n        }\n    }\n\n    _createClass(FastaSequence, [{\n        key: \"init\",\n        value: function init() {\n\n            var self = this;\n\n            if (self.indexed) {\n\n                return new Promise(function (fulfill, reject) {\n\n                    self.getIndex().then(function (index) {\n                        var order = 0;\n                        self.chromosomes = {};\n                        self.chromosomeNames.forEach(function (chrName) {\n                            var bpLength = self.index[chrName].size;\n                            self.chromosomes[chrName] = new igv.Chromosome(chrName, order++, bpLength);\n                        });\n\n                        // Ignore index, getting chr names as a side effect.  Really bad practice\n                        fulfill();\n                    }).catch(reject);\n                });\n            } else {\n                return self.loadAll();\n            }\n        }\n    }, {\n        key: \"getSequence\",\n        value: function getSequence(chr, start, end) {\n\n            if (this.indexed) {\n                return this.getSequenceIndexed(chr, start, end);\n            } else {\n                return getSequenceNonIndexed.this(chr, start, end);\n            }\n        }\n    }, {\n        key: \"getSequenceIndexed\",\n        value: function getSequenceIndexed(chr, start, end) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var interval = self.interval;\n\n                if (interval && interval.contains(chr, start, end)) {\n\n                    fulfill(getSequenceFromInterval(interval, start, end));\n                } else {\n\n                    //console.log(\"Cache miss: \" + (interval === undefined ? \"nil\" : interval.chr + \":\" + interval.start + \"-\" + interval.end));\n\n                    // Expand query, to minimum of 100kb\n                    var qstart = start;\n                    var qend = end;\n                    if (end - start < 100000) {\n                        var w = end - start;\n                        var center = Math.round(start + w / 2);\n                        qstart = Math.max(0, center - 50000);\n                        qend = center + 50000;\n                    }\n\n                    self.readSequence(chr, qstart, qend).then(function (seqBytes) {\n                        self.interval = new GenomicInterval(chr, qstart, qend, seqBytes);\n                        fulfill(getSequenceFromInterval(self.interval, start, end));\n                    }).catch(reject);\n                }\n\n                function getSequenceFromInterval(interval, start, end) {\n                    var offset = start - interval.start;\n                    var n = end - start;\n                    var seq = interval.features ? interval.features.substr(offset, n) : null;\n                    return seq;\n                }\n            });\n        }\n    }, {\n        key: \"getSequenceNonIndexed\",\n        value: function getSequenceNonIndexed(chr, start, end) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var seq = self.sequences[chr];\n                if (seq && seq.length > end) {\n                    fulfill(seq.substring(start, end));\n                }\n            });\n        }\n    }, {\n        key: \"getIndex\",\n        value: function getIndex() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                if (self.index) {\n                    fulfill(self.index);\n                } else {\n                    _igvxhr.igvxhr.load(self.indexFile, {}).then(function (data) {\n                        var lines = data.split(\"\\n\");\n                        var len = lines.length;\n                        var lineNo = 0;\n\n                        self.chromosomeNames = []; // TODO -- eliminate this side effect !!!!\n                        self.index = {}; // TODO -- ditto\n                        while (lineNo < len) {\n\n                            var tokens = lines[lineNo++].split(\"\\t\");\n                            var nTokens = tokens.length;\n                            if (nTokens == 5) {\n                                // Parse the index line.\n                                var chr = tokens[0];\n                                var size = parseInt(tokens[1]);\n                                var position = parseInt(tokens[2]);\n                                var basesPerLine = parseInt(tokens[3]);\n                                var bytesPerLine = parseInt(tokens[4]);\n\n                                var indexEntry = {\n                                    size: size, position: position, basesPerLine: basesPerLine, bytesPerLine: bytesPerLine\n                                };\n\n                                self.chromosomeNames.push(chr);\n                                self.index[chr] = indexEntry;\n                            }\n                        }\n\n                        if (fulfill) {\n                            fulfill(self.index);\n                        }\n                    }).catch(reject);\n                }\n            });\n        }\n    }, {\n        key: \"loadAll\",\n        value: function loadAll() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                self.chromosomeNames = [];\n                self.chromosomes = {};\n                self.sequences = {};\n\n                _igvxhr.igvxhr.load(self.file, {\n                    withCredentials: self.withCredentials\n\n                }).then(function (data) {\n\n                    var lines = data.splitLines(),\n                        len = lines.length,\n                        lineNo = 0,\n                        nextLine,\n                        currentSeq = \"\",\n                        currentChr,\n                        order = 0;\n\n                    while (lineNo < len) {\n                        nextLine = lines[lineNo++].trim();\n                        if (nextLine.startsWith(\"#\") || nextLine.length === 0) {\n                            continue;\n                        } else if (nextLine.startsWith(\">\")) {\n                            if (currentSeq) {\n                                self.chromosomeNames.push(currentChr);\n                                self.sequences[currentChr] = currentSeq;\n                                self.chromosomes[currentChr] = new igv.Chromosome(currentChr, order++, currentSeq.length);\n                            }\n                            currentChr = nextLine.substr(1).split(\"\\\\s+\")[0];\n                            currentSeq = \"\";\n                        } else {\n                            currentSeq += nextLine;\n                        }\n                    }\n\n                    fulfill();\n                });\n            });\n        }\n    }, {\n        key: \"readSequence\",\n        value: function readSequence(chr, qstart, qend) {\n\n            //console.log(\"Read sequence \" + chr + \":\" + qstart + \"-\" + qend);\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                self.getIndex().then(function () {\n\n                    var idxEntry = self.index[chr];\n                    if (!idxEntry) {\n                        console.log(\"No index entry for chr: \" + chr);\n\n                        // Tag interval with null so we don't try again\n                        self.interval = new GenomicInterval(chr, qstart, qend, null);\n                        fulfill(null);\n                    } else {\n\n                        var start = Math.max(0, qstart); // qstart should never be < 0\n                        var end = Math.min(idxEntry.size, qend);\n                        var bytesPerLine = idxEntry.bytesPerLine;\n                        var basesPerLine = idxEntry.basesPerLine;\n                        var position = idxEntry.position;\n                        var nEndBytes = bytesPerLine - basesPerLine;\n\n                        var startLine = Math.floor(start / basesPerLine);\n                        var endLine = Math.floor(end / basesPerLine);\n\n                        var base0 = startLine * basesPerLine; // Base at beginning of start line\n\n                        var offset = start - base0;\n\n                        var startByte = position + startLine * bytesPerLine + offset;\n\n                        var base1 = endLine * basesPerLine;\n                        var offset1 = end - base1;\n                        var endByte = position + endLine * bytesPerLine + offset1 - 1;\n                        var byteCount = endByte - startByte + 1;\n                        if (byteCount <= 0) {\n                            fulfill(null);\n                        }\n\n                        _igvxhr.igvxhr.load(self.file, {\n                            range: { start: startByte, size: byteCount }\n                        }).then(function (allBytes) {\n\n                            var nBases,\n                                seqBytes = \"\",\n                                srcPos = 0,\n                                desPos = 0,\n                                allBytesLength = allBytes.length;\n\n                            if (offset > 0) {\n                                nBases = Math.min(end - start, basesPerLine - offset);\n                                seqBytes += allBytes.substr(srcPos, nBases);\n                                srcPos += nBases + nEndBytes;\n                                desPos += nBases;\n                            }\n\n                            while (srcPos < allBytesLength) {\n                                nBases = Math.min(basesPerLine, allBytesLength - srcPos);\n                                seqBytes += allBytes.substr(srcPos, nBases);\n                                srcPos += nBases + nEndBytes;\n                                desPos += nBases;\n                            }\n\n                            fulfill(seqBytes);\n                        }).catch(reject);\n                    }\n                }).catch(reject);\n            });\n        }\n    }]);\n\n    return FastaSequence;\n}();\n\nexports.FeatureSource = FeatureSource;\nexports.FastaSequence = FastaSequence;\nexports.BigBedFeatureSource = BigBedFeatureSource;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZmVhdHVyZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvZmVhdHVyZS5qcz83YmU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgQnJvYWQgSW5zdGl0dXRlXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAqIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG5cclxuaW1wb3J0IHtVdGlsc30gZnJvbSBcIi4vdXRpbHMuanNcIjtcclxuaW1wb3J0IHtpZ3Z4aHIsdW5iZ3pmfSBmcm9tIFwiLi9pZ3Z4aHIuanNcIjtcclxuaW1wb3J0IHtsb2FkQmFtSW5kZXh9IGZyb20gXCIuL2JhbS5qc1wiO1xyXG5pbXBvcnQge0JXU291cmNlfSBmcm9tIFwiLi9iaWd3aWcuanNcIjtcclxuXHJcbmNvbnN0IE1BWF9HWklQX0JMT0NLX1NJWkUgPSAoMSA8PCAxNik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBmZWF0dXJlIHNvdXJjZSBmb3IgXCJiZWQgbGlrZVwiIGZpbGVzICh0YWIgZGVsaW1pdGVkIGZpbGVzIHdpdGggMSBmZWF0dXJlIHBlciBsaW5lOiBiZWQsIGdmZiwgdmNmLCBldGMpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuY2xhc3MgRmVhdHVyZVNvdXJjZXtcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG5cclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuXHJcbiAgICAgICAgdGhpcy5zb3VyY2VUeXBlID0gKGNvbmZpZy5zb3VyY2VUeXBlID09PSB1bmRlZmluZWQgPyBcImZpbGVcIiA6IGNvbmZpZy5zb3VyY2VUeXBlKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZy5zb3VyY2VUeXBlID09PSBcImdhNGdoXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWFkZXIgPSBuZXcgaWd2LkdhNGdoVmFyaWFudFJlYWRlcihjb25maWcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnNvdXJjZVR5cGUgPT09IFwiaW1tdmFyXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWFkZXIgPSBuZXcgaWd2LkltbVZhclJlYWRlcihjb25maWcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnR5cGUgPT09IFwiZXF0bFwiKSB7XHJcbiAgICAgICAgICAgIGlmIChjb25maWcuc291cmNlVHlwZSA9PT0gXCJndGV4LXdzXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVyID0gbmV3IGlndi5HdGV4UmVhZGVyKGNvbmZpZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRlciA9IG5ldyBpZ3YuR3RleEZpbGVSZWFkZXIoY29uZmlnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnNvdXJjZVR5cGUgPT09IFwiYmlncXVlcnlcIikge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWRlciA9IG5ldyBpZ3YuQmlnUXVlcnlGZWF0dXJlUmVhZGVyKGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEZWZhdWx0IGZvciBhbGwgc29ydHMgb2YgYXNjaWkgdGFiLWRlbGltaXRlZCBmaWxlIGZvcm10c1xyXG4gICAgICAgICAgICB0aGlzLnJlYWRlciA9IG5ldyBGZWF0dXJlRmlsZVJlYWRlcihjb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZpc2liaWxpdHlXaW5kb3cgPSBjb25maWcudmlzaWJpbGl0eVdpbmRvdztcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGdldEZpbGVIZWFkZXIoKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgbWF4Um93cyA9IHRoaXMuY29uZmlnLm1heFJvd3MgfHwgNTAwO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGYuaGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHNlbGYuaGVhZGVyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZi5yZWFkZXIucmVhZEhlYWRlciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVhZGVyLnJlYWRIZWFkZXIoKS50aGVuKGZ1bmN0aW9uIChoZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pc19pbmRleGVkPXRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vbi1pbmRleGVkIHJlYWRlcnMgd2lsbCByZXR1cm4gZmVhdHVyZXMgYXMgYSBzaWRlIGVmZmVjdC4gIFRoaXMgaXMgYW4gaW1wb3J0YW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB1bmZvcnR1bmF0ZSwgcGVyZm9ybWFuY2UgaGFja1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBoZWFkZXIuZmVhdHVyZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZ3RmXCIgPT09IHNlbGYuY29uZmlnLmZvcm1hdCB8fCBcImdmZjNcIiA9PT0gc2VsZi5jb25maWcuZm9ybWF0IHx8IFwiZ2ZmXCIgPT09IHNlbGYuY29uZmlnLmZvcm1hdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcyA9IChuZXcgaWd2LkdGRkhlbHBlcihzZWxmLmNvbmZpZy5mb3JtYXQpKS5jb21iaW5lRmVhdHVyZXMoZmVhdHVyZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIG92ZXJsYXBwaW5nIGZlYXR1cmVzIHRvIHJvd3NcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja0ZlYXR1cmVzKGZlYXR1cmVzLCBtYXhSb3dzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZlYXR1cmVDYWNoZSA9IG5ldyBGZWF0dXJlQ2FjaGUoZmVhdHVyZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0cmFjayBpcyBtYXJrZWQgXCJzZWFyY2hhYmxlXCI8IGNhY2hlIGZlYXR1cmVzIGJ5IG5hbWUgLS0gdXNlIHRoaXMgd2l0aCBjYXV0aW9uLCBtZW1vcnkgaW50ZW5zaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnNlYXJjaGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRGZWF0dXJlc1RvREIoZmVhdHVyZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlciAmJiBoZWFkZXIuZm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5mb3JtYXQgPSBoZWFkZXIuZm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGhlYWRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgYWRkRmVhdHVyZXNUb0RCKGZlYXR1cmVMaXN0KSB7XHJcbiAgICAgICAgZmVhdHVyZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gICAgICAgICAgICBpZiAoZmVhdHVyZS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZ3YuYnJvd3Nlci5mZWF0dXJlREJbZmVhdHVyZS5uYW1lLnRvVXBwZXJDYXNlKCldID0gZmVhdHVyZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RmVhdHVyZXMoY2hyLHN0YXJ0LGVuZCxmb3JjZSxkYXRhKXtcclxuICAgICAgXHJcbiAgICAgICAgLy9ubyBuZWVkIHRvIGdldCBoZWFkZXJcclxuICAgICAgICBpZiAodGhpcy5pc19pbmRleGVkKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEZlYXR1cmVzKGNocixzdGFydCxlbmQsZm9yY2UsZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vZ2V0IGhlYWRlcnMvaW5kZXggdGhlbiBnZXQgZmVhdHVyZXNcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGZ1bGZpbGwscmVqZWN0KXtcclxuICAgICAgICAgICAgc2VsZi5nZXRGaWxlSGVhZGVyKCkudGhlbihmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fZ2V0RmVhdHVyZXMoY2hyLHN0YXJ0LGVuZCxmb3JjZSxkYXRhKS50aGVuKGZ1bmN0aW9uKGZlYXR1cmVzKXtcclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGZlYXR1cmVzKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXF1aXJlZCBmdW5jdGlvbiBmbyBhbGwgZGF0YSBzb3VyY2Ugb2JqZWN0cy4gIEZldGNoZXMgZmVhdHVyZXMgZm9yIHRoZVxyXG4gICAgICogcmFuZ2UgcmVxdWVzdGVkIGFuZCBwYXNzZXMgdGhlbSBvbiB0byB0aGUgc3VjY2VzcyBmdW5jdGlvbi4gIFVzdWFsbHkgdGhpcyBpc1xyXG4gICAgICogYSBmdW5jdGlvbiB0aGF0IHJlbmRlcnMgdGhlIGZlYXR1cmVzIG9uIHRoZSBjYW52YXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2hyXHJcbiAgICAgKiBAcGFyYW0gYnBTdGFydFxyXG4gICAgICogQHBhcmFtIGJwRW5kXHJcbiAgICAgKi9cclxuXHJcbiAgICBfZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCxmb3JjZSxkYXRhKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHNlbGYudGltZT1EYXRlLm5vdygpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZ2Vub21pY0ludGVydmFsID0gbmV3IEdlbm9taWNJbnRlcnZhbChjaHIsIGJwU3RhcnQsIGJwRW5kKSxcclxuICAgICAgICAgICAgICAgIGZlYXR1cmVDYWNoZSA9IHNlbGYuZmVhdHVyZUNhY2hlLFxyXG4gICAgICAgICAgICAgICAgbWF4Um93cyA9IHNlbGYuY29uZmlnLm1heFJvd3MgfHwgNTAwO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGZlYXR1cmVDYWNoZSAmJiAoZmVhdHVyZUNhY2hlLnJhbmdlID09PSB1bmRlZmluZWQgfHwgZmVhdHVyZUNhY2hlLnJhbmdlLmNvbnRhaW5zUmFuZ2UoZ2Vub21pY0ludGVydmFsKSkpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5mZWF0dXJlQ2FjaGUucXVlcnlGZWF0dXJlcyhjaHIsIGJwU3RhcnQsIGJwRW5kKSk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyAtLSByZXVzZSBjYWNoZWQgZmVhdHVyZXMgdGhhdCBvdmVyZWxhcCBuZXcgcmVnaW9uXHJcblxyXG4gICAgICAgICAgICAgICAvKiBpZiAoc2VsZi5zb3VyY2VUeXBlID09PSAnZmlsZScgJiYgKHNlbGYudmlzaWJpbGl0eVdpbmRvdyA9PT0gdW5kZWZpbmVkIHx8IHNlbGYudmlzaWJpbGl0eVdpbmRvdyA8PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBnZW5vbWljIGludGVydmFsIHRvIGdyYWIgZW50aXJlIGNocm9tb3NvbWVcclxuICAgICAgICAgICAgICAgICAgICBnZW5vbWljSW50ZXJ2YWwuc3RhcnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaHJvbW9zb21lID1jaHI7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2Vub21pY0ludGVydmFsLmVuZCA9IChjaHJvbW9zb21lID09PSB1bmRlZmluZWQgPyAgTnVtYmVyLk1BWF9WQUxVRSA6IGNocm9tb3NvbWUuYnBMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgc2VsZi5yZXRyaWV2ZUZlYXR1cmVzKGNociwgZ2Vub21pY0ludGVydmFsLnN0YXJ0LCBnZW5vbWljSW50ZXJ2YWwuZW5kLGZvcmNlLGRhdGEpLnRoZW4oXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChmZWF0dXJlTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZUxpc3QgJiYgdHlwZW9mIGZlYXR1cmVMaXN0LmZvckVhY2ggPT09ICdmdW5jdGlvbicpIHsgIC8vIEhhdmUgcmVzdWx0IEFORCBpdHMgYW4gYXJyYXkgdHlwZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0luZGV4ZWQgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVhZGVyLmluZGV4ZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5zb3VyY2VUeXBlID09PSBcImdhNGdoXCIgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5zb3VyY2VUeXBlID09PSBcImltbXZhclwiIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcuc291cmNlVHlwZSA9PT0gXCJndGV4XCIgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5zb3VyY2VUeXBlID09PSBcImJpZ3F1ZXJ5XCJ8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLnNvdXJjZVR5cGUgPT09IFwiY3VzdG9tXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyAtLSBDT01CSU5FIEdGRiBGRUFUVVJFUyBIRVJFXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZihzZWxmLmlzR0ZGKSBmZWF0dXJlTGlzdCA9IGNvbWJpbmVGZWF0dXJlcyhmZWF0dXJlTGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJndGZcIiA9PT0gc2VsZi5jb25maWcuZm9ybWF0IHx8IFwiZ2ZmM1wiID09PSBzZWxmLmNvbmZpZy5mb3JtYXQgfHwgXCJnZmZcIiA9PT0gc2VsZi5jb25maWcuZm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUxpc3QgPSAobmV3IGlndi5HRkZIZWxwZXIoc2VsZi5jb25maWcuZm9ybWF0KSkuY29tYmluZUZlYXR1cmVzKGZlYXR1cmVMaXN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZlYXR1cmVDYWNoZSA9IGlzSW5kZXhlZCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEZlYXR1cmVDYWNoZShmZWF0dXJlTGlzdCwgZ2Vub21pY0ludGVydmFsKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEZlYXR1cmVDYWNoZShmZWF0dXJlTGlzdCk7ICAgLy8gTm90ZSAtIHJlcGxhY2luZyBwcmV2aW91cyBjYWNoZSB3aXRoIG5ldyBvbmVcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIG92ZXJsYXBwaW5nIGZlYXR1cmVzIHRvIHJvd3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZlYXR1cmVTb3VyY2UucGFja0ZlYXR1cmVzKGZlYXR1cmVMaXN0LCBtYXhSb3dzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0cmFjayBpcyBtYXJrZWQgXCJzZWFyY2hhYmxlXCI8IGNhY2hlIGZlYXR1cmVzIGJ5IG5hbWUgLS0gdXNlIHRoaXMgd2l0aCBjYXV0aW9uLCBtZW1vcnkgaW50ZW5zaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc2VhcmNoYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZlYXR1cmVzVG9EQihmZWF0dXJlTGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluYWxseSBwYXNzIGZlYXR1cmVzIGZvciBxdWVyeSBpbnRlcnZhbCB0byBjb250aW51YXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5mZWF0dXJlQ2FjaGUucXVlcnlGZWF0dXJlcyhjaHIsIGJwU3RhcnQsIGJwRW5kKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXRyaWV2ZUZlYXR1cmVzKGNocixzdGFydCxlbmQpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRlci5yZWFkRmVhdHVyZXMoY2hyLHN0YXJ0LGVuZCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHN0YXRpYyBwYWNrRmVhdHVyZXMoZmVhdHVyZXMsIG1heFJvd3MpIHtcclxuXHJcbiAgICAgICAgaWYgKGZlYXR1cmVzID09IG51bGwgfHwgZmVhdHVyZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNlZ3JlZ2F0ZSBieSBjaHJvbW9zb21lXHJcblxyXG4gICAgICAgIHZhciBjaHJGZWF0dXJlTWFwID0ge30sXHJcbiAgICAgICAgICAgIGNocnMgPSBbXTtcclxuICAgICAgICBmZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2hyID0gZmVhdHVyZS5jaHIsXHJcbiAgICAgICAgICAgICAgICBmbGlzdCA9IGNockZlYXR1cmVNYXBbY2hyXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZmxpc3QpIHtcclxuICAgICAgICAgICAgICAgIGZsaXN0ID0gW107XHJcbiAgICAgICAgICAgICAgICBjaHJGZWF0dXJlTWFwW2Nocl0gPSBmbGlzdDtcclxuICAgICAgICAgICAgICAgIGNocnMucHVzaChjaHIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmbGlzdC5wdXNoKGZlYXR1cmUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBMb29wIHRocm91Z2ggY2hyb3NvbW9zb21lcyBhbmQgcGFjayBmZWF0dXJlcztcclxuXHJcbiAgICAgICAgY2hycy5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHtcclxuXHJcbiAgICAgICAgICAgIHBhY2soY2hyRmVhdHVyZU1hcFtjaHJdLCBtYXhSb3dzKTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIC8vIEFzc2lnbnMgYSByb3cgIyB0byBlYWNoIGZlYXR1cmUuICBJZiB0aGUgZmVhdHVyZSBkb2VzIG5vdCBmaXQgaW4gYW55IHJvdyBhbmQgI3Jvd3MgPT0gbWF4Um93cyBub1xyXG4gICAgICAgIC8vIHJvdyBudW1iZXIgaXMgYXNzaWduZWQuXHJcbiAgICAgICAgZnVuY3Rpb24gcGFjayhmZWF0dXJlTGlzdCwgbWF4Um93cykge1xyXG5cclxuICAgICAgICAgICAgdmFyIHJvd3MgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGZlYXR1cmVMaXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLnN0YXJ0IC0gYi5zdGFydDtcclxuICAgICAgICAgICAgfSlcclxuXHJcblxyXG4gICAgICAgICAgICByb3dzLnB1c2goLTEwMDApO1xyXG4gICAgICAgICAgICBmZWF0dXJlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgICAgICAgICAgcixcclxuICAgICAgICAgICAgICAgICAgICBsZW4gPSBNYXRoLm1pbihyb3dzLmxlbmd0aCwgbWF4Um93cyksXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBmZWF0dXJlLnN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAociA9IDA7IHIgPCBsZW47IHIrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA+PSByb3dzW3JdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUucm93ID0gcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93c1tyXSA9IGZlYXR1cmUuZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmVhdHVyZS5yb3cgPSByO1xyXG4gICAgICAgICAgICAgICAgcm93c1tyXSA9IGZlYXR1cmUuZW5kO1xyXG5cclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIEJpZ0JlZEZlYXR1cmVTb3VyY2UgZXh0ZW5kcyBGZWF0dXJlU291cmNle1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnLGRlY29kZV9mdW5jdGlvbil7XHJcblx0XHRjb25maWcuc291cmNlVHlwZT1cImd0ZXhcIjtcclxuXHRcdHN1cGVyKGNvbmZpZyk7XHJcblx0XHR0aGlzLmhlYWRlcj10cnVlO1xyXG5cdFx0dGhpcy5mZWF0dXJlX3NvdXJjZT1uZXcgQldTb3VyY2UoY29uZmlnLGRlY29kZV9mdW5jdGlvbik7XHJcblx0fVxyXG5cclxuXHRyZXRyaWV2ZUZlYXR1cmVzKGNocixicFN0YXJ0LGJwRW5kLGZvcmNlLGRhdGEpe1xyXG5cdFx0cmV0dXJuIHRoaXMuZmVhdHVyZV9zb3VyY2UuZ2V0RmVhdHVyZXMoY2hyLGJwU3RhcnQsYnBFbmQsZmFsc2UsZGF0YSk7ICAgICBcdFxyXG5cdH1cclxufVxyXG5cclxuLy8qKioqKioqKmpzL0ZlYXR1cmVGaWxlUmVhZGVyLmpzKioqKipcclxuXHJcblxyXG5cclxuY29uc3QgRl9NQVhfR1pJUF9CTE9DS19TSVpFID0gKDEgPDwgMTYpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZGVyIGZvciBcImJlZCBsaWtlXCIgZmlsZXMgKHRhYiBkZWxpbWl0ZWQgZmlsZXMgd2l0aCAxIGZlYXR1cmUgcGVyIGxpbmU6IGJlZCwgZ2ZmLCB2Y2YsIGV0YylcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG5jbGFzcyBGZWF0dXJlRmlsZVJlYWRlcntcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG5cclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZy5sb2NhbEZpbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2NhbEZpbGUgPSBjb25maWcubG9jYWxGaWxlO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGVuYW1lID0gY29uZmlnLmxvY2FsRmlsZS5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51cmwgPSBjb25maWcudXJsO1xyXG4gICAgICAgICAgICB0aGlzLmluZGV4VVJMID0gY29uZmlnLmluZGV4VVJMO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRVUkwgPSBjb25maWcuaGVhZFVSTCB8fCB0aGlzLmZpbGVuYW1lO1xyXG5cclxuICAgICAgICAgICAgdmFyIHVyaVBhcnRzID0gVXRpbHMucGFyc2VVcmkoY29uZmlnLnVybCk7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZW5hbWUgPSB1cmlQYXJ0cy5maWxlO1xyXG4gICAgICAgICAgICB0aGlzLnBhdGggPSB1cmlQYXJ0cy5wYXRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5mb3JtYXQgPSBjb25maWcuZm9ybWF0O1xyXG5cclxuICAgICAgICB0aGlzLnBhcnNlciA9IHRoaXMuZ2V0UGFyc2VyKHRoaXMuZm9ybWF0LCBjb25maWcuZGVjb2RlKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIGdldFBhcnNlcihmb3JtYXQsIGRlY29kZSkge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ2Y2ZcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmNmUGFyc2VyKCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzZWdcIiA6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNlZ1BhcnNlcigpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGZWF0dXJlUGFyc2VyKGZvcm1hdCwgZGVjb2RlLCB0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBzZWcgZmlsZXMgZG9uJ3QgaGF2ZSBhbiBpbmRleFxyXG4gICAgaXNJbmRleGFibGUoKSB7XHJcbiAgICAgICAgdmFyIGNvbmZpZ0luZGV4VVJMID0gdGhpcy5jb25maWcuaW5kZXhVUkwsXHJcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIGNvbmZpZ0luZGV4ZWQgPSB0aGlzLmNvbmZpZy5pbmRleGVkO1xyXG5cclxuICAgICAgICByZXR1cm4gY29uZmlnSW5kZXhVUkwgfHwgKHR5cGUgIT0gXCJ3aWdcIiAmJiBjb25maWdJbmRleGVkICE9IGZhbHNlKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgYXN5bmMgbG9hZGVkIGluZGV4XHJcbiAgICAgKi9cclxuICAgIGxvYWRJbmRleCgpIHtcclxuICAgICAgICB2YXIgaWR4RmlsZSA9IHRoaXMuaW5kZXhVUkw7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsZW5hbWUuZW5kc1dpdGgoXCIuZ3pcIikpIHtcclxuICAgICAgICAgICAgaWYgKCFpZHhGaWxlKSBpZHhGaWxlID0gdGhpcy51cmwgKyBcIi50YmlcIjtcclxuICAgICAgICAgICAgcmV0dXJuIGxvYWRCYW1JbmRleChpZHhGaWxlLCB0aGlzLmNvbmZpZywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWlkeEZpbGUpIGlkeEZpbGUgPSB0aGlzLnVybCArIFwiLmlkeFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gbG9hZFRyaWJibGVJbmRleChpZHhGaWxlLCB0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxvYWRGZWF0dXJlc05vSW5kZXgoKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIHBhcnNlciA9IHNlbGYucGFyc2VyLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBzZWxmLmNvbmZpZy5oZWFkZXJzLCAgICAgICAgICAgLy8gaHR0cCBoZWFkZXJzLCBub3QgZmlsZSBoZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHNlbGYuY29uZmlnLndpdGhDcmVkZW50aWFsc1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmxvY2FsRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRTdHJpbmdGcm9tRmlsZShzZWxmLmxvY2FsRmlsZSwgb3B0aW9ucykudGhlbihwYXJzZURhdGEpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZFN0cmluZyhzZWxmLnVybCwgb3B0aW9ucykudGhlbihwYXJzZURhdGEpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZURhdGEoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIgPSBwYXJzZXIucGFyc2VIZWFkZXIoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oZWFkZXIgaW5zdGFuY2VvZiBTdHJpbmcgJiYgc2VsZi5oZWFkZXIuc3RhcnRzV2l0aChcIiMjZ2ZmLXZlcnNpb24gM1wiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZm9ybWF0ID0gJ2dmZjMnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChwYXJzZXIucGFyc2VGZWF0dXJlcyhkYXRhKSk7ICAgLy8gPD0gUEFSU0lORyBET05FIEhFUkVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgbG9hZEZlYXR1cmVzV2l0aEluZGV4KGNociwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBibG9ja3MsXHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlbGYuaW5kZXgsXHJcbiAgICAgICAgICAgICAgICB0YWJpeCA9IGluZGV4ICYmIGluZGV4LnRhYml4LFxyXG4gICAgICAgICAgICAgICAgcmVmSWQgPSB0YWJpeCA/IGluZGV4LnNlcXVlbmNlSW5kZXhNYXBbY2hyXSA6IGNocixcclxuICAgICAgICAgICAgICAgIHByb21pc2VzID0gW107XHJcblxyXG4gICAgICAgICAgICBibG9ja3MgPSBpbmRleC5ibG9ja3NGb3JSYW5nZShyZWZJZCwgc3RhcnQsIGVuZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWJsb2NrcyB8fCBibG9ja3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKG51bGwpOyAgICAgICAvLyBUT0RPIC0tIGlzIHRoaXMgY29ycmVjdD8gIFNob3VsZCBpdCByZXR1cm4gYW4gZW1wdHkgYXJyYXk/XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0UG9zID0gYmxvY2subWludi5ibG9jayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gYmxvY2subWludi5vZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3MgPSBibG9jay5tYXh2LmJsb2NrICsgKGluZGV4LnRhYml4ID8gRl9NQVhfR1pJUF9CTE9DS19TSVpFIDogMCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHNlbGYuY29uZmlnLmhlYWRlcnMsICAgICAgICAgICAvLyBodHRwIGhlYWRlcnMsIG5vdCBmaWxlIGhlYWRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7c3RhcnQ6IHN0YXJ0UG9zLCBzaXplOiBlbmRQb3MgLSBzdGFydFBvcyArIDF9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogc2VsZi5jb25maWcud2l0aENyZWRlbnRpYWxzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmZsYXRlZCwgc2xpY2VkRGF0YTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXgudGFiaXgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGF0ZWQgPSBpZ3Z4aHIuYXJyYXlCdWZmZXJUb1N0cmluZyh1bmJnemYoZGF0YSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gZGVjb21wcmVzcyBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZsYXRlZCA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2VkRGF0YSA9IHN0YXJ0T2Zmc2V0ID8gaW5mbGF0ZWQuc2xpY2Uoc3RhcnRPZmZzZXQpIDogaW5mbGF0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IHNlbGYucGFyc2VyLnBhcnNlRmVhdHVyZXMoc2xpY2VkRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzeW5jIGxvYWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubG9jYWxGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZFN0cmluZ0Zyb21GaWxlKHNlbGYubG9jYWxGaWxlLCBvcHRpb25zKS50aGVuKHN1Y2Nlc3MpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXgudGFiaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZEFycmF5QnVmZmVyKHNlbGYudXJsLCBvcHRpb25zKS50aGVuKHN1Y2Nlc3MpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZFN0cmluZyhzZWxmLnVybCwgb3B0aW9ucykudGhlbihzdWNjZXNzKS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoZmVhdHVyZUFycmF5cykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgYWxsRmVhdHVyZXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlQXJyYXlzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcyA9IGZlYXR1cmVBcnJheXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMgPSBmZWF0dXJlQXJyYXlzWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGZlYXR1cmVBcnJheXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzID0gYWxsRmVhdHVyZXMuY29uY2F0KGZlYXR1cmVBcnJheXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChhbGxGZWF0dXJlcylcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGdldEluZGV4KCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgaXNJbmRlZWRJbmRleGlibGUgPSB0aGlzLmlzSW5kZXhhYmxlKCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmluZGV4ZWQgPT09IHVuZGVmaW5lZCAmJiBpc0luZGVlZEluZGV4aWJsZSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5sb2FkSW5kZXgoKS50aGVuKGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLmluZGV4KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLmluZGV4KTsgICAvLyBJcyBlaXRoZXIgYWxyZWFkeSBsb2FkZWQsIG9yIHRoZXJlIGlzbid0IG9uZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJlYWRIZWFkZXIoKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZi5oZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5oZWFkZXIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3JjZSBhIGxvYWQgb2YgdGhlIGluZGV4IGZpcnN0XHJcblxyXG4gICAgICAgICAgICAgICBzZWxmLiBnZXRJbmRleCgpLnRoZW4oZnVuY3Rpb24gKGluZGV4KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2FkIHRoZSBmaWxlIGhlYWRlciAobm90IEhUVFAgaGVhZGVyKSBmb3IgYW4gaW5kZXhlZCBmaWxlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIC0tIG5vdGUgdGhpcyB3aWxsIGZhaWwgaWYgdGhlIGZpbGUgaGVhZGVyIGlzID4gNjVrYiBpbiBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHNlbGYuY29uZmlnLmhlYWRlcnMsICAgICAgICAgICAvLyBodHRwIGhlYWRlcnMsIG5vdCBmaWxlIGhlYWRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnejogaW5kZXgudGFiaXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtzdGFydDogMCwgc2l6ZTogNjUwMDB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogc2VsZi5jb25maWcud2l0aENyZWRlbnRpYWxzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIgPSBzZWxmLnBhcnNlci5wYXJzZUhlYWRlcihkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHNlbGYuaGVhZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5sb2NhbEZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlndnhoci5sb2FkU3RyaW5nRnJvbUZpbGUoc2VsZi5sb2NhbEZpbGUsIG9wdGlvbnMpLnRoZW4oc3VjY2Vzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZFN0cmluZyhzZWxmLnVybCwgb3B0aW9ucykudGhlbihzdWNjZXNzKS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvYWRGZWF0dXJlc05vSW5kZXgodW5kZWZpbmVkKS50aGVuKGZ1bmN0aW9uIChmZWF0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IHNlbGYuaGVhZGVyIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyLmZlYXR1cmVzID0gZmVhdHVyZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGhlYWRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZ1bGZpbGxcclxuICAgICAqIEBwYXJhbSByYW5nZSAtLSBnZW5vbWljIHJhbmdlIHRvIGxvYWQuICBGb3IgdXNlIHdpdGggaW5kZXhlZCBzb3VyY2UgKG9wdGlvbmFsKVxyXG4gICAgICovXHJcbiAgICByZWFkRmVhdHVyZXMoY2hyLCBzdGFydCwgZW5kKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmxvYWRGZWF0dXJlc1dpdGhJbmRleChjaHIsIHN0YXJ0LCBlbmQpLnRoZW4ocGFja0ZlYXR1cmVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlbGYubG9hZEZlYXR1cmVzTm9JbmRleCgpLnRoZW4ocGFja0ZlYXR1cmVzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gcGFja0ZlYXR1cmVzKGZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHBhY2tcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoZmVhdHVyZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcblxyXG4vLyoqKmpzL2ZlYXR1cmUvRmVhdHVyZVBhcnNlcnMuanMqKioqKioqKioqKioqKlxyXG5cclxuXHJcbmNvbnN0IG1heEZlYXR1cmVDb3VudCA9IE51bWJlci5NQVhfVkFMVUU7ICAgIC8vIEZvciBmdXR1cmUgdXNlLCAgY29udHJvbHMgZG93bnNhbXBsaW5nXHJcblxyXG5jb25zdCBnZmZOYW1lRmllbGRzID0gW1wiTmFtZVwiLCBcImdlbmVfbmFtZVwiLCBcImdlbmVcIiwgXCJnZW5lX2lkXCIsIFwiYWxpYXNcIiwgXCJsb2N1c1wiXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgZmFjdG9yeSBmdW5jdGlvbi4gIFJldHVybiBhIHBhcnNlciBmb3IgdGhlIGdpdmVuIGZpbGUgZm9ybWF0LlxyXG4gICAgICovXHJcbmNsYXNzIEZlYXR1cmVQYXJzZXJ7XHJcbiAgICBjb25zdHJ1Y3Rvcihmb3JtYXQsIGRlY29kZSwgY29uZmlnKSB7XHJcblxyXG4gICAgICAgIHZhciBjdXN0b21Gb3JtYXQ7XHJcblxyXG4gICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xyXG4gICAgICAgIHRoaXMubmFtZUZpZWxkID0gY29uZmlnID8gY29uZmlnLm5hbWVGaWVsZCA6IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnNraXBSb3dzID0gMDsgICAvLyBUaGUgbnVtYmVyIG9mIGZpeGVkIGhlYWRlciByb3dzIHRvIHNraXAuICBPdmVycmlkZSBmb3Igc3BlY2lmaWMgdHlwZXMgYXMgbmVlZGVkXHJcblxyXG4gICAgICAgIGlmIChkZWNvZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWNvZGUgPSBkZWNvZGU7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcclxuICAgICAgICAgICAgY2FzZSBcIm5hcnJvd3BlYWtcIjpcclxuICAgICAgICAgICAgY2FzZSBcImJyb2FkcGVha1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwicGVha3NcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVQZWFrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSAvXFxzKy87XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImJlZGdyYXBoXCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVjb2RlQmVkR3JhcGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IC9cXHMrLztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwid2lnXCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVjb2RlV2lnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSAvXFxzKy87XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImdmZjNcIiA6XHJcbiAgICAgICAgICAgIGNhc2UgXCJnZmZcIiA6XHJcbiAgICAgICAgICAgIGNhc2UgXCJndGZcIiA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVjb2RlR0ZGO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSBcIlxcdFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJhbmV1XCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVjb2RlQW5ldTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVyID0gXCJcXHRcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZnVzaW9uanVuY3NwYW5cIjpcclxuICAgICAgICAgICAgICAgIC8vIGJoYWFzLCBuZWVkZWQgZm9yIEZ1c2lvbkluc3BlY3RvciB2aWV3XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVjb2RlRnVzaW9uSnVuY1NwYW47XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IC9cXHMrLztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ3RleGd3YXNcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuc2tpcFJvd3MgPSAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGUgPSB0aGlzLmRlY29kZUd0ZXhHV0FTO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSBcIlxcdFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyZWZmbGF0XCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVjb2RlUmVmZmxhdDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVyID0gXCJcXHRcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG5cclxuICAgICAgICAgICAgICAgLyogY3VzdG9tRm9ybWF0ID0gaWd2LmJyb3dzZXIuZ2V0Rm9ybWF0KGZvcm1hdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tRm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IGRlY29kZUN1c3RvbTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdCA9IGN1c3RvbUZvcm1hdDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IGN1c3RvbUZvcm1hdC5kZWxpbWl0ZXIgfHwgXCJcXHRcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IEZlYXR1cmVQYXJzZXIuZGVjb2RlQmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVyID0gL1xccysvO1xyXG4gICAgICAgICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHBhcnNlSGVhZGVyKGRhdGEpIHtcclxuXHJcbiAgICAgICAgdmFyIGxpbmVzID0gZGF0YS5zcGxpdChcIlxcblwiKSxcclxuICAgICAgICAgICAgbGVuID0gbGluZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICBsaW5lLFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBoZWFkZXI7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBsaW5lID0gbGluZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCJ0cmFja1wiKSB8fCBsaW5lLnN0YXJ0c1dpdGgoXCIjXCIpIHx8IGxpbmUuc3RhcnRzV2l0aChcImJyb3dzZXJcIikpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCJ0cmFja1wiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlciA9IHRoaXMucGFyc2VUcmFja0xpbmUobGluZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCIjI2dmZi12ZXJzaW9uIDNcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdCA9IFwiZ2ZmM1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVyKSBoZWFkZXIgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJbXCJmb3JtYXRcIl0gPSBcImdmZjNcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhlYWRlcj17fTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoZWFkZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIHBhcnNlRmVhdHVyZXMoZGF0YSkge1xyXG5cclxuICAgICAgICBpZiAoIWRhdGEpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICB2YXIgd2lnLFxyXG4gICAgICAgICAgICBmZWF0dXJlLFxyXG4gICAgICAgICAgICBsaW5lcyA9IGRhdGEuc3BsaXQoXCJcXG5cIiksXHJcbiAgICAgICAgICAgIGxlbiA9IGxpbmVzLmxlbmd0aCxcclxuICAgICAgICAgICAgdG9rZW5zLFxyXG4gICAgICAgICAgICBhbGxGZWF0dXJlcyA9IFtdLFxyXG4gICAgICAgICAgICBsaW5lLFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBjbnQgPSAwLFxyXG4gICAgICAgICAgICBqLFxyXG4gICAgICAgICAgICBkZWNvZGUgPSB0aGlzLmRlY29kZSxcclxuICAgICAgICAgICAgZm9ybWF0ID0gdGhpcy5mb3JtYXQsXHJcbiAgICAgICAgICAgIGRlbGltaXRlciA9IHRoaXMuZGVsaW1pdGVyIHx8IFwiXFx0XCI7XHJcblxyXG5cclxuICAgICAgICBmb3IgKGkgPSB0aGlzLnNraXBSb3dzOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgbGluZSA9IGxpbmVzW2ldO1xyXG4gICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKFwidHJhY2tcIikgfHwgbGluZS5zdGFydHNXaXRoKFwiI1wiKSB8fCBsaW5lLnN0YXJ0c1dpdGgoXCJicm93c2VyXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwid2lnXCIgJiYgbGluZS5zdGFydHNXaXRoKFwiZml4ZWRTdGVwXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB3aWcgPSB0aGlzLnBhcnNlRml4ZWRTdGVwKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcIndpZ1wiICYmIGxpbmUuc3RhcnRzV2l0aChcInZhcmlhYmxlU3RlcFwiKSkge1xyXG4gICAgICAgICAgICAgICAgd2lnID0gdGhpcy5wYXJzZVZhcmlhYmxlU3RlcChsaW5lKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0b2tlbnMgPSBsaW5lc1tpXS5zcGxpdChkZWxpbWl0ZXIpO1xyXG4gICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA8IDEpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgZmVhdHVyZSA9IHRoaXMuZGVjb2RlKHRva2Vucywgd2lnKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmZWF0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxsRmVhdHVyZXMubGVuZ3RoIDwgbWF4RmVhdHVyZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMucHVzaChmZWF0dXJlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2Vydm9pciBzYW1wbGluZywgIGNvbmRpdGlvbmFsbHkgcmVwbGFjZSBleGlzdGluZyBmZWF0dXJlIHdpdGggbmV3IG9uZS5cclxuICAgICAgICAgICAgICAgICAgICBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY250KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IG1heEZlYXR1cmVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxGZWF0dXJlc1tqXSA9IGZlYXR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY250Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhbGxGZWF0dXJlcztcclxuICAgIH07XHJcblxyXG5cclxuICAgIHN0YXRpYyBwYXJzZUZpeGVkU3RlcChsaW5lKSB7XHJcblxyXG4gICAgICAgIHZhciB0b2tlbnMgPSBsaW5lLnNwbGl0KC9cXHMrLyksXHJcbiAgICAgICAgICAgIGNjID0gdG9rZW5zWzFdLnNwbGl0KFwiPVwiKVsxXSxcclxuICAgICAgICAgICAgc3MgPSBwYXJzZUludCh0b2tlbnNbMl0uc3BsaXQoXCI9XCIpWzFdLCAxMCksXHJcbiAgICAgICAgICAgIHN0ZXAgPSBwYXJzZUludCh0b2tlbnNbM10uc3BsaXQoXCI9XCIpWzFdLCAxMCksXHJcbiAgICAgICAgICAgIHNwYW4gPSAodG9rZW5zLmxlbmd0aCA+IDQpID8gcGFyc2VJbnQodG9rZW5zWzRdLnNwbGl0KFwiPVwiKVsxXSwgMTApIDogMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtmb3JtYXQ6IFwiZml4ZWRTdGVwXCIsIGNocm9tOiBjYywgc3RhcnQ6IHNzLCBzdGVwOiBzdGVwLCBzcGFuOiBzcGFuLCBpbmRleDogMH07XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBwYXJzZVZhcmlhYmxlU3RlcChsaW5lKSB7XHJcblxyXG4gICAgICAgIHZhciB0b2tlbnMgPSBsaW5lLnNwbGl0KC9cXHMrLyksXHJcbiAgICAgICAgICAgIGNjID0gdG9rZW5zWzFdLnNwbGl0KFwiPVwiKVsxXSxcclxuICAgICAgICAgICAgc3BhbiA9IHRva2Vucy5sZW5ndGggPiAyID8gcGFyc2VJbnQodG9rZW5zWzJdLnNwbGl0KFwiPVwiKVsxXSwgMTApIDogMTtcclxuICAgICAgICByZXR1cm4ge2Zvcm1hdDogXCJ2YXJpYWJsZVN0ZXBcIiwgY2hyb206IGNjLCBzcGFuOiBzcGFufVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgcGFyc2VUcmFja0xpbmUobGluZSkge1xyXG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge30sXHJcbiAgICAgICAgICAgIHRva2VucyA9IGxpbmUuc3BsaXQoLyg/OlwiKShbXlwiXSspKD86XCIpfChbXlxcc1wiXSspKD89XFxzK3wkKS9nKSxcclxuICAgICAgICAgICAgdG1wID0gW10sXHJcbiAgICAgICAgICAgIGksIHRrLCBjdXJyO1xyXG5cclxuICAgICAgICAvLyBDbGVhbiB1cCB0b2tlbnMgYXJyYXlcclxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghdG9rZW5zW2ldIHx8IHRva2Vuc1tpXS50cmltKCkubGVuZ3RoID09PSAwKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIHRrID0gdG9rZW5zW2ldLnRyaW0oKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0ay5lbmRzV2l0aChcIj1cIikgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyID0gdGs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3Vycikge1xyXG4gICAgICAgICAgICAgICAgdG1wLnB1c2goY3VyciArIHRrKTtcclxuICAgICAgICAgICAgICAgIGN1cnIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0bXAucHVzaCh0ayk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdG1wLmZvckVhY2goZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICBpZiAoIXN0cikgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIga3YgPSBzdHIuc3BsaXQoJz0nLCAyKTtcclxuICAgICAgICAgICAgaWYgKGt2Lmxlbmd0aCA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2t2WzBdXSA9IGt2WzFdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gcHJvcGVydGllcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZSB0aGUgXCJzdGFuZGFyZFwiIFVDU0MgYmVkIGZvcm1hdFxyXG4gICAgICogQHBhcmFtIHRva2Vuc1xyXG4gICAgICogQHBhcmFtIGlnbm9yZVxyXG4gICAgICogQHJldHVybnMgZGVjb2RlZCBmZWF0dXJlLCBvciBudWxsIGlmIHRoaXMgaXMgbm90IGEgdmFsaWQgcmVjb3JkXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkZWNvZGVCZWQodG9rZW5zLCBpZ25vcmUpIHtcclxuXHJcbiAgICAgICAgdmFyIGNociwgc3RhcnQsIGVuZCwgaWQsIG5hbWUsIHRtcCwgaWROYW1lLCBleG9uQ291bnQsIGV4b25TaXplcywgZXhvblN0YXJ0cywgZXhvbnMsIGV4b24sIGZlYXR1cmUsXHJcbiAgICAgICAgICAgIGVTdGFydCwgZUVuZDtcclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPCAzKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgY2hyID0gdG9rZW5zWzBdO1xyXG4gICAgICAgIHN0YXJ0ID0gcGFyc2VJbnQodG9rZW5zWzFdKTtcclxuICAgICAgICBlbmQgPSB0b2tlbnMubGVuZ3RoID4gMiA/IHBhcnNlSW50KHRva2Vuc1syXSkgOiBzdGFydCArIDE7XHJcblxyXG4gICAgICAgIGZlYXR1cmUgPSB7Y2hyOiBjaHIsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIHNjb3JlOiAxMDAwfTtcclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgIC8vIE5vdGU6IHRoZXNlIGFyZSB2ZXJ5IHNwZWNpYWwgcnVsZXMgZm9yIHRoZSBnZW5jb2RlIGdlbmUgZmlsZXMuXHJcbiAgICAgICAgICAgIHRtcCA9IHRva2Vuc1szXS5yZXBsYWNlKC9cIi9nLCAnJyk7XHJcbiAgICAgICAgICAgIGlkTmFtZSA9IHRtcC5zcGxpdCgnOycpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkTmFtZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGt2ID0gaWROYW1lW2ldLnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoa3ZbMF0gPT0gXCJnZW5lX2lkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZCA9IGt2WzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGt2WzBdID09IFwiZ2VuZV9uYW1lXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0ga3ZbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmVhdHVyZS5pZCA9IGlkID8gaWQgOiB0bXA7XHJcbiAgICAgICAgICAgIGZlYXR1cmUubmFtZSA9IG5hbWUgPyBuYW1lIDogdG1wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA0KSB7XHJcbiAgICAgICAgICAgIGZlYXR1cmUuc2NvcmUgPSBwYXJzZUZsb2F0KHRva2Vuc1s0XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gNSkge1xyXG4gICAgICAgICAgICBmZWF0dXJlLnN0cmFuZCA9IHRva2Vuc1s1XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA2KSB7XHJcbiAgICAgICAgICAgIGZlYXR1cmUuY2RTdGFydCA9IHBhcnNlSW50KHRva2Vuc1s2XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gNykge1xyXG4gICAgICAgICAgICBmZWF0dXJlLmNkRW5kID0gcGFyc2VJbnQodG9rZW5zWzddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA4KSB7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbnNbOF0gIT09IFwiLlwiICYmIHRva2Vuc1s4XSAhPT0gXCIwXCIpXHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlLmNvbG9yID0gaWd2LmNyZWF0ZUNvbG9yU3RyaW5nKHRva2Vuc1s4XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMTEpIHtcclxuICAgICAgICAgICAgZXhvbkNvdW50ID0gcGFyc2VJbnQodG9rZW5zWzldKTtcclxuICAgICAgICAgICAgZXhvblNpemVzID0gdG9rZW5zWzEwXS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICBleG9uU3RhcnRzID0gdG9rZW5zWzExXS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICBleG9ucyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleG9uQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZVN0YXJ0ID0gc3RhcnQgKyBwYXJzZUludChleG9uU3RhcnRzW2ldKTtcclxuICAgICAgICAgICAgICAgIGVFbmQgPSBlU3RhcnQgKyBwYXJzZUludChleG9uU2l6ZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4b24gPSB7c3RhcnQ6IGVTdGFydCwgZW5kOiBlRW5kfTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5jZFN0YXJ0ID4gZUVuZCB8fCBmZWF0dXJlLmNkRW5kIDwgZmVhdHVyZS5jZFN0YXJ0KSBleG9uLnV0ciA9IHRydWU7ICAgLy8gRW50aXJlIGV4b24gaXMgVVRSXHJcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5jZFN0YXJ0ID49IGVTdGFydCAmJiBmZWF0dXJlLmNkU3RhcnQgPD0gZUVuZCkgZXhvbi5jZFN0YXJ0ID0gZmVhdHVyZS5jZFN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuY2RFbmQgPj0gZVN0YXJ0ICYmIGZlYXR1cmUuY2RFbmQgPD0gZUVuZCkgZXhvbi5jZEVuZCA9IGZlYXR1cmUuY2RFbmQ7XHJcblxyXG4gICAgICAgICAgICAgICAgZXhvbnMucHVzaChleG9uKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmVhdHVyZS5leG9ucyA9IGV4b25zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZmVhdHVyZS5wb3B1cERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gW107XHJcbiAgICAgICAgICAgIGlmIChmZWF0dXJlLm5hbWUpIGRhdGEucHVzaCh7bmFtZTogXCJOYW1lXCIsIHZhbHVlOiBmZWF0dXJlLm5hbWV9KTtcclxuICAgICAgICAgICAgaWYgKFwiK1wiID09PSBmZWF0dXJlLnN0cmFuZCB8fCBcIi1cIiA9PT0gZmVhdHVyZS5zdHJhbmQpIGRhdGEucHVzaCh7bmFtZTogXCJTdHJhbmRcIiwgdmFsdWU6IGZlYXR1cmUuc3RyYW5kfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZSBhIFVDU0MgXCJyZWZmbGF0XCIgcmVjb3JkXHJcbiAgICAgKiBAcGFyYW0gdG9rZW5zXHJcbiAgICAgKiBAcGFyYW0gaWdub3JlXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRlY29kZVJlZmZsYXQodG9rZW5zLCBpZ25vcmUpIHtcclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPCAxMCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIHZhciBmZWF0dXJlID0ge1xyXG4gICAgICAgICAgICAgICAgY2hyOiB0b2tlbnNbMl0sXHJcbiAgICAgICAgICAgICAgICBzdGFydDogcGFyc2VJbnQodG9rZW5zWzRdKSxcclxuICAgICAgICAgICAgICAgIGVuZDogcGFyc2VJbnQodG9rZW5zWzVdKSxcclxuICAgICAgICAgICAgICAgIGlkOiB0b2tlbnNbMV0sXHJcbiAgICAgICAgICAgICAgICBuYW1lOiB0b2tlbnNbMF0sXHJcbiAgICAgICAgICAgICAgICBzdHJhbmQ6IHRva2Vuc1szXSxcclxuICAgICAgICAgICAgICAgIGNkU3RhcnQ6IHBhcnNlSW50KHRva2Vuc1s2XSksXHJcbiAgICAgICAgICAgICAgICBjZEVuZDogcGFyc2VJbnQodG9rZW5zWzddKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBleG9uQ291bnQgPSBwYXJzZUludCh0b2tlbnNbOF0pLFxyXG4gICAgICAgICAgICBleG9uU3RhcnRzID0gdG9rZW5zWzldLnNwbGl0KCcsJyksXHJcbiAgICAgICAgICAgIGV4b25FbmRzID0gdG9rZW5zWzEwXS5zcGxpdCgnLCcpLFxyXG4gICAgICAgICAgICBleG9ucyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4b25Db3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV4b25zLnB1c2goe3N0YXJ0OiBwYXJzZUludChleG9uU3RhcnRzW2ldKSwgZW5kOiBwYXJzZUludChleG9uRW5kc1tpXSl9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZlYXR1cmUuZXhvbnMgPSBleG9ucztcclxuXHJcbiAgICAgICAgZmVhdHVyZS5wb3B1cERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbe25hbWU6IFwiTmFtZVwiLCB2YWx1ZTogZmVhdHVyZS5uYW1lfV07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBkZWNvZGVQZWFrKHRva2VucywgaWdub3JlKSB7XHJcblxyXG4gICAgICAgIHZhciB0b2tlbkNvdW50LCBjaHIsIHN0YXJ0LCBlbmQsIHN0cmFuZCwgbmFtZSwgc2NvcmUsIHFWYWx1ZSwgc2lnbmFsLCBwVmFsdWU7XHJcblxyXG4gICAgICAgIHRva2VuQ291bnQgPSB0b2tlbnMubGVuZ3RoO1xyXG4gICAgICAgIGlmICh0b2tlbkNvdW50IDwgOSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNociA9IHRva2Vuc1swXTtcclxuICAgICAgICBzdGFydCA9IHBhcnNlSW50KHRva2Vuc1sxXSk7XHJcbiAgICAgICAgZW5kID0gcGFyc2VJbnQodG9rZW5zWzJdKTtcclxuICAgICAgICBuYW1lID0gdG9rZW5zWzNdO1xyXG4gICAgICAgIHNjb3JlID0gcGFyc2VGbG9hdCh0b2tlbnNbNF0pO1xyXG4gICAgICAgIHN0cmFuZCA9IHRva2Vuc1s1XS50cmltKCk7XHJcbiAgICAgICAgc2lnbmFsID0gcGFyc2VGbG9hdCh0b2tlbnNbNl0pO1xyXG4gICAgICAgIHBWYWx1ZSA9IHBhcnNlRmxvYXQodG9rZW5zWzddKTtcclxuICAgICAgICBxVmFsdWUgPSBwYXJzZUZsb2F0KHRva2Vuc1s4XSk7XHJcblxyXG4gICAgICAgIGlmIChzY29yZSA9PT0gMCkgc2NvcmUgPSBzaWduYWw7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNocjogY2hyLCBzdGFydDogc3RhcnQsIGVuZDogZW5kLCBuYW1lOiBuYW1lLCBzY29yZTogc2NvcmUsIHN0cmFuZDogc3RyYW5kLCBzaWduYWw6IHNpZ25hbCxcclxuICAgICAgICAgICAgcFZhbHVlOiBwVmFsdWUsIHFWYWx1ZTogcVZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZGVjb2RlQmVkR3JhcGgodG9rZW5zLCBpZ25vcmUpIHtcclxuXHJcbiAgICAgICAgdmFyIGNociwgc3RhcnQsIGVuZCwgdmFsdWU7XHJcblxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoIDwgMykgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIGNociA9IHRva2Vuc1swXTtcclxuICAgICAgICBzdGFydCA9IHBhcnNlSW50KHRva2Vuc1sxXSk7XHJcbiAgICAgICAgZW5kID0gcGFyc2VJbnQodG9rZW5zWzJdKTtcclxuXHJcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHRva2Vuc1szXSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7Y2hyOiBjaHIsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIHZhbHVlOiB2YWx1ZX07XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRlY29kZVdpZyh0b2tlbnMsIHdpZykge1xyXG5cclxuICAgICAgICB2YXIgc3MsXHJcbiAgICAgICAgICAgIGVlLFxyXG4gICAgICAgICAgICB2YWx1ZTtcclxuXHJcbiAgICAgICAgaWYgKHdpZy5mb3JtYXQgPT09IFwiZml4ZWRTdGVwXCIpIHtcclxuXHJcbiAgICAgICAgICAgIHNzID0gKHdpZy5pbmRleCAqIHdpZy5zdGVwKSArIHdpZy5zdGFydDtcclxuICAgICAgICAgICAgZWUgPSBzcyArIHdpZy5zcGFuO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodG9rZW5zWzBdKTtcclxuICAgICAgICAgICAgKysod2lnLmluZGV4KTtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKSA/IG51bGwgOiB7Y2hyOiB3aWcuY2hyb20sIHN0YXJ0OiBzcywgZW5kOiBlZSwgdmFsdWU6IHZhbHVlfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAod2lnLmZvcm1hdCA9PT0gXCJ2YXJpYWJsZVN0ZXBcIikge1xyXG5cclxuICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPCAyKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIHNzID0gcGFyc2VJbnQodG9rZW5zWzBdLCAxMCk7XHJcbiAgICAgICAgICAgIGVlID0gc3MgKyB3aWcuc3BhbjtcclxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHRva2Vuc1sxXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgPyBudWxsIDoge2Nocjogd2lnLmNocm9tLCBzdGFydDogc3MsIGVuZDogZWUsIHZhbHVlOiB2YWx1ZX07XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZUJlZEdyYXBoKHRva2Vucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBkZWNvZGVBbmV1KHRva2VucywgaWdub3JlKSB7XHJcblxyXG4gICAgICAgIHZhciBjaHIsIHN0YXJ0LCBlbmQsIGZlYXR1cmU7XHJcblxyXG5cclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA8IDQpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBjaHIgPSB0b2tlbnNbMV07XHJcbiAgICAgICAgc3RhcnQgPSBwYXJzZUludCh0b2tlbnNbMl0pO1xyXG4gICAgICAgIGVuZCA9IHRva2Vucy5sZW5ndGggPiAzID8gcGFyc2VJbnQodG9rZW5zWzNdKSA6IHN0YXJ0ICsgMTtcclxuXHJcbiAgICAgICAgZmVhdHVyZSA9IHtjaHI6IGNociwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZH07XHJcblxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gNCkge1xyXG4gICAgICAgICAgICBmZWF0dXJlLnNjb3JlID0gcGFyc2VGbG9hdCh0b2tlbnNbNF0pO1xyXG4gICAgICAgICAgICBmZWF0dXJlLnZhbHVlID0gZmVhdHVyZS5zY29yZTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBmZWF0dXJlLnBvcHVwRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt7bmFtZTogXCJOYW1lXCIsIHZhbHVlOiBmZWF0dXJlLm5hbWV9XTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gZmVhdHVyZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRlY29kZUZ1c2lvbkp1bmNTcGFuKHRva2VucywgaWdub3JlKSB7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgIEZvcm1hdDpcclxuXHJcbiAgICAgICAgIDAgICAgICAgI3NjYWZmb2xkXHJcbiAgICAgICAgIDEgICAgICAgZnVzaW9uX2JyZWFrX25hbWVcclxuICAgICAgICAgMiAgICAgICBicmVha19sZWZ0XHJcbiAgICAgICAgIDMgICAgICAgYnJlYWtfcmlnaHRcclxuICAgICAgICAgNCAgICAgICBudW1fanVuY3Rpb25fcmVhZHNcclxuICAgICAgICAgNSAgICAgICBudW1fc3Bhbm5pbmdfZnJhZ3NcclxuICAgICAgICAgNiAgICAgICBzcGFubmluZ19mcmFnX2Nvb3Jkc1xyXG5cclxuICAgICAgICAgMCAgICAgICBCM0dOVDEtLU5QU1IxXHJcbiAgICAgICAgIDEgICAgICAgQjNHTlQxLS1OUFNSMXwyMjAzLTEwMTgyXHJcbiAgICAgICAgIDIgICAgICAgMjIwM1xyXG4gICAgICAgICAzICAgICAgIDEwMTgyXHJcbiAgICAgICAgIDQgICAgICAgMTg5XHJcbiAgICAgICAgIDUgICAgICAgMTEzOFxyXG4gICAgICAgICA2ICAgICAgIDE4NjAtMTM3NTcsMTc5OC0xMzgxOSwxMzkxLTE4MTI3LDE0NDMtMTcxNzQsLi4uXHJcblxyXG4gICAgICAgICAqL1xyXG5cclxuXHJcbiAgICAgICBcclxuXHJcbiAgICAgICAgdmFyIGNociA9IHRva2Vuc1swXTtcclxuICAgICAgICB2YXIgZnVzaW9uX25hbWUgPSB0b2tlbnNbMV07XHJcbiAgICAgICAgdmFyIGp1bmN0aW9uX2xlZnQgPSBwYXJzZUludCh0b2tlbnNbMl0pO1xyXG4gICAgICAgIHZhciBqdW5jdGlvbl9yaWdodCA9IHBhcnNlSW50KHRva2Vuc1szXSk7XHJcbiAgICAgICAgdmFyIG51bV9qdW5jdGlvbl9yZWFkcyA9IHBhcnNlSW50KHRva2Vuc1s0XSk7XHJcbiAgICAgICAgdmFyIG51bV9zcGFubmluZ19mcmFncyA9IHBhcnNlSW50KHRva2Vuc1s1XSk7XHJcblxyXG4gICAgICAgIHZhciBzcGFubmluZ19mcmFnX2Nvb3Jkc190ZXh0ID0gdG9rZW5zWzZdO1xyXG5cclxuICAgICAgICB2YXIgZmVhdHVyZSA9IHtcclxuICAgICAgICAgICAgY2hyOiBjaHIsXHJcbiAgICAgICAgICAgIG5hbWU6IGZ1c2lvbl9uYW1lLFxyXG4gICAgICAgICAgICBqdW5jdGlvbl9sZWZ0OiBqdW5jdGlvbl9sZWZ0LFxyXG4gICAgICAgICAgICBqdW5jdGlvbl9yaWdodDoganVuY3Rpb25fcmlnaHQsXHJcbiAgICAgICAgICAgIG51bV9qdW5jdGlvbl9yZWFkczogbnVtX2p1bmN0aW9uX3JlYWRzLFxyXG4gICAgICAgICAgICBudW1fc3Bhbm5pbmdfZnJhZ3M6IG51bV9zcGFubmluZ19mcmFncyxcclxuICAgICAgICAgICAgc3Bhbm5pbmdfZnJhZ19jb29yZHM6IFtdLFxyXG5cclxuICAgICAgICAgICAgc3RhcnQ6IC0xLFxyXG4gICAgICAgICAgICBlbmQ6IC0xXHJcbiAgICAgICAgfTsgLy8gc2V0IHN0YXJ0IGFuZCBlbmQgbGF0ZXIgYmFzZWQgb24gbWluL21heCBvZiBzcGFuIGNvb3Jkc1xyXG5cclxuICAgICAgICB2YXIgbWluX2Nvb3JkID0ganVuY3Rpb25fbGVmdDtcclxuICAgICAgICB2YXIgbWF4X2Nvb3JkID0ganVuY3Rpb25fcmlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChudW1fc3Bhbm5pbmdfZnJhZ3MgPiAwKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29vcmRfcGFpcnMgPSBzcGFubmluZ19mcmFnX2Nvb3Jkc190ZXh0LnNwbGl0KCcsJyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkX3BhaXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXRfY29vcmRzID0gY29vcmRfcGFpcnNbaV0uc3BsaXQoJy0nKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc3Bhbl9sZWZ0ID0gc3BsaXRfY29vcmRzWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwYW5fcmlnaHQgPSBzcGxpdF9jb29yZHNbMV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNwYW5fbGVmdCA8IG1pbl9jb29yZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbl9jb29yZCA9IHNwYW5fbGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzcGFuX3JpZ2h0ID4gbWF4X2Nvb3JkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4X2Nvb3JkID0gc3Bhbl9yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZlYXR1cmUuc3Bhbm5pbmdfZnJhZ19jb29yZHMucHVzaCh7bGVmdDogc3Bhbl9sZWZ0LCByaWdodDogc3Bhbl9yaWdodH0pO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZmVhdHVyZS5zdGFydCA9IG1pbl9jb29yZDtcclxuICAgICAgICBmZWF0dXJlLmVuZCA9IG1heF9jb29yZDtcclxuXHJcblxyXG4gICAgICAgIGZlYXR1cmUucG9wdXBEYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3tuYW1lOiBcIk5hbWVcIiwgdmFsdWU6IGZlYXR1cmUubmFtZX1dO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZGVjb2RlR3RleEdXQVModG9rZW5zLCBpZ25vcmUpIHtcclxuXHJcblxyXG4gICAgICAgIHZhciB0b2tlbkNvdW50LCBjaHIsIHN0YXJ0LCBlbmQsIHN0cmFuZCwgbmFtZSwgc2NvcmUsIHFWYWx1ZSwgc2lnbmFsLCBwVmFsdWU7XHJcblxyXG4gICAgICAgIHRva2VuQ291bnQgPSB0b2tlbnMubGVuZ3RoO1xyXG4gICAgICAgIGlmICh0b2tlbkNvdW50IDwgOCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNociA9IHRva2Vuc1swXTtcclxuICAgICAgICBzdGFydCA9IHBhcnNlSW50KHRva2Vuc1sxXSkgLSAxO1xyXG4gICAgICAgIGVuZCA9IHBhcnNlSW50KHRva2Vuc1szXS5zcGxpdCgnOicpWzFdKTtcclxuICAgICAgICAvL25hbWUgPSB0b2tlbnNbM107XHJcbiAgICAgICAgLy9zY29yZSA9IHBhcnNlRmxvYXQodG9rZW5zWzRdKTtcclxuICAgICAgICAvL3N0cmFuZCA9IHRva2Vuc1s1XS50cmltKCk7XHJcbiAgICAgICAgLy9zaWduYWwgPSBwYXJzZUZsb2F0KHRva2Vuc1s2XSk7XHJcbiAgICAgICAgcFZhbHVlID0gcGFyc2VGbG9hdCh0b2tlbnNbNV0pO1xyXG4gICAgICAgIC8vcVZhbHVlID0gcGFyc2VGbG9hdCh0b2tlbnNbOF0pO1xyXG5cclxuICAgICAgICAvL3JldHVybiB7Y2hyOiBjaHIsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIG5hbWU6IG5hbWUsIHNjb3JlOiBzY29yZSwgc3RyYW5kOiBzdHJhbmQsIHNpZ25hbDogc2lnbmFsLFxyXG4gICAgICAgIC8vICAgIHBWYWx1ZTogcFZhbHVlLCBxVmFsdWU6IHFWYWx1ZX07XHJcbiAgICAgICAgcmV0dXJuIHtjaHI6IGNociwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgcHZhbHVlOiBwVmFsdWV9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlIGEgc2luZ2xlIGdmZiByZWNvcmQgKDEgbGluZSBpbiBmaWxlKS4gIEFnZ3JlZ2F0aW9ucyBzdWNoIGFzIGdlbmUgbW9kZWxzIGFyZSBjb25zdHJ1Y3RlZCBhdCBhIGhpZ2hlciBsZXZlbC5cclxuICAgICAqICAgICAgY3RnMTIzIC4gbVJOQSAgICAgICAgICAgIDEwNTAgIDkwMDAgIC4gICsgIC4gIElEPW1STkEwMDAwMTtQYXJlbnQ9Z2VuZTAwMDAxXHJcbiAgICAgKiBAcGFyYW0gdG9rZW5zXHJcbiAgICAgKiBAcGFyYW0gaWdub3JlXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRlY29kZUdGRih0b2tlbnMsIGlnbm9yZSkge1xyXG5cclxuICAgICAgICB2YXIgdG9rZW5Db3VudCwgY2hyLCBzdGFydCwgZW5kLCBzdHJhbmQsIHR5cGUsIHNjb3JlLCBwaGFzZSwgYXR0cmlidXRlU3RyaW5nLCBpZCwgcGFyZW50LCBjb2xvciwgbmFtZSxcclxuICAgICAgICAgICAgdHJhbnNjcmlwdF9pZCwgaSxcclxuICAgICAgICAgICAgZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XHJcblxyXG4gICAgICAgIHRva2VuQ291bnQgPSB0b2tlbnMubGVuZ3RoO1xyXG4gICAgICAgIGlmICh0b2tlbkNvdW50IDwgOSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgICAgICAvLyBOb3QgYSB2YWxpZCBnZmYgcmVjb3JkXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaHIgPSB0b2tlbnNbMF07XHJcbiAgICAgICAgdHlwZSA9IHRva2Vuc1syXTtcclxuICAgICAgICBzdGFydCA9IHBhcnNlSW50KHRva2Vuc1szXSkgLSAxO1xyXG4gICAgICAgIGVuZCA9IHBhcnNlSW50KHRva2Vuc1s0XSk7XHJcbiAgICAgICAgc2NvcmUgPSBcIi5cIiA9PT0gdG9rZW5zWzVdID8gMCA6IHBhcnNlRmxvYXQodG9rZW5zWzVdKTtcclxuICAgICAgICBzdHJhbmQgPSB0b2tlbnNbNl07XHJcbiAgICAgICAgcGhhc2UgPSBcIi5cIiA9PT0gdG9rZW5zWzddID8gMCA6IHBhcnNlSW50KHRva2Vuc1s3XSk7XHJcbiAgICAgICAgYXR0cmlidXRlU3RyaW5nID0gdG9rZW5zWzhdO1xyXG5cclxuICAgICAgICAvLyBGaW5kIElEIGFuZCBQYXJlbnQsIG9yIHRyYW5zY3JpcHRfaWRcclxuICAgICAgICB2YXIgZGVsaW0gPSAoJ2dmZjMnID09PSBmb3JtYXQpID8gJz0nIDogL1xccysvO1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge307XHJcbiAgICAgICAgYXR0cmlidXRlU3RyaW5nLnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbiAoa3YpIHtcclxuICAgICAgICAgICAgdmFyIHQgPSBrdi50cmltKCkuc3BsaXQoZGVsaW0sIDIpLCBrZXksIHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodC5sZW5ndGggPT0gMikge1xyXG4gICAgICAgICAgICAgICAga2V5ID0gdFswXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRbMV0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgLy9TdHJpcCBvZmYgcXVvdGVzLCBpZiBhbnlcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCdcIicpICYmIHZhbHVlLmVuZHNXaXRoKCdcIicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMSwgdmFsdWUubGVuZ3RoIC0gMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJJRFwiID09PSB0WzBdKSBpZCA9IHRbMV07XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcIlBhcmVudFwiID09PSB0WzBdKSBwYXJlbnQgPSB0WzFdO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJjb2xvclwiID09PSB0WzBdLnRvTG93ZXJDYXNlKCkpIGNvbG9yID0gaWd2LmNyZWF0ZUNvbG9yU3RyaW5nKHRbMV0pO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJ0cmFuc2NyaXB0X2lkXCIgPT09IHRbMF0pIGlkID0gdFsxXTsgICAgIC8vIGd0ZiBmb3JtYXRcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEZpbmQgbmFtZSAobGFiZWwpIHByb3BlcnR5XHJcbiAgICAgICAgaWYgKHRoaXMubmFtZUZpZWxkKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBhdHRyaWJ1dGVzW3RoaXMubmFtZUZpZWxkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZmZOYW1lRmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShnZmZOYW1lRmllbGRzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZUZpZWxkID0gZ2ZmTmFtZUZpZWxkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gYXR0cmlidXRlc1t0aGlzLm5hbWVGaWVsZF07XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBpZCxcclxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXHJcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgIGNocjogY2hyLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZDogZW5kLFxyXG4gICAgICAgICAgICBzY29yZTogc2NvcmUsXHJcbiAgICAgICAgICAgIHN0cmFuZDogc3RyYW5kLFxyXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZVN0cmluZzogYXR0cmlidXRlU3RyaW5nLFxyXG4gICAgICAgICAgICBwb3B1cERhdGE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrdnMgPSB0aGlzLmF0dHJpYnV0ZVN0cmluZy5zcGxpdCgnOycpLFxyXG4gICAgICAgICAgICAgICAgICAgIHBkID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAga2V5LCB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGt2cy5mb3JFYWNoKGZ1bmN0aW9uIChrdikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga3YudHJpbSgpLnNwbGl0KGRlbGltLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodC5sZW5ndGggPT09IDIgJiYgdFsxXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHRbMF0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRbMV0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1N0cmlwIG9mZiBxdW90ZXMsIGlmIGFueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnXCInKSAmJiB2YWx1ZS5lbmRzV2l0aCgnXCInKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMSwgdmFsdWUubGVuZ3RoIC0gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGQucHVzaCh7bmFtZToga2V5LCB2YWx1ZTogdmFsdWV9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlIHRoZSBcInN0YW5kYXJkXCIgVUNTQyBiZWQgZm9ybWF0XHJcbiAgICAgKiBAcGFyYW0gdG9rZW5zXHJcbiAgICAgKiBAcGFyYW0gaWdub3JlXHJcbiAgICAgKiBAcmV0dXJucyBkZWNvZGVkIGZlYXR1cmUsIG9yIG51bGwgaWYgdGhpcyBpcyBub3QgYSB2YWxpZCByZWNvcmRcclxuICAgICAqL1xyXG4gICAgZGVjb2RlQ3VzdG9tKHRva2VucywgaWdub3JlKSB7XHJcblxyXG4gICAgICAgIHZhciBmZWF0dXJlLFxyXG4gICAgICAgICAgICBjaHIsIHN0YXJ0LCBlbmQsXHJcbiAgICAgICAgICAgIGZvcm1hdCA9IHRoaXMuZm9ybWF0LCAgICAgICAgIC8vIFwidGhpc1wiIHJlZmVycyB0byBGZWF0dXJlUGFyc2VyIGluc3RhbmNlXHJcbiAgICAgICAgICAgIGNvb3JkcyA9IGZvcm1hdC5jb29yZHMgfHwgMDtcclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPCAzKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgY2hyID0gdG9rZW5zW2Zvcm1hdC5jaHJdO1xyXG4gICAgICAgIHN0YXJ0ID0gcGFyc2VJbnQodG9rZW5zW2Zvcm1hdC5zdGFydF0pIC0gY29vcmRzO1xyXG4gICAgICAgIGVuZCA9IGZvcm1hdC5lbmQgIT09IHVuZGVmaW5lZCA/IHBhcnNlSW50KHRva2Vuc1tmb3JtYXQuZW5kXSkgOiBzdGFydCArIDE7XHJcblxyXG4gICAgICAgIGZlYXR1cmUgPSB7Y2hyOiBjaHIsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmR9O1xyXG5cclxuICAgICAgICBpZiAoZm9ybWF0LmZpZWxkcykge1xyXG4gICAgICAgICAgICBmb3JtYXQuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9IGZvcm1hdC5jaHIgJiYgaW5kZXggIT0gZm9ybWF0LnN0YXJ0ICYmIGluZGV4ICE9IGZvcm1hdC5lbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlW2ZpZWxkXSA9IHRva2Vuc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcblxyXG4vLyoqKioqKipqcy9mZWF0dXJlL2ZlYXR1cmVDYWNoZS5qcyoqKioqKioqKioqKioqKioqKioqKipcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYmplY3QgZm9yIGNhY2hpbmcgbGlzdHMgb2YgZmVhdHVyZXMuICBTdXBwb3J0cyBlZmZlY2llbnQgcXVlcmllcyBmb3Igc3ViLXJhbmdlICAoY2hyLCBzdGFydCwgZW5kKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmZWF0dXJlTGlzdFxyXG4gICAgICogQHBhcmFtIFRoZSBnZW5vbWljIHJhbmdlIHNwYW5uZWQgYnkgZmVhdHVyZUxpc3QgKG9wdGlvbmFsKVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuXHJcbmNsYXNzIEZlYXR1cmVDYWNoZXtcclxuICAgIGNvbnN0cnVjdG9yKGZlYXR1cmVMaXN0LCByYW5nZSkge1xyXG4gICAgICAgIHRoaXMudHJlZU1hcCA9IEZlYXR1cmVDYWNoZS5idWlsZFRyZWVNYXAoZmVhdHVyZUxpc3QpO1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcclxuICAgIH1cclxuXHJcbiAgICBxdWVyeUZlYXR1cmVzKGNociwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgICBcclxuXHJcbiAgICAgICAgdmFyIGZlYXR1cmVMaXN0LCBpbnRlcnZhbEZlYXR1cmVzLCBmZWF0dXJlLCBsZW4sIGksIHRyZWUsIGludGVydmFscztcclxuXHJcbiAgICAgICAgdHJlZSA9IHRoaXMudHJlZU1hcFtjaHJdO1xyXG5cclxuICAgICAgICBpZiAoIXRyZWUpIHJldHVybiBbXTtcclxuXHJcbiAgICAgICAgaW50ZXJ2YWxzID0gdHJlZS5maW5kT3ZlcmxhcHBpbmcoc3RhcnQsIGVuZCk7XHJcblxyXG4gICAgICAgIGlmIChpbnRlcnZhbHMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVHJpbSB0aGUgbGlzdCBvZiBmZWF0dXJlcyBpbiB0aGUgaW50ZXJ2YWxzIHRvIHRob3NlXHJcbiAgICAgICAgICAgIC8vIG92ZXJsYXBwaW5nIHRoZSByZXF1ZXN0ZWQgcmFuZ2UuXHJcbiAgICAgICAgICAgIC8vIEFzc3VtcHRpb246IGZlYXR1cmVzIGFyZSBzb3J0ZWQgYnkgc3RhcnQgcG9zaXRpb25cclxuXHJcbiAgICAgICAgICAgIGZlYXR1cmVMaXN0ID0gW107XHJcblxyXG4gICAgICAgICAgICBpbnRlcnZhbHMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgIGludGVydmFsRmVhdHVyZXMgPSBpbnRlcnZhbC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGxlbiA9IGludGVydmFsRmVhdHVyZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZSA9IGludGVydmFsRmVhdHVyZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuc3RhcnQgPiBlbmQpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZlYXR1cmUuZW5kID49IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVMaXN0LnB1c2goZmVhdHVyZSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gZmVhdHVyZUxpc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgYWxsRmVhdHVyZXMoKSB7XHJcblxyXG4gICAgICAgIHZhciBhbGxGZWF0dXJlcyA9IFtdO1xyXG4gICAgICAgIHZhciB0cmVlTWFwID0gdGhpcy50cmVlTWFwO1xyXG4gICAgICAgIGlmICh0cmVlTWFwKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0cmVlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJlZU1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmVlID0gdHJlZU1hcFtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyZWUubWFwSW50ZXJ2YWxzKGZ1bmN0aW9uIChpbnRlcnZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcyA9IGFsbEZlYXR1cmVzLmNvbmNhdChpbnRlcnZhbC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFsbEZlYXR1cmVzO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgYnVpbGRUcmVlTWFwKGZlYXR1cmVMaXN0KSB7XHJcblxyXG4gICAgICAgIHZhciBmZWF0dXJlQ2FjaGUgPSB7fSxcclxuICAgICAgICAgICAgY2hyb21vc29tZXMgPSBbXSxcclxuICAgICAgICAgICAgdHJlZU1hcCA9IHt9LFxyXG4gICAgICAgICAgICBnZW5vbWUgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAoZmVhdHVyZUxpc3QpIHtcclxuXHJcbiAgICAgICAgICAgIGZlYXR1cmVMaXN0LmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY2hyID0gZmVhdHVyZS5jaHIsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2VuZUxpc3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJhbnNsYXRlIHRvIFwib2ZmaWNpYWxcIiBuYW1lXHJcbiAgICAgICAgICAgICAgICBpZihnZW5vbWUpIGNociA9IGdlbm9tZS5nZXRDaHJvbW9zb21lTmFtZShjaHIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGdlbmVMaXN0ID0gZmVhdHVyZUNhY2hlW2Nocl07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFnZW5lTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNocm9tb3NvbWVzLnB1c2goY2hyKTtcclxuICAgICAgICAgICAgICAgICAgICBnZW5lTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVDYWNoZVtjaHJdID0gZ2VuZUxpc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZ2VuZUxpc3QucHVzaChmZWF0dXJlKTtcclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIE5vdyBidWlsZCBpbnRlcnZhbCB0cmVlIGZvciBlYWNoIGNocm9tb3NvbWVcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hyb21vc29tZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBjaHIgPSBjaHJvbW9zb21lc1tpXTtcclxuICAgICAgICAgICAgICAgIHRyZWVNYXBbY2hyXSA9RmVhdHVyZUNhY2hlLmJ1aWxkSW50ZXJ2YWxUcmVlKGZlYXR1cmVDYWNoZVtjaHJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRyZWVNYXA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGQgYW4gaW50ZXJ2YWwgdHJlZSBmcm9tIHRoZSBmZWF0dXJlIGxpc3QgZm9yIGZhc3QgaW50ZXJ2YWwgYmFzZWQgcXVlcmllcy4gICBXZSBsdW1wIGZlYXR1cmVzIGluIGdyb3Vwc1xyXG4gICAgICogb2YgMTAsIG9yIHRvdGFsIHNpemUgLyAxMDAsICAgdG8gcmVkdWNlIHNpemUgb2YgdGhlIHRyZWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZlYXR1cmVMaXN0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBidWlsZEludGVydmFsVHJlZShmZWF0dXJlTGlzdCkge1xyXG5cclxuICAgICAgICB2YXIgaSwgZSwgaVN0YXJ0LCBpRW5kLCB0cmVlLCBjaHVua1NpemUsIGxlbiwgc3ViQXJyYXk7XHJcblxyXG4gICAgICAgIHRyZWUgPSBuZXcgSW50ZXJ2YWxUcmVlKCk7XHJcbiAgICAgICAgbGVuID0gZmVhdHVyZUxpc3QubGVuZ3RoO1xyXG5cclxuICAgICAgICBjaHVua1NpemUgPSBNYXRoLm1heCgxMCwgTWF0aC5yb3VuZChsZW4gLyAxMDApKTtcclxuXHJcbiAgICAgICAgZmVhdHVyZUxpc3Quc29ydChmdW5jdGlvbiAoZjEsIGYyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoZjEuc3RhcnQgPT09IGYyLnN0YXJ0ID8gMCA6IChmMS5zdGFydCA+IGYyLnN0YXJ0ID8gMSA6IC0xKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gY2h1bmtTaXplKSB7XHJcbiAgICAgICAgICAgIGUgPSBNYXRoLm1pbihsZW4sIGkgKyBjaHVua1NpemUpO1xyXG4gICAgICAgICAgICBzdWJBcnJheSA9IGZlYXR1cmVMaXN0LnNsaWNlKGksIGUpO1xyXG4gICAgICAgICAgICBpU3RhcnQgPSBzdWJBcnJheVswXS5zdGFydDtcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgaUVuZCA9IGlTdGFydDtcclxuICAgICAgICAgICAgc3ViQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgaUVuZCA9IE1hdGgubWF4KGlFbmQsIGZlYXR1cmUuZW5kKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRyZWUuaW5zZXJ0KGlTdGFydCwgaUVuZCwgc3ViQXJyYXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRyZWU7XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5cclxuLy8qKioqKmpzL2ludGVydmFsVHJlZS5qcyoqKioqKioqKioqKlxyXG5cclxuXHJcbmNvbnN0IEJMQUNLID0gMTtcclxuY29uc3QgUkVEID0gMjtcclxuXHJcbmxldCBOSUwgPSB7fVxyXG5OSUwuY29sb3IgPSBCTEFDSztcclxuTklMLnBhcmVudCA9IE5JTDtcclxuTklMLmxlZnQgPSBOSUw7XHJcbk5JTC5yaWdodCA9IE5JTDtcclxuXHJcbiAgXHJcbmNsYXNzIEludGVydmFsVHJlZXtcclxuICAgIGNvbnN0cnVjdG9yKCkgeyAgICBcclxuICAgICAgICB0aGlzLnJvb3QgPSBOSUw7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGluc2VydChzdGFydCwgZW5kLCB2YWx1ZSkge1xyXG5cclxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBuZXcgSW50ZXJ2YWwoc3RhcnQsIGVuZCwgdmFsdWUpO1xyXG4gICAgICAgIHZhciB4ID0gbmV3IE5vZGUoaW50ZXJ2YWwpO1xyXG4gICAgICAgIHRoaXMudHJlZUluc2VydCh4KTtcclxuICAgICAgICB4LmNvbG9yID0gUkVEO1xyXG4gICAgICAgIHdoaWxlICh4ICE9IHRoaXMucm9vdCAmJiB4LnBhcmVudC5jb2xvciA9PSBSRUQpIHtcclxuICAgICAgICAgICAgaWYgKHgucGFyZW50ID09IHgucGFyZW50LnBhcmVudC5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHgucGFyZW50LnBhcmVudC5yaWdodDtcclxuICAgICAgICAgICAgICAgIGlmICh5LmNvbG9yID09IFJFRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyZW50LmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgICAgICAgICAgeS5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyZW50LnBhcmVudC5jb2xvciA9IFJFRDtcclxuICAgICAgICAgICAgICAgICAgICB4ID0geC5wYXJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA9PSB4LnBhcmVudC5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0geC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdFJvdGF0ZSh4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgeC5wYXJlbnQuY29sb3IgPSBCTEFDSztcclxuICAgICAgICAgICAgICAgICAgICB4LnBhcmVudC5wYXJlbnQuY29sb3IgPSBSRUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodFJvdGF0ZSh4LnBhcmVudC5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSB4LnBhcmVudC5wYXJlbnQubGVmdDtcclxuICAgICAgICAgICAgICAgIGlmICh5LmNvbG9yID09IFJFRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyZW50LmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgICAgICAgICAgeS5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyZW50LnBhcmVudC5jb2xvciA9IFJFRDtcclxuICAgICAgICAgICAgICAgICAgICB4ID0geC5wYXJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA9PSB4LnBhcmVudC5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB4LnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodFJvdGF0ZSh4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgeC5wYXJlbnQuY29sb3IgPSBCTEFDSztcclxuICAgICAgICAgICAgICAgICAgICB4LnBhcmVudC5wYXJlbnQuY29sb3IgPSBSRUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWZ0Um90YXRlKHgucGFyZW50LnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yb290LmNvbG9yID0gQkxBQ0s7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGFydCAtIHF1ZXJ5IGludGVydmFsXHJcbiAgICAgKiBAcGFyYW0gZW5kIC0gcXVlcnkgaW50ZXJ2YWxcclxuICAgICAqIEByZXR1cm5zIEFycmF5IG9mIGFsbCBpbnRlcnZhbHMgb3ZlcmxhcHBpbmcgdGhlIHF1ZXJ5IHJlZ2lvblxyXG4gICAgICovXHJcbiAgICBmaW5kT3ZlcmxhcHBpbmcoc3RhcnQsIGVuZCkge1xyXG5cclxuXHJcbiAgICAgICAgdmFyIHNlYXJjaEludGVydmFsID0gbmV3IEludGVydmFsKHN0YXJ0LCBlbmQsIDApO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5yb290ID09PSBOSUwpIHJldHVybiBbXTtcclxuXHJcbiAgICAgICAgdmFyIGludGVydmFscyA9IHRoaXMuc2VhcmNoQWxsKHNlYXJjaEludGVydmFsLCB0aGlzLnJvb3QsIFtdKTtcclxuXHJcbiAgICAgICAgaWYoaW50ZXJ2YWxzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgaW50ZXJ2YWxzLnNvcnQoZnVuY3Rpb24oaTEsIGkyKSB7XHJcbiAgICAgICAgICAgICAgICAgcmV0dXJuIGkxLmxvdyAtIGkyLmxvdztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaW50ZXJ2YWxzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHVtcCBpbmZvIG9uIGludGVydmFscyB0byBjb25zb2xlLiAgRm9yIGRlYnVnZ2luZy5cclxuICAgICAqL1xyXG4gICAgbG9nSW50ZXJ2YWxzKCkge1xyXG5cclxuICAgICAgICBsb2dOb2RlKHRoaXMucm9vdCwgMCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGxvZ05vZGUobm9kZSwgaW5kZW50KSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3BhY2UgPSBcIlwiO1xyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxpbmRlbnQ7IGkrKykgc3BhY2UgKz0gXCIgXCI7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHNwYWNlICsgbm9kZS5pbnRlcnZhbC5sb3cgKyBcIiBcIiArIG5vZGUuaW50ZXJ2YWwuaGlnaCk7IC8vICsgXCIgXCIgKyAobm9kZS5pbnRlcnZhbC52YWx1ZSA/IG5vZGUuaW50ZXJ2YWwudmFsdWUgOiBcIiBudWxsXCIpKTtcclxuXHJcbiAgICAgICAgICAgIGluZGVudCArPSA1O1xyXG5cclxuICAgICAgICAgICAgaWYobm9kZS5sZWZ0ICE9IE5JTCkgbG9nTm9kZShub2RlLmxlZnQsIGluZGVudCk7XHJcbiAgICAgICAgICAgIGlmKG5vZGUucmlnaHQgIT0gTklMKSBsb2dOb2RlKG5vZGUucmlnaHQsIGluZGVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgbWFwSW50ZXJ2YWxzKGZ1bmMpIHtcclxuXHJcbiAgICAgICAgYXBwbHlJbnRlcnZhbCh0aGlzLnJvb3QpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhcHBseUludGVydmFsKG5vZGUpIHtcclxuXHJcbiAgICAgICAgICAgIGZ1bmMobm9kZS5pbnRlcnZhbCk7XHJcblxyXG4gICAgICAgICAgICBpZihub2RlLmxlZnQgIT0gTklMKSBhcHBseUludGVydmFsKG5vZGUubGVmdCk7XHJcbiAgICAgICAgICAgIGlmKG5vZGUucmlnaHQgIT0gTklMKSBhcHBseUludGVydmFsKG5vZGUucmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZWFyY2hBbGwoaW50ZXJ2YWwsIG5vZGUsIHJlc3VsdHMpIHtcclxuXHJcbiAgICAgICAgaWYgKG5vZGUuaW50ZXJ2YWwub3ZlcmxhcHMoaW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlLmludGVydmFsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChub2RlLmxlZnQgIT0gTklMICYmIG5vZGUubGVmdC5tYXggPj0gaW50ZXJ2YWwubG93KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoQWxsKGludGVydmFsLCBub2RlLmxlZnQsIHJlc3VsdHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5vZGUucmlnaHQgIT0gTklMICYmIG5vZGUucmlnaHQubWluIDw9IGludGVydmFsLmhpZ2gpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWFyY2hBbGwoaW50ZXJ2YWwsIG5vZGUucmlnaHQsIHJlc3VsdHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9XHJcblxyXG4gICAgbGVmdFJvdGF0ZSh4KSB7XHJcbiAgICAgICAgdmFyIHkgPSB4LnJpZ2h0O1xyXG4gICAgICAgIHgucmlnaHQgPSB5LmxlZnQ7XHJcbiAgICAgICAgaWYgKHkubGVmdCAhPSBOSUwpIHtcclxuICAgICAgICAgICAgeS5sZWZ0LnBhcmVudCA9IHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHkucGFyZW50ID0geC5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKHgucGFyZW50ID09IE5JTCkge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSB5O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh4LnBhcmVudC5sZWZ0ID09IHgpIHtcclxuICAgICAgICAgICAgICAgIHgucGFyZW50LmxlZnQgPSB5O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeC5wYXJlbnQucmlnaHQgPSB5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHkubGVmdCA9IHg7XHJcbiAgICAgICAgeC5wYXJlbnQgPSB5O1xyXG5cclxuICAgICAgICB0aGlzLmFwcGx5VXBkYXRlKHgpO1xyXG4gICAgICAgIC8vIG5vIG5lZWQgdG8gYXBwbHkgdXBkYXRlIG9uIHksIHNpbmNlIGl0J2xsIHkgaXMgYW4gYW5jZXN0b3JcclxuICAgICAgICAvLyBvZiB4LCBhbmQgd2lsbCBiZSB0b3VjaGVkIGJ5IGFwcGx5VXBkYXRlKCkuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHJpZ2h0Um90YXRlKHgpIHtcclxuICAgICAgICB2YXIgeSA9IHgubGVmdDtcclxuICAgICAgICB4LmxlZnQgPSB5LnJpZ2h0O1xyXG4gICAgICAgIGlmICh5LnJpZ2h0ICE9IE5JTCkge1xyXG4gICAgICAgICAgICB5LnJpZ2h0LnBhcmVudCA9IHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHkucGFyZW50ID0geC5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKHgucGFyZW50ID09IE5JTCkge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSB5O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh4LnBhcmVudC5yaWdodCA9PSB4KSB7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmVudC5yaWdodCA9IHk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmVudC5sZWZ0ID0geTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB5LnJpZ2h0ID0geDtcclxuICAgICAgICB4LnBhcmVudCA9IHk7XHJcblxyXG5cclxuICAgICAgICB0aGlzLmFwcGx5VXBkYXRlKHgpO1xyXG4gICAgICAgIC8vIG5vIG5lZWQgdG8gYXBwbHkgdXBkYXRlIG9uIHksIHNpbmNlIGl0J2xsIHkgaXMgYW4gYW5jZXN0b3JcclxuICAgICAgICAvLyBvZiB4LCBhbmQgd2lsbCBiZSB0b3VjaGVkIGJ5IGFwcGx5VXBkYXRlKCkuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm90ZTogIERvZXMgbm90IG1haW50YWluIFJCIGNvbnN0cmFpbnRzLCAgdGhpcyBpcyBkb25lIHBvc3QgaW5zZXJ0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHggIGEgTm9kZVxyXG4gICAgICovXHJcbiAgIHRyZWVJbnNlcnQoeCkge1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5yb290O1xyXG4gICAgICAgIHZhciB5ID0gTklMO1xyXG4gICAgICAgIHdoaWxlIChub2RlICE9IE5JTCkge1xyXG4gICAgICAgICAgICB5ID0gbm9kZTtcclxuICAgICAgICAgICAgaWYgKHguaW50ZXJ2YWwubG93IDw9IG5vZGUuaW50ZXJ2YWwubG93KSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgeC5wYXJlbnQgPSB5O1xyXG5cclxuICAgICAgICBpZiAoeSA9PSBOSUwpIHtcclxuICAgICAgICAgICAgdGhpcy5yb290ID0geDtcclxuICAgICAgICAgICAgeC5sZWZ0ID0geC5yaWdodCA9IE5JTDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoeC5pbnRlcnZhbC5sb3cgPD0geS5pbnRlcnZhbC5sb3cpIHtcclxuICAgICAgICAgICAgICAgIHkubGVmdCA9IHg7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB5LnJpZ2h0ID0geDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5hcHBseVVwZGF0ZSh4KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQXBwbGllcyB0aGUgc3RhdGlzdGljIHVwZGF0ZSBvbiB0aGUgbm9kZSBhbmQgaXRzIGFuY2VzdG9ycy5cclxuICAgIGFwcGx5VXBkYXRlIChub2RlKSB7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gTklMKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlTWF4ID0gbm9kZS5sZWZ0Lm1heCA+IG5vZGUucmlnaHQubWF4ID8gbm9kZS5sZWZ0Lm1heCA6IG5vZGUucmlnaHQubWF4O1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWxIaWdoID0gbm9kZS5pbnRlcnZhbC5oaWdoO1xyXG4gICAgICAgICAgICBub2RlLm1heCA9IG5vZGVNYXggPiBpbnRlcnZhbEhpZ2ggPyBub2RlTWF4IDogaW50ZXJ2YWxIaWdoO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5vZGVNaW4gPSBub2RlLmxlZnQubWluIDwgbm9kZS5yaWdodC5taW4gPyBub2RlLmxlZnQubWluIDogbm9kZS5yaWdodC5taW47XHJcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbExvdyA9IG5vZGUuaW50ZXJ2YWwubG93O1xyXG4gICAgICAgICAgICBub2RlLm1pbiA9IG5vZGVNaW4gPCBpbnRlcnZhbExvdyA/IG5vZGVNaW4gOiBpbnRlcnZhbExvdztcclxuXHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuY2xhc3MgSW50ZXJ2YWwge1xyXG4gICAgY29uc3RydWN0b3IobG93LCBoaWdoLCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMubG93ID0gbG93O1xyXG4gICAgICAgIHRoaXMuaGlnaCA9IGhpZ2g7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICBpZiAoIW90aGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMgPT0gb3RoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAodGhpcy5sb3cgPT0gb3RoZXJJbnRlcnZhbC5sb3cgJiZcclxuICAgICAgICAgICAgdGhpcy5oaWdoID09IG90aGVySW50ZXJ2YWwuaGlnaCk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5sb3cgPCBvdGhlci5sb3cpXHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBpZiAodGhpcy5sb3cgPiBvdGhlci5sb3cpXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5oaWdoIDwgb3RoZXIuaGlnaClcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGlmICh0aGlzLmhpZ2ggPiBvdGhlci5oaWdoKVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBpbnRlcnZhbCBvdmVybGFwcyB0aGUgb3RoZXIuXHJcbiAgICAgKi9cclxuICAgIG92ZXJsYXBzKG90aGVyKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmxvdyA8PSBvdGhlci5oaWdoICYmIG90aGVyLmxvdyA8PSB0aGlzLmhpZ2gpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy9hbGVydChlKTtcclxuICAgICAgICAgICAgaWd2LnByZXNlbnRBbGVydChlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIE5vZGV7XHJcbiAgICBjb25zdHJ1Y3RvcihpbnRlcnZhbCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gTklMO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IE5JTDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gTklMO1xyXG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBpbnRlcnZhbDtcclxuICAgICAgICB0aGlzLmNvbG9yID0gUkVEO1xyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBHZW5vbWljSW50ZXJ2YWx7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGNociwgc3RhcnQsIGVuZCwgZmVhdHVyZXMpIHtcclxuICAgICAgICB0aGlzLmNociA9IGNocjtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRhaW5zIChjaHIsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaHIgPT0gY2hyICYmXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPD0gc3RhcnQgJiZcclxuICAgICAgICAgICAgdGhpcy5lbmQgPj0gZW5kO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRhaW5zUmFuZ2UocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaHIgPT09IHJhbmdlLmNociAmJlxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0IDw9IHJhbmdlLnN0YXJ0ICYmXHJcbiAgICAgICAgICAgIHRoaXMuZW5kID49IHJhbmdlLmVuZDtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG5jbGFzcyBGYXN0YVNlcXVlbmNle1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHVybCkge1xyXG5cclxuICAgICAgICB0aGlzLmZpbGUgPSB1cmw7XHJcbiAgICAgICAgdGhpcy5pbmRleGVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5pbmRleGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXhGaWxlID0gdGhpcy5maWxlICsgXCIuZmFpXCI7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcblxyXG4gICAgfVxyXG5cclxuICAgaW5pdCgpe1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIGlmIChzZWxmLmluZGV4ZWQpIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5nZXRJbmRleCgpLnRoZW4oZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9yZGVyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNocm9tb3NvbWVzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jaHJvbW9zb21lTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hyTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnBMZW5ndGggPSBzZWxmLmluZGV4W2Nock5hbWVdLnNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2hyb21vc29tZXNbY2hyTmFtZV0gPSBuZXcgaWd2LkNocm9tb3NvbWUoY2hyTmFtZSwgb3JkZXIrKywgYnBMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGluZGV4LCBnZXR0aW5nIGNociBuYW1lcyBhcyBhIHNpZGUgZWZmZWN0LiAgUmVhbGx5IGJhZCBwcmFjdGljZVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoKTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYubG9hZEFsbCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U2VxdWVuY2UoY2hyLCBzdGFydCwgZW5kKSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmluZGV4ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VxdWVuY2VJbmRleGVkKGNociwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0U2VxdWVuY2VOb25JbmRleGVkLnRoaXMoY2hyLCBzdGFydCwgZW5kKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBnZXRTZXF1ZW5jZUluZGV4ZWQoY2hyLCBzdGFydCwgZW5kKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGludGVydmFsID0gc2VsZi5pbnRlcnZhbDtcclxuXHJcbiAgICAgICAgICAgIGlmIChpbnRlcnZhbCAmJiBpbnRlcnZhbC5jb250YWlucyhjaHIsIHN0YXJ0LCBlbmQpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChnZXRTZXF1ZW5jZUZyb21JbnRlcnZhbChpbnRlcnZhbCwgc3RhcnQsIGVuZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDYWNoZSBtaXNzOiBcIiArIChpbnRlcnZhbCA9PT0gdW5kZWZpbmVkID8gXCJuaWxcIiA6IGludGVydmFsLmNociArIFwiOlwiICsgaW50ZXJ2YWwuc3RhcnQgKyBcIi1cIiArIGludGVydmFsLmVuZCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBxdWVyeSwgdG8gbWluaW11bSBvZiAxMDBrYlxyXG4gICAgICAgICAgICAgICAgdmFyIHFzdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHFlbmQgPSBlbmQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGVuZCAtIHN0YXJ0KSA8IDEwMDAwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3ID0gKGVuZCAtIHN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2VudGVyID0gTWF0aC5yb3VuZChzdGFydCArIHcgLyAyKTtcclxuICAgICAgICAgICAgICAgICAgICBxc3RhcnQgPSBNYXRoLm1heCgwLCBjZW50ZXIgLSA1MDAwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcWVuZCA9IGNlbnRlciArIDUwMDAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLnJlYWRTZXF1ZW5jZShjaHIsIHFzdGFydCwgcWVuZCkudGhlbihmdW5jdGlvbiAoc2VxQnl0ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmludGVydmFsID0gbmV3IEdlbm9taWNJbnRlcnZhbChjaHIsIHFzdGFydCwgcWVuZCwgc2VxQnl0ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoZ2V0U2VxdWVuY2VGcm9tSW50ZXJ2YWwoc2VsZi5pbnRlcnZhbCwgc3RhcnQsIGVuZCkpO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U2VxdWVuY2VGcm9tSW50ZXJ2YWwoaW50ZXJ2YWwsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBzdGFydCAtIGludGVydmFsLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBlbmQgLSBzdGFydDtcclxuICAgICAgICAgICAgICAgIHZhciBzZXEgPSBpbnRlcnZhbC5mZWF0dXJlcyA/IGludGVydmFsLmZlYXR1cmVzLnN1YnN0cihvZmZzZXQsIG4pIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2V0U2VxdWVuY2VOb25JbmRleGVkKGNociwgc3RhcnQsIGVuZCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBzZXEgPSBzZWxmLnNlcXVlbmNlc1tjaHJdO1xyXG4gICAgICAgICAgICBpZiAoc2VxICYmIHNlcS5sZW5ndGggPiBlbmQpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VxLnN1YnN0cmluZyhzdGFydCwgZW5kKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0SW5kZXgoKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHNlbGYuaW5kZXgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWd2eGhyLmxvYWQoc2VsZi5pbmRleEZpbGUse30pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSBkYXRhLnNwbGl0KFwiXFxuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBsaW5lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVObyA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2hyb21vc29tZU5hbWVzID0gW107ICAgICAvLyBUT0RPIC0tIGVsaW1pbmF0ZSB0aGlzIHNpZGUgZWZmZWN0ICEhISFcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4ID0ge307ICAgICAgICAgICAgICAgLy8gVE9ETyAtLSBkaXR0b1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChsaW5lTm8gPCBsZW4pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBsaW5lc1tsaW5lTm8rK10uc3BsaXQoXCJcXHRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuVG9rZW5zID0gdG9rZW5zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5Ub2tlbnMgPT0gNSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGluZGV4IGxpbmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hyID0gdG9rZW5zWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSBwYXJzZUludCh0b2tlbnNbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gcGFyc2VJbnQodG9rZW5zWzJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXNlc1BlckxpbmUgPSBwYXJzZUludCh0b2tlbnNbM10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGVzUGVyTGluZSA9IHBhcnNlSW50KHRva2Vuc1s0XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4RW50cnkgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSwgcG9zaXRpb246IHBvc2l0aW9uLCBiYXNlc1BlckxpbmU6IGJhc2VzUGVyTGluZSwgYnl0ZXNQZXJMaW5lOiBieXRlc1BlckxpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jaHJvbW9zb21lTmFtZXMucHVzaChjaHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleFtjaHJdID0gaW5kZXhFbnRyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bGZpbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLmluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZEFsbCgpe1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHNlbGYuY2hyb21vc29tZU5hbWVzID0gW107XHJcbiAgICAgICAgICAgIHNlbGYuY2hyb21vc29tZXMgPSB7fTtcclxuICAgICAgICAgICAgc2VsZi5zZXF1ZW5jZXMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGlndnhoci5sb2FkKHNlbGYuZmlsZSwge1xyXG4gICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLndpdGhDcmVkZW50aWFsc1xyXG5cclxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IGRhdGEuc3BsaXRMaW5lcygpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IGxpbmVzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lTm8gPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRMaW5lLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXEgPSBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaHIsXHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXIgPSAwO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobGluZU5vIDwgbGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUgPSBsaW5lc1tsaW5lTm8rK10udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0TGluZS5zdGFydHNXaXRoKFwiI1wiKSB8fCBuZXh0TGluZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHRMaW5lLnN0YXJ0c1dpdGgoXCI+XCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2VxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNocm9tb3NvbWVOYW1lcy5wdXNoKGN1cnJlbnRDaHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXF1ZW5jZXNbY3VycmVudENocl0gPSBjdXJyZW50U2VxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jaHJvbW9zb21lc1tjdXJyZW50Q2hyXSA9IG5ldyBpZ3YuQ2hyb21vc29tZShjdXJyZW50Q2hyLCBvcmRlcisrLCBjdXJyZW50U2VxLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENociA9IG5leHRMaW5lLnN1YnN0cigxKS5zcGxpdChcIlxcXFxzK1wiKVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlcSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2VxICs9IG5leHRMaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKCk7XHJcblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZWFkU2VxdWVuY2UoY2hyLCBxc3RhcnQsIHFlbmQpIHtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJlYWQgc2VxdWVuY2UgXCIgKyBjaHIgKyBcIjpcIiArIHFzdGFydCArIFwiLVwiICsgcWVuZCk7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBzZWxmLmdldEluZGV4KCkudGhlbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGlkeEVudHJ5ID0gc2VsZi5pbmRleFtjaHJdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpZHhFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gaW5kZXggZW50cnkgZm9yIGNocjogXCIgKyBjaHIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUYWcgaW50ZXJ2YWwgd2l0aCBudWxsIHNvIHdlIGRvbid0IHRyeSBhZ2FpblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW50ZXJ2YWwgPSBuZXcgR2Vub21pY0ludGVydmFsKGNociwgcXN0YXJ0LCBxZW5kLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKG51bGwpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IE1hdGgubWF4KDAsIHFzdGFydCk7ICAgIC8vIHFzdGFydCBzaG91bGQgbmV2ZXIgYmUgPCAwXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IE1hdGgubWluKGlkeEVudHJ5LnNpemUsIHFlbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBieXRlc1BlckxpbmUgPSBpZHhFbnRyeS5ieXRlc1BlckxpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VzUGVyTGluZSA9IGlkeEVudHJ5LmJhc2VzUGVyTGluZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBpZHhFbnRyeS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbkVuZEJ5dGVzID0gYnl0ZXNQZXJMaW5lIC0gYmFzZXNQZXJMaW5lO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRMaW5lID0gTWF0aC5mbG9vcihzdGFydCAvIGJhc2VzUGVyTGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZExpbmUgPSBNYXRoLmZsb29yKGVuZCAvIGJhc2VzUGVyTGluZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlMCA9IHN0YXJ0TGluZSAqIGJhc2VzUGVyTGluZTsgICAvLyBCYXNlIGF0IGJlZ2lubmluZyBvZiBzdGFydCBsaW5lXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBzdGFydCAtIGJhc2UwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRCeXRlID0gcG9zaXRpb24gKyBzdGFydExpbmUgKiBieXRlc1BlckxpbmUgKyBvZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlMSA9IGVuZExpbmUgKiBiYXNlc1BlckxpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldDEgPSBlbmQgLSBiYXNlMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQnl0ZSA9IHBvc2l0aW9uICsgZW5kTGluZSAqIGJ5dGVzUGVyTGluZSArIG9mZnNldDEgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBieXRlQ291bnQgPSBlbmRCeXRlIC0gc3RhcnRCeXRlICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZUNvdW50IDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlndnhoci5sb2FkKHNlbGYuZmlsZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZToge3N0YXJ0OiBzdGFydEJ5dGUsIHNpemU6IGJ5dGVDb3VudH1cclxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChhbGxCeXRlcykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5CYXNlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcUJ5dGVzID0gXCJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BvcyA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNQb3MgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsQnl0ZXNMZW5ndGggPSBhbGxCeXRlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbkJhc2VzID0gTWF0aC5taW4oZW5kIC0gc3RhcnQsIGJhc2VzUGVyTGluZSAtIG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXFCeXRlcyArPSBhbGxCeXRlcy5zdWJzdHIoc3JjUG9zLCBuQmFzZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUG9zICs9IChuQmFzZXMgKyBuRW5kQnl0ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzUG9zICs9IG5CYXNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHNyY1BvcyA8IGFsbEJ5dGVzTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuQmFzZXMgPSBNYXRoLm1pbihiYXNlc1BlckxpbmUsIGFsbEJ5dGVzTGVuZ3RoIC0gc3JjUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcUJ5dGVzICs9IGFsbEJ5dGVzLnN1YnN0cihzcmNQb3MsIG5CYXNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQb3MgKz0gKG5CYXNlcyArIG5FbmRCeXRlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNQb3MgKz0gbkJhc2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHNlcUJ5dGVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdClcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7RmVhdHVyZVNvdXJjZSxGYXN0YVNlcXVlbmNlLEJpZ0JlZEZlYXR1cmVTb3VyY2V9Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQVNBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUF3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7Ozs7OztBQUlBOzs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRkE7QUFDQTtBQUVBO0FBQ0E7QUFKQTtBQUtBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7OztBQVZBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUhBO0FBSEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQXJEQTtBQXdEQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQTBlQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQXRnQkE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUVBOzs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5QkE7QUFnQ0E7Ozs7OztBQXVDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFHQTs7Ozs7O0FBS0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBSUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/feature.js\n");

/***/ }),

/***/ "./src/igvxhr.js":
/*!***********************!*\
  !*** ./src/igvxhr.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Zlib, XMLHttpRequest) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.unbgzf = exports.igvxhr = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _inflate = __webpack_require__(/*! ./vendor/inflate.js */ \"./src/vendor/inflate.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar is_node = false;\ntry {\n    navigator;\n} catch (e) {\n    is_node = true;\n}\n\nif (!Zlib.Zlib) {\n    Zlib.Zlib = Zlib;\n}\n\nvar NONE = 0;\nvar GZIP = 1;\nvar BGZF = 2;\n\nvar igvxhr = function () {\n    function igvxhr() {\n        _classCallCheck(this, igvxhr);\n    }\n\n    _createClass(igvxhr, null, [{\n        key: \"load\",\n\n\n        // Compression types\n\n\n        value: function load(url, options) {\n\n            return new Promise(function (fulfill, reject) {\n                var xhr = new XMLHttpRequest(),\n                    sendData = options.sendData,\n                    method = options.method || (sendData ? \"POST\" : \"GET\"),\n                    range = options.range,\n                    responseType = options.responseType,\n                    contentType = options.contentType,\n                    mimeType = options.mimeType,\n                    headers = options.headers,\n                    isSafari = is_node ? false : navigator.vendor.indexOf(\"Apple\") == 0 && /\\sSafari\\//.test(navigator.userAgent),\n                    withCredentials = options.withCredentials,\n                    header_keys,\n                    key,\n                    value,\n                    i;\n\n                // Support for GCS paths.\n                //url = url.startsWith(\"gs://\") ? igv.Google.translateGoogleCloudURL(url) : url;\n\n\n                /* if (igv.Google.isGoogleURL(url)) {\r\n                       url = igv.Google.addApiKey(url);\r\n                       // Add google headers (e.g. oAuth)\r\n                     headers = headers || {};\r\n                     igv.Google.addGoogleHeaders(headers);\r\n                       // Hack to prevent caching for google storage files.  Get weird net:err-cache errors otherwise\r\n                     if (range) {\r\n                         url += url.includes(\"?\") ? \"&\" : \"?\";\r\n                         url += \"someRandomSeed=\" + Math.random().toString(36);\r\n                     }\r\n                 }\r\n                 */\n\n                xhr.open(method, url);\n\n                if (range) {\n                    var rangeEnd = range.size ? range.start + range.size - 1 : \"\";\n                    xhr.setRequestHeader(\"Range\", \"bytes=\" + range.start + \"-\" + rangeEnd);\n                }\n                if (contentType) {\n                    xhr.setRequestHeader(\"Content-Type\", contentType);\n                }\n                if (mimeType) {\n                    xhr.overrideMimeType(mimeType);\n                }\n                if (responseType) {\n                    xhr.responseType = responseType;\n                }\n                if (headers) {\n                    header_keys = Object.keys(headers);\n                    for (i = 0; i < header_keys.length; i++) {\n                        key = header_keys[i];\n                        value = headers[key];\n                        // console.log(\"Adding to header: \" + key + \"=\" + value);\n                        xhr.setRequestHeader(key, value);\n                    }\n                }\n\n                // NOTE: using withCredentials with servers that return \"*\" for access-allowed-origin will fail\n                if (withCredentials === true) {\n                    xhr.withCredentials = true;\n                }\n\n                xhr.onload = function (event) {\n                    // when the url points to a local file, the status is 0 but that is no error\n                    if (xhr.status == 0 || xhr.status >= 200 && xhr.status <= 300) {\n\n                        if (range && xhr.status != 206) {\n                            handleError(\"ERROR: range-byte header was ignored for url: \" + url);\n                        } else {\n\n                            fulfill(xhr.response, xhr);\n                        }\n                    } else {\n\n                        //\n                        if (xhr.status === 416) {\n                            //  Tried to read off the end of the file.   This shouldn't happen, but if it does return an\n                            handleError(\"Unsatisfiable range\");\n                        } else {\n                            // TODO -- better error handling\n                            handleError(\"Error accessing resource: \" + xhr.status);\n                        }\n                    }\n                };\n\n                xhr.onerror = function (event) {\n\n                    if (false) {} else {\n                        handleError(\"Error accessing resource: \" + url + \" Status: \" + xhr.status);\n                    }\n                };\n\n                xhr.ontimeout = function (event) {\n                    handleError(\"Timed out\");\n                };\n\n                xhr.onabort = function (event) {\n                    console.log(\"Aborted\");\n                    reject(new igv.AbortLoad());\n                };\n\n                try {\n\n                    xhr.send(sendData);\n                } catch (e) {\n                    console.log(e);\n                }\n\n                function handleError(message) {\n                    if (reject) {\n                        reject(message);\n                    } else {\n                        throw Error(message);\n                    }\n                }\n            });\n        }\n    }, {\n        key: \"loadArrayBuffer\",\n        value: function loadArrayBuffer(url, options) {\n\n            if (options === undefined) options = {};\n            options.responseType = \"arraybuffer\";\n            return igvxhr.load(url, options);\n        }\n    }, {\n        key: \"loadJson\",\n        value: function loadJson(url, options) {\n\n            var method = options.method || (options.sendData ? \"POST\" : \"GET\");\n\n            if (method == \"POST\") options.contentType = \"application/json\";\n\n            return new Promise(function (fulfill, reject) {\n\n                igvxhr.load(url, options).then(function (result) {\n                    if (result) {\n                        fulfill(JSON.parse(result));\n                    } else {\n                        fulfill(result);\n                    }\n                }).catch(reject);\n            });\n        }\n\n        /**\r\n         * Load a \"raw\" string.\r\n         */\n\n    }, {\n        key: \"loadString\",\n        value: function loadString(url, options) {\n\n            var compression, fn, idx;\n\n            if (options === undefined) options = {};\n\n            // Strip parameters from url\n            // TODO -- handle local files with ?\n            idx = url.indexOf(\"?\");\n            fn = idx > 0 ? url.substring(0, idx) : url;\n\n            if (options.bgz) {\n                compression = BGZF;\n            } else if (fn.endsWith(\".gz\")) {\n                compression = GZIP;\n            } else {\n                compression = NONE;\n            }\n\n            if (compression === NONE) {\n                options.mimeType = 'text/plain; charset=x-user-defined';\n                return igvxhr.load(url, options);\n            } else {\n                options.responseType = \"arraybuffer\";\n\n                return new Promise(function (fulfill, reject) {\n\n                    igvxhr.load(url, options).then(function (data) {\n                        var result = igvxhr.arrayBufferToString(data, compression);\n                        fulfill(result);\n                    }).catch(reject);\n                });\n            }\n        }\n    }, {\n        key: \"loadStringFromFile\",\n        value: function loadStringFromFile(localfile, options) {\n\n            return new Promise(function (fulfill, reject) {\n\n                var fileReader = new FileReader(),\n                    range = options.range;\n\n                fileReader.onload = function (e) {\n\n                    var compression, result;\n\n                    if (options.bgz) {\n                        compression = BGZF;\n                    } else if (localfile.name.endsWith(\".gz\")) {\n\n                        compression = GZIP;\n                    } else {\n                        compression = NONE;\n                    }\n\n                    result = igvxhr.arrayBufferToString(fileReader.result, compression);\n\n                    fulfill(result, localfile);\n                };\n\n                fileReader.onerror = function (e) {\n                    console.log(\"reject uploading local file \" + localfile.name);\n                    reject(null, fileReader);\n                };\n\n                fileReader.readAsArrayBuffer(localfile);\n            });\n        }\n    }, {\n        key: \"isCrossDomain\",\n        value: function isCrossDomain(url) {\n\n            var origin = window.location.origin;\n\n            return !url.startsWith(origin);\n        }\n    }, {\n        key: \"arrayBufferToString\",\n        value: function arrayBufferToString(arraybuffer, compression) {\n\n            var plain, inflate;\n\n            if (compression === GZIP) {\n                inflate = new Zlib.Zlib.Gunzip(new Uint8Array(arraybuffer));\n                plain = inflate.decompress();\n            } else if (compression === BGZF) {\n                plain = new Uint8Array(unbgzf(arraybuffer));\n            } else {\n                plain = new Uint8Array(arraybuffer);\n            }\n\n            var result = \"\";\n            for (var i = 0, len = plain.length; i < len; i++) {\n                result = result + String.fromCharCode(plain[i]);\n            }\n            return result;\n        }\n    }]);\n\n    return igvxhr;\n}();\n\n//**********js/bam/bgzf.js***************************************\n\n\nvar BLOCK_HEADER_LENGTH = 18;\nvar BLOCK_LENGTH_OFFSET = 16; // Location in the gzip block of the total block size (actually total block size - 1)\nvar BLOCK_FOOTER_LENGTH = 8; // Number of bytes that follow the deflated data\nvar MAX_COMPRESSED_BLOCK_SIZE = 64 * 1024; // We require that a compressed block (including header and footer, be <= this)\nvar GZIP_OVERHEAD = BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH + 2; // Gzip overhead is the header, the footer, and the block size (encoded as a short).\nvar GZIP_ID1 = 31; // Magic number\nvar GZIP_ID2 = 139; // Magic number\nvar GZIP_FLG = 4; // FEXTRA flag means there are optional fields\n\n\n// Uncompress data,  assumed to be series of bgzipped blocks\n// Code is based heavily on bam.js, part of the Dalliance Genome Explorer,  (c) Thomas Down 2006-2001.\nvar unbgzf = function unbgzf(data, lim) {\n\n    var oBlockList = [],\n        ptr = [0],\n        totalSize = 0;\n\n    lim = lim || data.byteLength - 18;\n\n    while (ptr[0] < lim) {\n\n        var ba = new Uint8Array(data, ptr[0], 18);\n\n        var xlen = ba[11] << 8 | ba[10];\n        var si1 = ba[12];\n        var si2 = ba[13];\n        var slen = ba[15] << 8 | ba[14];\n        var bsize = ba[17] << 8 | ba[16] + 1;\n\n        var start = 12 + xlen + ptr[0]; // Start of CDATA\n        var length = data.byteLength - start;\n\n        if (length < bsize + 8) break;\n\n        var unc = (0, _inflate.jszlib_inflate_buffer)(data, start, length, ptr);\n\n        ptr[0] += 8; // Skipping CRC-32 and size of uncompressed data\n\n        totalSize += unc.byteLength;\n        oBlockList.push(unc);\n    }\n\n    // Concatenate decompressed blocks\n    if (oBlockList.length == 1) {\n        return oBlockList[0];\n    } else {\n        var out = new Uint8Array(totalSize);\n        var cursor = 0;\n        for (var i = 0; i < oBlockList.length; ++i) {\n            var b = new Uint8Array(oBlockList[i]);\n            (0, _inflate.arrayCopy)(b, 0, out, cursor, b.length);\n            cursor += b.length;\n        }\n        return out.buffer;\n    }\n};\n\nexports.igvxhr = igvxhr;\nexports.unbgzf = unbgzf;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/vendor/zlib_and_gzip.min.js */ \"./src/vendor/zlib_and_gzip.min.js\"), __webpack_require__(/*! xhr2 */ \"xhr2\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaWd2eGhyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9pZ3Z4aHIuanM/NGI1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IEJyb2FkIEluc3RpdHV0ZVxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xyXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gKiBUSEUgU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuXHJcbmltcG9ydCB7anN6bGliX2luZmxhdGVfYnVmZmVyLGFycmF5Q29weX0gZnJvbSBcIi4vdmVuZG9yL2luZmxhdGUuanNcIjtcclxuXHJcblxyXG5sZXQgaXNfbm9kZT1mYWxzZTtcclxudHJ5e1xyXG4gICAgbmF2aWdhdG9yO1xyXG59Y2F0Y2goZSl7XHJcbiAgICBpc19ub2RlPXRydWU7XHJcbn1cclxuXHJcbmlmICghWmxpYi5abGliKXtcclxuXHRabGliLlpsaWI9WmxpYjtcclxufVxyXG5cclxuY29uc3QgTk9ORSA9IDA7XHJcbmNvbnN0IEdaSVAgPSAxO1xyXG5jb25zdCBCR1pGID0gMjtcclxuY2xhc3MgaWd2eGhyIHtcclxuICAgXHJcbiAgICAvLyBDb21wcmVzc2lvbiB0eXBlc1xyXG4gICBcclxuXHJcbiAgICBzdGF0aWMgbG9hZCh1cmwsIG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICBcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxyXG4gICAgICAgICAgICAgICAgc2VuZERhdGEgPSBvcHRpb25zLnNlbmREYXRhLFxyXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgKHNlbmREYXRhID8gXCJQT1NUXCIgOiBcIkdFVFwiKSxcclxuICAgICAgICAgICAgICAgIHJhbmdlID0gb3B0aW9ucy5yYW5nZSxcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlLFxyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBvcHRpb25zLmNvbnRlbnRUeXBlLFxyXG4gICAgICAgICAgICAgICAgbWltZVR5cGUgPSBvcHRpb25zLm1pbWVUeXBlLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyxcclxuICAgICAgICAgICAgICAgIGlzU2FmYXJpID0gaXNfbm9kZT9mYWxzZTpuYXZpZ2F0b3IudmVuZG9yLmluZGV4T2YoXCJBcHBsZVwiKSA9PSAwICYmIC9cXHNTYWZhcmlcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksXHJcbiAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHMgPSBvcHRpb25zLndpdGhDcmVkZW50aWFscyxcclxuICAgICAgICAgICAgICAgIGhlYWRlcl9rZXlzLCBrZXksIHZhbHVlLCBpO1xyXG5cclxuICAgICAgICAgICAgLy8gU3VwcG9ydCBmb3IgR0NTIHBhdGhzLlxyXG4gICAgICAgICAgIC8vdXJsID0gdXJsLnN0YXJ0c1dpdGgoXCJnczovL1wiKSA/IGlndi5Hb29nbGUudHJhbnNsYXRlR29vZ2xlQ2xvdWRVUkwodXJsKSA6IHVybDtcclxuICAgICAgICBcclxuXHJcbiAgICAgICAgICAgLyogaWYgKGlndi5Hb29nbGUuaXNHb29nbGVVUkwodXJsKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHVybCA9IGlndi5Hb29nbGUuYWRkQXBpS2V5KHVybCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGdvb2dsZSBoZWFkZXJzIChlLmcuIG9BdXRoKVxyXG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IGhlYWRlcnMgfHwge307XHJcbiAgICAgICAgICAgICAgICBpZ3YuR29vZ2xlLmFkZEdvb2dsZUhlYWRlcnMoaGVhZGVycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSGFjayB0byBwcmV2ZW50IGNhY2hpbmcgZm9yIGdvb2dsZSBzdG9yYWdlIGZpbGVzLiAgR2V0IHdlaXJkIG5ldDplcnItY2FjaGUgZXJyb3JzIG90aGVyd2lzZVxyXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsICs9IHVybC5pbmNsdWRlcyhcIj9cIikgPyBcIiZcIiA6IFwiP1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIHVybCArPSBcInNvbWVSYW5kb21TZWVkPVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlRW5kID0gcmFuZ2Uuc2l6ZSA/IHJhbmdlLnN0YXJ0ICsgcmFuZ2Uuc2l6ZSAtIDEgOiBcIlwiO1xyXG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJSYW5nZVwiLCBcImJ5dGVzPVwiICsgcmFuZ2Uuc3RhcnQgKyBcIi1cIiArIHJhbmdlRW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWltZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKG1pbWVUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXJfa2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGhlYWRlcl9rZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gaGVhZGVyX2tleXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBoZWFkZXJzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJBZGRpbmcgdG8gaGVhZGVyOiBcIiArIGtleSArIFwiPVwiICsgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBOT1RFOiB1c2luZyB3aXRoQ3JlZGVudGlhbHMgd2l0aCBzZXJ2ZXJzIHRoYXQgcmV0dXJuIFwiKlwiIGZvciBhY2Nlc3MtYWxsb3dlZC1vcmlnaW4gd2lsbCBmYWlsXHJcbiAgICAgICAgICAgIGlmICh3aXRoQ3JlZGVudGlhbHMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSB1cmwgcG9pbnRzIHRvIGEgbG9jYWwgZmlsZSwgdGhlIHN0YXR1cyBpcyAwIGJ1dCB0aGF0IGlzIG5vIGVycm9yXHJcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PSAwIHx8ICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDw9IDMwMCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlICYmIHhoci5zdGF0dXMgIT0gMjA2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKFwiRVJST1I6IHJhbmdlLWJ5dGUgaGVhZGVyIHdhcyBpZ25vcmVkIGZvciB1cmw6IFwiICsgdXJsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbCh4aHIucmVzcG9uc2UseGhyKTtcclxuICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDQxNikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgVHJpZWQgdG8gcmVhZCBvZmYgdGhlIGVuZCBvZiB0aGUgZmlsZS4gICBUaGlzIHNob3VsZG4ndCBoYXBwZW4sIGJ1dCBpZiBpdCBkb2VzIHJldHVybiBhblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihcIlVuc2F0aXNmaWFibGUgcmFuZ2VcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Ugey8vIFRPRE8gLS0gYmV0dGVyIGVycm9yIGhhbmRsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKFwiRXJyb3IgYWNjZXNzaW5nIHJlc291cmNlOiBcIiArIHhoci5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxfcmV0cmllcz4xMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWxfcmV0cmllcysrO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghIG9wdGlvbnMucmV0cmllcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucmV0cmllcz0wXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucmV0cmllcysrO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vb3B0aW9ucy5zZW5kRGF0YSA9IFwidXJsPVwiICsgdXJsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vb3B0aW9ucy5jcm9zc0RvbWFpblJldHJpZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qaWYgKG9wdGlvbnMucmV0cmllczwzKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlndnhoci5sb2FkQXJyYXlCdWZmZXIodXJsLCBvcHRpb25zKS50aGVuKGZ1bGZpbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKFwiRXJyb3IgYWNjZXNzaW5nIHJlc291cmNlOiBcIiArIHVybCArIFwiIFN0YXR1czogXCIgKyB4aHIuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKFwiRXJyb3IgYWNjZXNzaW5nIHJlc291cmNlOiBcIiArIHVybCArIFwiIFN0YXR1czogXCIgKyB4aHIuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKFwiVGltZWQgb3V0XCIpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQWJvcnRlZFwiKTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgaWd2LkFib3J0TG9hZCgpKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgeGhyLnNlbmQoc2VuZERhdGEpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlRXJyb3IobWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGxvYWRBcnJheUJ1ZmZlciAodXJsLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBvcHRpb25zLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuICAgICAgICByZXR1cm4gaWd2eGhyLmxvYWQodXJsLCBvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIGxvYWRKc29uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IChvcHRpb25zLnNlbmREYXRhID8gXCJQT1NUXCIgOiBcIkdFVFwiKTtcclxuXHJcbiAgICAgICAgaWYgKG1ldGhvZCA9PSBcIlBPU1RcIikgb3B0aW9ucy5jb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgaWd2eGhyLmxvYWQodXJsLCBvcHRpb25zKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChKU09OLnBhcnNlKHJlc3VsdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgYSBcInJhd1wiIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGxvYWRTdHJpbmcodXJsLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIHZhciBjb21wcmVzc2lvbiwgZm4sIGlkeDtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHt9O1xyXG5cclxuICAgICAgICAvLyBTdHJpcCBwYXJhbWV0ZXJzIGZyb20gdXJsXHJcbiAgICAgICAgLy8gVE9ETyAtLSBoYW5kbGUgbG9jYWwgZmlsZXMgd2l0aCA/XHJcbiAgICAgICAgaWR4ID0gdXJsLmluZGV4T2YoXCI/XCIpO1xyXG4gICAgICAgIGZuID0gaWR4ID4gMCA/IHVybC5zdWJzdHJpbmcoMCwgaWR4KSA6IHVybDtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYmd6KSB7XHJcbiAgICAgICAgICAgIGNvbXByZXNzaW9uID0gQkdaRjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZm4uZW5kc1dpdGgoXCIuZ3pcIikpIHtcclxuICAgICAgICAgICAgY29tcHJlc3Npb24gPSBHWklQO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29tcHJlc3Npb24gPSBOT05FO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvbXByZXNzaW9uID09PSBOT05FKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMubWltZVR5cGUgPSAndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCc7XHJcbiAgICAgICAgICAgIHJldHVybiBpZ3Z4aHIubG9hZCh1cmwsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlndnhoci5sb2FkKHVybCwgb3B0aW9ucykudGhlbihcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaWd2eGhyLmFycmF5QnVmZmVyVG9TdHJpbmcoZGF0YSwgY29tcHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHN0YXRpYyBsb2FkU3RyaW5nRnJvbUZpbGUobG9jYWxmaWxlLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCksXHJcbiAgICAgICAgICAgICAgICByYW5nZSA9IG9wdGlvbnMucmFuZ2U7XHJcblxyXG5cclxuICAgICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjb21wcmVzc2lvbiwgcmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJneikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uID0gQkdaRjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvY2FsZmlsZS5uYW1lLmVuZHNXaXRoKFwiLmd6XCIpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uID0gR1pJUDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uID0gTk9ORTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpZ3Z4aHIuYXJyYXlCdWZmZXJUb1N0cmluZyhmaWxlUmVhZGVyLnJlc3VsdCwgY29tcHJlc3Npb24pO1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwocmVzdWx0LCBsb2NhbGZpbGUpO1xyXG5cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZpbGVSZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlamVjdCB1cGxvYWRpbmcgbG9jYWwgZmlsZSBcIiArIGxvY2FsZmlsZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChudWxsLCBmaWxlUmVhZGVyKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIobG9jYWxmaWxlKTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGlzQ3Jvc3NEb21haW4odXJsKSB7XHJcblxyXG4gICAgICAgIHZhciBvcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xyXG5cclxuICAgICAgICByZXR1cm4gIXVybC5zdGFydHNXaXRoKG9yaWdpbik7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBhcnJheUJ1ZmZlclRvU3RyaW5nIChhcnJheWJ1ZmZlciwgY29tcHJlc3Npb24pIHtcclxuXHJcbiAgICAgICAgdmFyIHBsYWluLCBpbmZsYXRlO1xyXG5cclxuICAgICAgICBpZiAoY29tcHJlc3Npb24gPT09IEdaSVApIHtcclxuICAgICAgICAgICAgaW5mbGF0ZSA9IG5ldyBabGliLlpsaWIuR3VuemlwKG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSk7XHJcbiAgICAgICAgICAgIHBsYWluID0gaW5mbGF0ZS5kZWNvbXByZXNzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbXByZXNzaW9uID09PSBCR1pGKSB7XHJcbiAgICAgICAgICAgIHBsYWluID0gbmV3IFVpbnQ4QXJyYXkodW5iZ3pmKGFycmF5YnVmZmVyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwbGFpbiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwbGFpbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBsYWluW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG4vLyoqKioqKioqKipqcy9iYW0vYmd6Zi5qcyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuXHJcbmNvbnN0IEJMT0NLX0hFQURFUl9MRU5HVEggPSAxODtcclxuY29uc3QgQkxPQ0tfTEVOR1RIX09GRlNFVCA9IDE2OyAgLy8gTG9jYXRpb24gaW4gdGhlIGd6aXAgYmxvY2sgb2YgdGhlIHRvdGFsIGJsb2NrIHNpemUgKGFjdHVhbGx5IHRvdGFsIGJsb2NrIHNpemUgLSAxKVxyXG5jb25zdCBCTE9DS19GT09URVJfTEVOR1RIID0gODsgLy8gTnVtYmVyIG9mIGJ5dGVzIHRoYXQgZm9sbG93IHRoZSBkZWZsYXRlZCBkYXRhXHJcbmNvbnN0IE1BWF9DT01QUkVTU0VEX0JMT0NLX1NJWkUgPSA2NCAqIDEwMjQ7IC8vIFdlIHJlcXVpcmUgdGhhdCBhIGNvbXByZXNzZWQgYmxvY2sgKGluY2x1ZGluZyBoZWFkZXIgYW5kIGZvb3RlciwgYmUgPD0gdGhpcylcclxuY29uc3QgR1pJUF9PVkVSSEVBRCA9IEJMT0NLX0hFQURFUl9MRU5HVEggKyBCTE9DS19GT09URVJfTEVOR1RIICsgMjsgLy8gR3ppcCBvdmVyaGVhZCBpcyB0aGUgaGVhZGVyLCB0aGUgZm9vdGVyLCBhbmQgdGhlIGJsb2NrIHNpemUgKGVuY29kZWQgYXMgYSBzaG9ydCkuXHJcbmNvbnN0IEdaSVBfSUQxID0gMzE7ICAgLy8gTWFnaWMgbnVtYmVyXHJcbmNvbnN0IEdaSVBfSUQyID0gMTM5OyAgLy8gTWFnaWMgbnVtYmVyXHJcbmNvbnN0IEdaSVBfRkxHID0gNDsgLy8gRkVYVFJBIGZsYWcgbWVhbnMgdGhlcmUgYXJlIG9wdGlvbmFsIGZpZWxkc1xyXG5cclxuXHJcbiAgICAvLyBVbmNvbXByZXNzIGRhdGEsICBhc3N1bWVkIHRvIGJlIHNlcmllcyBvZiBiZ3ppcHBlZCBibG9ja3NcclxuICAgIC8vIENvZGUgaXMgYmFzZWQgaGVhdmlseSBvbiBiYW0uanMsIHBhcnQgb2YgdGhlIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXIsICAoYykgVGhvbWFzIERvd24gMjAwNi0yMDAxLlxyXG5sZXQgdW5iZ3pmID0gZnVuY3Rpb24gKGRhdGEsIGxpbSkge1xyXG5cclxuICAgICAgICB2YXIgb0Jsb2NrTGlzdCA9IFtdLFxyXG4gICAgICAgICAgICBwdHIgPSBbMF0sXHJcbiAgICAgICAgICAgIHRvdGFsU2l6ZSA9IDA7XHJcblxyXG4gICAgICAgIGxpbSA9IGxpbSB8fCBkYXRhLmJ5dGVMZW5ndGggLSAxODtcclxuXHJcbiAgICAgICAgd2hpbGUgKHB0clswXSA8IGxpbSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgcHRyWzBdLCAxOCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgeGxlbiA9IChiYVsxMV0gPDwgOCkgfCAoYmFbMTBdKTtcclxuICAgICAgICAgICAgdmFyIHNpMSA9IGJhWzEyXTtcclxuICAgICAgICAgICAgdmFyIHNpMiA9IGJhWzEzXTtcclxuICAgICAgICAgICAgdmFyIHNsZW4gPSAoYmFbMTVdIDw8IDgpIHwgKGJhWzE0XSk7XHJcbiAgICAgICAgICAgIHZhciBic2l6ZSA9IChiYVsxN10gPDwgOCkgfCAoYmFbMTZdKSArIDE7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSAxMiArIHhsZW4gKyBwdHJbMF07ICAgIC8vIFN0YXJ0IG9mIENEQVRBXHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGggLSBzdGFydDtcclxuXHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPCAoYnNpemUgKyA4KSkgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB2YXIgdW5jID0ganN6bGliX2luZmxhdGVfYnVmZmVyKGRhdGEsIHN0YXJ0LCBsZW5ndGgsIHB0cik7XHJcblxyXG4gICAgICAgICAgICBwdHJbMF0gKz0gODsgICAgLy8gU2tpcHBpbmcgQ1JDLTMyIGFuZCBzaXplIG9mIHVuY29tcHJlc3NlZCBkYXRhXHJcblxyXG4gICAgICAgICAgICB0b3RhbFNpemUgKz0gdW5jLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgIG9CbG9ja0xpc3QucHVzaCh1bmMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29uY2F0ZW5hdGUgZGVjb21wcmVzc2VkIGJsb2Nrc1xyXG4gICAgICAgIGlmIChvQmxvY2tMaXN0Lmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvQmxvY2tMaXN0WzBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSh0b3RhbFNpemUpO1xyXG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvQmxvY2tMaXN0Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KG9CbG9ja0xpc3RbaV0pO1xyXG4gICAgICAgICAgICAgICAgYXJyYXlDb3B5KGIsIDAsIG91dCwgY3Vyc29yLCBiLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBjdXJzb3IgKz0gYi5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG91dC5idWZmZXI7XHJcbiAgICAgICAgfVxyXG59XHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQge2lndnhocix1bmJnemZ9O1xyXG5cclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FvQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/igvxhr.js\n");

/***/ }),

/***/ "./src/node/image_gen.js":
/*!*******************************!*\
  !*** ./src/node/image_gen.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.MLVImageGen = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _tracks = __webpack_require__(/*! ../tracks.js */ \"./src/tracks.js\");\n\nvar _canvas = __webpack_require__(/*! canvas */ \"canvas\");\n\nvar _canvas2 = _interopRequireDefault(_canvas);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar fs = __webpack_require__(/*! fs */ \"fs\");\n\nvar MLVImageGen = function () {\n    function MLVImageGen(tracks, config) {\n        _classCallCheck(this, MLVImageGen);\n\n        if (!config) {\n            this.config = config = {};\n        } else {\n            this.config = config;\n        }\n        this.config.height = this.config.height ? this.config.height : 200;\n        this.config.width = this.config.width ? this.config.width : 300;\n        console.log(this.config.width);\n        this.canvas = _canvas2.default.createCanvas(300, 200, \"\");\n        this.ctx = this.canvas.getContext('2d');\n        console.log(\"ddddddddddd\");\n        this.tracks = {};\n        this.track_order = [];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = tracks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var t_config = _step.value;\n\n                var track = _tracks.MLVTrack.getTrack(t_config);\n                this.tracks[track.config.track_id] = track;\n                this.track_order.push(track.config.track_id);\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        this.index = 0;\n    }\n\n    _createClass(MLVImageGen, [{\n        key: \"drawImages\",\n        value: function drawImages() {\n            console.log(this.index);\n            var loc = this.config.locations;\n            if (this.index < loc.length) {\n                var info = loc[this.index];\n                this.drawImage(info[0], info[1], info[2], info[3]);\n            }\n        }\n    }, {\n        key: \"drawImage\",\n        value: function drawImage(chr, start, end, file) {\n            console.log(file);\n            var bpPerPixel = (end - start) / this.config.width;\n            var self = this;\n            this.getAllFeatures(chr, start, end, { pixelWidth: this.config.width, bpPerPixel: bpPerPixel }).then(function (all_features) {\n                console.log(\"going to clear canvas\");\n                if (all_features) {\n                    var options = {\n                        context: self.ctx,\n                        bpStart: start,\n                        bpPerPixel: bpPerPixel,\n                        pixelWidth: self.config.width,\n                        pixelHeight: self.config.height\n                    };\n                    var top = 0;\n                    self.groups = {};\n\n                    self.ctx.clearRect(0, 0, self.config.width, self.config.height);\n                    console.log(\"clear canvas\");\n                    for (var i in all_features) {\n                        var track = self.tracks[self.track_order[i]];\n                        options.features = all_features[i];\n                        var group = track.config.group;\n                        if (group) {\n                            if (!self.groups[group]) {\n                                self.groups[group] = { top: top, height: track.config.height };\n                            }\n                            options.top = self.groups[group].top;\n                            options.height = self.groups[group].height;\n                        } else {\n                            options.top = top;\n                        }\n                        var offset = track.drawFeatures(options);\n                        if (offset) {\n                            top = offset;\n                        }\n                        /*if (self.show_scale){\r\n                        \ttrack.drawScale(options.pixelHeight,self.scale_ctx)\r\n                        }*/\n                    }\n                    /*for (let name in self.highlighted_regions){\r\n                    \tlet region = self.highlighted_regions[name];\r\n                    \tif (self.chr !== region.chr){\r\n                    \t\tcontinue;\r\n                    \t}\r\n                    \tif (region.end<bpStart ||region.start>bpEnd){\r\n                    \t\tcontinue\r\n                    \t}\r\n                    \tself.drawHighlightedRegion(region,options);\r\n                    }*/\n                }\n                console.log(\"creating stream\");\n                //const out = fs.createWriteStream(file)\n                console.log(\"drawing \" + file);\n                //const stream = self.canvas.createPNGStream()\n                fs.writeFileSync(file, self.canvas.toBuffer());\n                //stream.pipe(out)\n                self.index++;\n                self.drawImages();\n            }).catch(function (error) {\n                console.log(error);\n                self.index++;\n                self.drawImages();\n            });\n        }\n    }, {\n        key: \"getAllFeatures\",\n        value: function getAllFeatures(chr, bpStart, bpEnd, data) {\n            var promises = [];\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this.track_order[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var track_id = _step2.value;\n\n                    var track = this.tracks[track_id];\n                    promises.push(track.getFeatures(chr, bpStart, bpEnd, false, data));\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            return Promise.all(promises);\n        }\n    }]);\n\n    return MLVImageGen;\n}();\n\nexports.MLVImageGen = MLVImageGen;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbm9kZS9pbWFnZV9nZW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL25vZGUvaW1hZ2VfZ2VuLmpzPzljZDYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XHJcbmltcG9ydCB7TUxWVHJhY2ssUnVsZXJUcmFja30gZnJvbSBcIi4uL3RyYWNrcy5qc1wiO1xyXG5pbXBvcnQgQ2FudmFzIGZyb20gXCJjYW52YXNcIjtcclxuXHJcbmNsYXNzIE1MVkltYWdlR2VuIHtcclxuICAgY29uc3RydWN0b3IgKHRyYWNrcyxjb25maWcpIHtcclxuXHRcdGlmICghY29uZmlnKXtcclxuXHRcdFx0dGhpcy5jb25maWcgPWNvbmZpZz17fTtcclxuXHRcdH1cclxuXHRcdGVsc2V7XHJcblx0XHRcdHRoaXMuY29uZmlnPWNvbmZpZztcclxuXHRcdH1cclxuXHRcdHRoaXMuY29uZmlnLmhlaWdodD10aGlzLmNvbmZpZy5oZWlnaHQ/dGhpcy5jb25maWcuaGVpZ2h0OjIwMDtcclxuXHRcdHRoaXMuY29uZmlnLndpZHRoPXRoaXMuY29uZmlnLndpZHRoP3RoaXMuY29uZmlnLndpZHRoOjMwMDtcclxuXHRcdGNvbnNvbGUubG9nKHRoaXMuY29uZmlnLndpZHRoKVxyXG4gICAgICAgIFx0dGhpcy5jYW52YXM9Q2FudmFzLmNyZWF0ZUNhbnZhcygzMDAsMjAwLFwiXCIpO1xyXG4gICAgICAgICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsgICAgICAgICBcclxuICAgICAgICAgICBjb25zb2xlLmxvZyhcImRkZGRkZGRkZGRkXCIpO1xyXG5cdFx0dGhpcy50cmFja3M9e307XHJcblx0XHR0aGlzLnRyYWNrX29yZGVyPVtdO1xyXG5cdFx0Zm9yIChsZXQgdF9jb25maWcgb2YgdHJhY2tzKXtcclxuXHRcdFx0bGV0IHRyYWNrPU1MVlRyYWNrLmdldFRyYWNrKHRfY29uZmlnKTtcclxuXHRcdFx0dGhpcy50cmFja3NbdHJhY2suY29uZmlnLnRyYWNrX2lkXT10cmFjaztcclxuXHRcdFx0dGhpcy50cmFja19vcmRlci5wdXNoKHRyYWNrLmNvbmZpZy50cmFja19pZCk7XHJcblx0XHR9XHJcbiAgXHJcbiAgICAgICBcdHRoaXMuaW5kZXg9MDtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIGRyYXdJbWFnZXMoKXtcclxuXHRcdGNvbnNvbGUubG9nKHRoaXMuaW5kZXgpO1xyXG5cdFx0bGV0IGxvYyA9IHRoaXMuY29uZmlnLmxvY2F0aW9uc1xyXG5cdFx0aWYgKHRoaXMuaW5kZXg8bG9jLmxlbmd0aCl7XHJcblx0XHRcdGxldCBpbmZvPWxvY1t0aGlzLmluZGV4XVxyXG5cdFx0XHR0aGlzLmRyYXdJbWFnZShpbmZvWzBdLGluZm9bMV0saW5mb1syXSxpbmZvWzNdKTtcclxuXHRcdH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgXHJcblx0XHJcbiAgICBkcmF3SW1hZ2UoY2hyLHN0YXJ0LGVuZCxmaWxlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZmlsZSk7XHJcbiAgICAgICAgbGV0IGJwUGVyUGl4ZWw9KGVuZC1zdGFydCkvdGhpcy5jb25maWcud2lkdGg7XHJcblx0ICAgbGV0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZ2V0QWxsRmVhdHVyZXMoY2hyLCBzdGFydCwgZW5kLHtwaXhlbFdpZHRoOnRoaXMuY29uZmlnLndpZHRoLGJwUGVyUGl4ZWw6YnBQZXJQaXhlbH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYWxsX2ZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImdvaW5nIHRvIGNsZWFyIGNhbnZhc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsX2ZlYXR1cmVzKSB7ICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHNlbGYuY3R4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJwU3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJwUGVyUGl4ZWw6IGJwUGVyUGl4ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxXaWR0aDpzZWxmLmNvbmZpZy53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXhlbEhlaWdodDogc2VsZi5jb25maWcuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9wPTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZ3JvdXBzPXt9O1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdCAgc2VsZi5jdHguY2xlYXJSZWN0KDAsIDAsIHNlbGYuY29uZmlnLndpZHRoLCBzZWxmLmNvbmZpZy5oZWlnaHQpXHJcblx0XHRcdFx0ICBjb25zb2xlLmxvZyhcImNsZWFyIGNhbnZhc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBhbGxfZmVhdHVyZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdGxldCB0cmFjayA9IHNlbGYudHJhY2tzW3NlbGYudHJhY2tfb3JkZXJbaV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdG9wdGlvbnMuZmVhdHVyZXM9YWxsX2ZlYXR1cmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdGxldCBncm91cCA9IHRyYWNrLmNvbmZpZy5ncm91cFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdGlmIChncm91cCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRpZiAoIXNlbGYuZ3JvdXBzW2dyb3VwXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRcdHNlbGYuZ3JvdXBzW2dyb3VwXT17dG9wOnRvcCxoZWlnaHQ6dHJhY2suY29uZmlnLmhlaWdodH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRcdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRcdG9wdGlvbnMudG9wPXNlbGYuZ3JvdXBzW2dyb3VwXS50b3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRvcHRpb25zLmhlaWdodD1zZWxmLmdyb3Vwc1tncm91cF0uaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRcdG9wdGlvbnMudG9wID10b3BcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0PXRyYWNrLmRyYXdGZWF0dXJlcyhvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIFx0IGlmIChvZmZzZXQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgXHQgIFx0dG9wPW9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qaWYgKHNlbGYuc2hvd19zY2FsZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcdHRyYWNrLmRyYXdTY2FsZShvcHRpb25zLnBpeGVsSGVpZ2h0LHNlbGYuc2NhbGVfY3R4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLypmb3IgKGxldCBuYW1lIGluIHNlbGYuaGlnaGxpZ2h0ZWRfcmVnaW9ucyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0bGV0IHJlZ2lvbiA9IHNlbGYuaGlnaGxpZ2h0ZWRfcmVnaW9uc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRpZiAoc2VsZi5jaHIgIT09IHJlZ2lvbi5jaHIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdFx0Y29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdGlmIChyZWdpb24uZW5kPGJwU3RhcnQgfHxyZWdpb24uc3RhcnQ+YnBFbmQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdFx0Y29udGludWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0c2VsZi5kcmF3SGlnaGxpZ2h0ZWRSZWdpb24ocmVnaW9uLG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9Ki9cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY3JlYXRpbmcgc3RyZWFtXCIpO1xyXG5cdFx0XHQvL2NvbnN0IG91dCA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGZpbGUpXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImRyYXdpbmcgXCIrZmlsZSk7XHJcblx0XHRcdC8vY29uc3Qgc3RyZWFtID0gc2VsZi5jYW52YXMuY3JlYXRlUE5HU3RyZWFtKClcclxuXHRcdFx0ZnMud3JpdGVGaWxlU3luYyhmaWxlLCBzZWxmLmNhbnZhcy50b0J1ZmZlcigpKVxyXG5cdFx0XHQvL3N0cmVhbS5waXBlKG91dClcclxuXHRcdFx0c2VsZi5pbmRleCsrO1xyXG5cdFx0XHRzZWxmLmRyYXdJbWFnZXMoKVxyXG5cclxuXHRcdFx0ICAgIFxyXG5cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG5cdFx0XHQgICAgc2VsZi5pbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZHJhd0ltYWdlcygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgXHR9XHJcblxyXG5cdGdldEFsbEZlYXR1cmVzKGNocixicFN0YXJ0LGJwRW5kLGRhdGEpIHtcclxuICAgICAgXHRsZXQgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICBcdGZvciAobGV0IHRyYWNrX2lkICBvZiB0aGlzLnRyYWNrX29yZGVyKXtcclxuICAgICAgICBcdFx0bGV0IHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tfaWRdO1xyXG4gICAgICAgIFx0XHRwcm9taXNlcy5wdXNoKHRyYWNrLmdldEZlYXR1cmVzKGNocixicFN0YXJ0LGJwRW5kLGZhbHNlLGRhdGEpKTsgICAgICAgXHJcbiAgICAgICAgXHR9XHJcblxyXG4gICAgICAgIFx0cmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuXHJcbiAgICAgICAgICAgXHJcbiAgICBcdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7TUxWSW1hZ2VHZW59Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQUhBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQWVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQW9CQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBOzs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBR0E7Ozs7OztBQUlBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/node/image_gen.js\n");

/***/ }),

/***/ "./src/tracks.js":
/*!***********************!*\
  !*** ./src/tracks.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__webpack_provided_$_dot_extend) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Graphics = exports.MLVBigBedTrack = exports.RulerTrack = exports.MLVBedTrack = exports.MLVWigTrack = exports.MLVTrack = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _bigwig = __webpack_require__(/*! ./bigwig.js */ \"./src/bigwig.js\");\n\nvar _feature = __webpack_require__(/*! ./feature.js */ \"./src/feature.js\");\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MLVTrack = function () {\n    function MLVTrack(config) {\n        _classCallCheck(this, MLVTrack);\n\n        this.config = config;\n    }\n\n    _createClass(MLVTrack, [{\n        key: \"_setFeatureSource\",\n        value: function _setFeatureSource() {\n            //overriden by tracks with feature sources\n        }\n    }, {\n        key: \"drawScale\",\n        value: function drawScale(ctx) {\n            //overidden in tracks with scale\n        }\n    }, {\n        key: \"getConfig\",\n        value: function getConfig() {\n            return __webpack_provided_$_dot_extend(true, {}, this.config);\n        }\n    }, {\n        key: \"setConfigAttribute\",\n        value: function setConfigAttribute(attribute, value) {\n            this.config[attribute] = value;\n            if (attribute === \"url\") {\n                this._setFeatureSource();\n            }\n        }\n    }, {\n        key: \"getFeatureAt\",\n        value: function getFeatureAt(genomicLocation, chr, yOffset, bpPerPixel) {\n            return null;\n        }\n    }, {\n        key: \"setConfig\",\n        value: function setConfig(config) {\n            if (this.config.url !== config.url) {\n                this.config = config;\n                this._setFeatureSource();\n            } else {\n                this._setFeatureSource();\n            }\n        }\n    }, {\n        key: \"getFeatures\",\n        value: function getFeatures(chr, bpStart, bpEnd, force, data) {\n            return this.feature_source.getFeatures(chr, bpStart, bpEnd, force, data);\n        }\n    }, {\n        key: \"addExtraControls\",\n        value: function addExtraControls(div, panel) {}\n    }], [{\n        key: \"calculateLabel\",\n        value: function calculateLabel(url) {\n            var arr = url.split(\"/\");\n            var label = arr[arr.length - 1];\n            arr = label.split(\".\");\n            label = arr[0];\n            return label;\n        }\n    }, {\n        key: \"parseConfig\",\n        value: function parseConfig(con) {\n            var config = __webpack_provided_$_dot_extend(true, {}, con);\n\n            if ((!config.type || !config.format) && config.url) {\n                if (config.url.endsWith(\"bw\")) {\n                    config.type = \"bigwig\";\n                    config.format = \"wig\";\n                }\n                if (config.url.endsWith(\".bed.gz\")) {\n                    config.type = \"bed\";\n                    config.format = \"feature\";\n                }\n                if (config.url.endsWith(\".bb\") && !config.type) {\n                    config.type = \"bigbed\";\n                    config.format = \"feature\";\n                }\n                if (config.url.endsWith(\".fasta\")) {\n                    config.type = \"fasta\";\n                    config.format = \"sequence\";\n                }\n                if (config.url.endsWith(\".bam\")) {\n                    config.type = \"bam\";\n                    config.format = \"alignment\";\n                }\n            }\n            if (!config.short_label && config.url) {\n                config.short_label = MLVTrack.calculateLabel(config.url);\n            }\n\n            if (!config.track_id) {\n                config.track_id = config.url;\n            }\n\n            if (config.format === \"feature\") {\n                config.displayMode = config.displayMode || \"COLLAPSED\"; // COLLAPSED | EXPANDED | SQUISHED\n                config.labelDisplayMode = \"SLANT\";\n                config.squishedCallHeight = config.squishedCallHeight || 30;\n                config.expandedCallHeight = config.expandedCallHeight || 15;\n                config.featureHeight = config.featureHeight || 12;\n            }\n\n            if (config.format === \"wig\") {\n                if (!config.scale) {\n                    config.scale = \"automatic\";\n                }\n                if (!config.min_y) {\n                    config.min_y = 0;\n                }\n                if (!config.maxy_y) {\n                    config.max_y = 100;\n                }\n            }\n            if (config.type === \"bam\") {\n                if (!config.featureHeight) {\n                    config.featureHeight = 12;\n                }\n            }\n\n            if (!config.color) {\n                if (config.type === \"bam\") {\n                    config.color = \"#D3D3D3\";\n                } else {\n                    config.color = \"black\";\n                }\n            }\n            if (!config.opacity) {\n                config.opacity = 1.0;\n            }\n            return config;\n        }\n    }, {\n        key: \"getTrack\",\n        value: function getTrack(config) {\n\n            config = MLVTrack.parseConfig(config);\n\n            if (config.type === \"bigwig\") {\n                return new MLVWigTrack(config);\n            } else if (config.type === \"bed\") {\n                return new MLVBedTrack(config);\n            } else if (config.type === \"ucsc\") {\n                return new UCSCTrack(config);\n            } else if (config.type === \"line\") {\n                return new LineTrack(config);\n            } else if (config.type === \"bigbed\") {\n                return new MLVBigBedTrack(config);\n            } else if (config.type === \"ruler\") {\n                return new RulerTrack(config);\n            } else if (config.type === \"fasta\") {\n                return new SequenceTrack(config);\n            } else {\n\n                var class_type = MLVTrack.custom_tracks[config.type];\n                if (class_type) {\n                    return new class_type(config);\n                }\n            }\n        }\n    }]);\n\n    return MLVTrack;\n}();\n\nMLVTrack.custom_tracks = {};\n\n//*******************js/rulerTrack.js**********************\n\n\nvar RulerTrack = function (_MLVTrack) {\n    _inherits(RulerTrack, _MLVTrack);\n\n    function RulerTrack(config) {\n        _classCallCheck(this, RulerTrack);\n\n        if (!config) {\n            config = { \"track_id\": \"ruler\" + RulerTrack.count, format: \"ruler\", short_label: \"Ruler\" };\n        }\n\n        var _this = _possibleConstructorReturn(this, (RulerTrack.__proto__ || Object.getPrototypeOf(RulerTrack)).call(this, config));\n\n        _this.height = 30;\n        _this.name = \"\";\n\n        _this.disableButtons = true;\n        _this.ignoreTrackMenu = true;\n        _this.order = -Number.MAX_VALUE;\n\n        RulerTrack.count++;\n        return _this;\n    }\n\n    _createClass(RulerTrack, [{\n        key: \"getFeatures\",\n        value: function getFeatures(chr, bpStart, bpEnd) {\n\n            return new Promise(function (fulfill, reject) {\n                fulfill([]);\n            });\n        }\n    }, {\n        key: \"drawFeatures\",\n        value: function drawFeatures(options) {\n\n            var fontStyle,\n                ctx = options.context,\n                range,\n                ts,\n                spacing,\n                nTick,\n                x;\n\n            fontStyle = { textAlign: 'center', font: '10px PT Sans', fillStyle: \"rgba(64, 64, 64, 1)\", strokeStyle: \"rgba(64, 64, 64, 1)\" };\n\n            range = Math.floor(1100 * options.bpPerPixel);\n            ts = RulerTrack.findSpacing(range);\n            spacing = ts.majorTick;\n\n            // Find starting point closest to the current origin\n            nTick = Math.floor(options.bpStart / spacing) - 1;\n            x = 0;\n            var y_pos = options.top + this.height;\n            //canvas.setProperties({textAlign: 'center'});\n            Graphics.setProperties(ctx, fontStyle);\n            while (x < options.pixelWidth) {\n\n                var l = Math.floor(nTick * spacing),\n                    shim = 2;\n\n                x = Math.round((l - 1 - options.bpStart + 0.5) / options.bpPerPixel);\n                var chrPosition = formatNumber(l / ts.unitMultiplier, 0) + \" \" + ts.majorUnit;\n\n                if (nTick % 1 == 0) {\n                    Graphics.fillText(ctx, chrPosition, x, y_pos - 15);\n                }\n\n                Graphics.strokeLine(ctx, x, y_pos - 10, x, y_pos - shim);\n\n                nTick++;\n            }\n            Graphics.strokeLine(ctx, 0, y_pos - shim, options.pixelWidth, y_pos - shim);\n\n            function formatNumber(anynum, decimal) {\n                //decimal  - the number of decimals after the digit from 0 to 3\n                //-- Returns the passed number as a string in the xxx,xxx.xx format.\n                //anynum = eval(obj.value);\n                var divider = 10;\n                switch (decimal) {\n                    case 0:\n                        divider = 1;\n                        break;\n                    case 1:\n                        divider = 10;\n                        break;\n                    case 2:\n                        divider = 100;\n                        break;\n                    default:\n                        //for 3 decimal places\n                        divider = 1000;\n                }\n\n                var workNum = Math.abs(Math.round(anynum * divider) / divider);\n\n                var workStr = \"\" + workNum;\n\n                if (workStr.indexOf(\".\") == -1) {\n                    workStr += \".\";\n                }\n\n                var dStr = workStr.substr(0, workStr.indexOf(\".\"));\n                var dNum = dStr - 0;\n                var pStr = workStr.substr(workStr.indexOf(\".\"));\n\n                while (pStr.length - 1 < decimal) {\n                    pStr += \"0\";\n                }\n\n                if (pStr == '.') pStr = '';\n\n                //--- Adds a comma in the thousands place.\n                if (dNum >= 1000) {\n                    var dLen = dStr.length;\n                    dStr = parseInt(\"\" + dNum / 1000) + \",\" + dStr.substring(dLen - 3, dLen);\n                }\n\n                //-- Adds a comma in the millions place.\n                if (dNum >= 1000000) {\n                    dLen = dStr.length;\n                    dStr = parseInt(\"\" + dNum / 1000000) + \",\" + dStr.substring(dLen - 7, dLen);\n                }\n                var retval = dStr + pStr;\n                //-- Put numbers in parentheses if negative.\n                if (anynum < 0) {\n                    retval = \"(\" + retval + \")\";\n                }\n\n                //You could include a dollar sign in the return value.\n                //retval =  \"$\"+retval\n                return retval;\n            }\n            return y_pos;\n        }\n    }], [{\n        key: \"findSpacing\",\n        value: function findSpacing(maxValue) {\n\n            if (maxValue < 10) {\n                return new TickSpacing(1, \"\", 1);\n            }\n\n            // Now man zeroes?\n            var nZeroes = Math.floor(log10(maxValue));\n            var majorUnit = \"\";\n            var unitMultiplier = 1;\n            if (nZeroes > 9) {\n                majorUnit = \"gb\";\n                unitMultiplier = 1000000000;\n            }\n            if (nZeroes > 6) {\n                majorUnit = \"mb\";\n                unitMultiplier = 1000000;\n            } else if (nZeroes > 3) {\n                majorUnit = \"kb\";\n                unitMultiplier = 1000;\n            }\n\n            var nMajorTicks = maxValue / Math.pow(10, nZeroes - 1);\n            if (nMajorTicks < 25) {\n                return new TickSpacing(Math.pow(10, nZeroes - 1), majorUnit, unitMultiplier);\n            } else {\n                return new TickSpacing(Math.pow(10, nZeroes) / 2, majorUnit, unitMultiplier);\n            }\n\n            function log10(x) {\n                var dn = Math.log(10);\n                return Math.log(x) / dn;\n            }\n        }\n    }]);\n\n    return RulerTrack;\n}(MLVTrack);\n\nRulerTrack.count = 0;\n\nvar TickSpacing = function TickSpacing(majorTick, majorUnit, unitMultiplier) {\n    _classCallCheck(this, TickSpacing);\n\n    this.majorTick = majorTick;\n    this.majorUnit = majorUnit;\n    this.unitMultiplier = unitMultiplier;\n};\n\nvar MLVBedTrack = function (_MLVTrack2) {\n    _inherits(MLVBedTrack, _MLVTrack2);\n\n    function MLVBedTrack(config) {\n        _classCallCheck(this, MLVBedTrack);\n\n        var _this2 = _possibleConstructorReturn(this, (MLVBedTrack.__proto__ || Object.getPrototypeOf(MLVBedTrack)).call(this, config));\n\n        _this2._setFeatureSource();\n        _this2.filter_function = null;\n        _this2.color_function = null;\n\n        return _this2;\n    }\n\n    _createClass(MLVBedTrack, [{\n        key: \"_setFeatureSource\",\n        value: function _setFeatureSource() {\n            this.feature_source = new _feature.FeatureSource(this.config);\n        }\n    }, {\n        key: \"setFilterFunction\",\n        value: function setFilterFunction(func) {\n            this.filter_function = func;\n        }\n    }, {\n        key: \"setColorFunction\",\n        value: function setColorFunction(func) {\n            this.color_function = func;\n        }\n    }, {\n        key: \"getCurrentFeatures\",\n        value: function getCurrentFeatures(chr, start, end) {\n            return this.feature_source.featureCache.queryFeatures(chr, start, end);\n        }\n    }, {\n        key: \"drawFeatures\",\n        value: function drawFeatures(options) {\n            var max_y_val = 0;\n            var track = this,\n                py,\n                featureList = options.features,\n                ctx = options.context,\n                bpPerPixel = options.bpPerPixel,\n                bpStart = options.bpStart,\n                pixelWidth = options.pixelWidth,\n                pixelHeight = options.pixelHeight,\n                offset = 0,\n                bpEnd = bpStart + pixelWidth * bpPerPixel + 1;\n            var top = 0;\n            if (options.top) {\n                top = options.top;\n            }\n            this.top = top;\n            var conf = this.config;\n            var windowX = 0;\n            var windowX1 = windowX + pixelWidth;\n\n            this.config.squishedCallHeight = this.config.featureHeight + 10;\n            this.config.expandedCallHeight = this.config.featureHeight / 2 + 2;\n\n            if (featureList) {\n                var opacity = this.config.opacity ? this.config.opacity : 1;\n                ctx.globalAlpha = opacity;\n\n                for (var gene, i = 0, len = featureList.length; i < len; i++) {\n                    gene = featureList[i];\n                    if (this.filter_function && !this.filter_function(gene)) {\n                        gene._display = false;\n                        continue;\n                    }\n                    gene.display = true;\n                    if (gene.end < bpStart) continue;\n                    if (gene.start > bpEnd) break;\n                    var coord = this.calculateFeatureCoordinates(gene, bpStart, bpPerPixel);\n                    var h = conf.featureHeight;\n                    if (conf.displayMode === \"SQUISHED\" && gene.row != undefined) {\n                        h = conf.featureHeight / 2;\n                        py = conf.expandedCallHeight * gene.row + 2;\n                    } else if (conf.displayMode === \"EXPANDED\" && gene.row != undefined) {\n                        py = conf.squishedCallHeight * gene.row + 5;\n                    } else {\n                        // collapsed\n                        py = 5;\n                    }\n                    py += top;\n                    if (py + h > max_y_val) {\n                        max_y_val = py + h;\n                    }\n                    coord.py = py;\n                    coord.h = h;\n                    var info = { bpPerPixel: bpPerPixel, bpStart: bpStart, pixelWidth: pixelWidth };\n                    if (this.color_function) {\n                        gene.color = this.color_function(gene);\n                    }\n\n                    this.renderFeature(gene, coord, ctx, info);\n                    this.renderFeatureLabel(ctx, gene, coord.px, coord.px1, py, windowX, windowX1);\n                }\n                ctx.globalAlpha = 1;\n            } else {\n                console.log(\"No feature list\");\n            }\n            this.bottom = max_y_val;\n            if (this.config.displayMode === \"COLLAPSED\") {\n                max_y_val += 25;\n            }\n            return max_y_val;\n        }\n\n        /**\r\n           * @param ctx       the canvas 2d context\r\n           * @param feature\r\n           * @param featureX  feature start x-coordinate\r\n           * @param featureX1 feature end x-coordinate\r\n           * @param featureY  feature y-coordinate\r\n           * @param windowX   visible window start x-coordinate\r\n           * @param windowX1  visible window end x-coordinate\r\n           */\n\n    }, {\n        key: \"renderFeatureLabel\",\n        value: function renderFeatureLabel(ctx, feature, featureX, featureX1, featureY, windowX, windowX1) {\n            var info = this.config;\n            var geneColor, geneFontStyle, transform, boxX, boxX1, // label should be centered between these two x-coordinates\n            labelX, labelY, textFitsInBox;\n\n            // feature outside of viewable window\n            if (featureX1 < windowX || featureX > windowX1) {\n                boxX = featureX;\n                boxX1 = featureX1;\n            } else {\n                // center label within visible portion of the feature\n                boxX = Math.max(featureX, windowX);\n                boxX1 = Math.min(featureX1, windowX1);\n            }\n\n            //if (igv.browser.selection && \"genes\" === this.config.type && feature.name !== undefined) {\n            // TODO -- for gtex, figure out a better way to do this\n            //geneColor = igv.browser.selection.colorForGene(feature.name);\n            //  }\n\n            textFitsInBox = boxX1 - boxX > ctx.measureText(feature.name).width;\n            //geneColor=\"black\";\n\n            if ((textFitsInBox || geneColor) && info.displayMode != \"SQUISHED\" && feature.name !== undefined) {\n                geneFontStyle = {\n                    font: '10px PT Sans',\n                    textAlign: 'center',\n                    fillStyle: geneColor || info.color,\n                    strokeStyle: geneColor || info.color\n                };\n\n                if (info.displayMode === \"COLLAPSED\" && info.labelDisplayMode === \"SLANT\") {\n                    transform = { rotate: { angle: 45 } };\n                    delete geneFontStyle.textAlign;\n                }\n\n                labelX = boxX + (boxX1 - boxX) / 2;\n                labelY = getFeatureLabelY(featureY, transform);\n\n                Graphics.fillText(ctx, feature.name, labelX, labelY, geneFontStyle, transform);\n            }\n            function getFeatureLabelY(featureY, transform) {\n                return transform ? featureY + info.featureHeight + 14 : featureY + info.featureHeight + 7;\n            }\n        }\n    }, {\n        key: \"calculateFeatureCoordinates\",\n        value: function calculateFeatureCoordinates(feature, bpStart, xScale) {\n            var px = Math.round((feature.start - bpStart) / xScale),\n                px1 = Math.round((feature.end - bpStart) / xScale),\n                pw = px1 - px;\n\n            if (pw < 3) {\n                pw = 3;\n                px -= 1;\n            }\n\n            return {\n                px: px,\n                px1: px1,\n                pw: pw\n            };\n        }\n\n        /**\r\n            * Renders the feature to the canvas\r\n            * @param feature - The feature itself\r\n            * @param coord An object containing information on where to draw the feature\r\n            * px1,px2 the left and right pixels - pw - the width\r\n            * py the top, h - the height\r\n            * @param ctx - The context to draw the feature\r\n            * @param info - An object containing information about the genomic location\r\n            * bpStart.bpPerPixel and pixelWidth\r\n            * \r\n            */\n\n    }, {\n        key: \"renderFeature\",\n        value: function renderFeature(feature, coord, ctx, info) {\n            var e,\n                x,\n                cy,\n                direction,\n                exon,\n                ePx,\n                ePx1,\n                ePxU,\n                ePw,\n                py2,\n                h2,\n                step = 20,\n                color = this.config.color;\n            if (feature.color) {\n                color = feature.color;\n            }\n\n            ctx.fillStyle = color;\n            ctx.strokeStyle = color;\n\n            cy = coord.py + coord.h / 2;\n            h2 = coord.h / 2;\n            py2 = cy - h2 / 2;\n\n            var exonCount = feature.exons ? feature.exons.length : 0;\n            if (exonCount == 0) {\n                // single-exon transcript\n                ctx.fillRect(coord.px, coord.py, coord.pw, coord.h);\n            } else {\n                // multi-exon transcript\n                coord.px = Math.max(coord.px, 0);\n                coord.px1 = Math.min(coord.px1, info.pixelWidth);\n                Graphics.strokeLine(ctx, coord.px + 1, cy, coord.px1 - 1, cy); // center line for introns\n                direction = feature.strand == '+' ? 1 : -1;\n\n                for (x = coord.px + step / 2; x < coord.px1; x += step) {\n\n                    // draw arrowheads along central line indicating transcribed orientation\n                    Graphics.strokeLine(ctx, x - direction * 2, cy - 2, x, cy);\n                    Graphics.strokeLine(ctx, x - direction * 2, cy + 2, x, cy);\n                }\n                for (e = 0; e < exonCount; e++) {\n                    // draw the exons\n                    exon = feature.exons[e];\n                    ePx = Math.round((exon.start - info.bpStart) / info.bpPerPixel);\n                    ePx1 = Math.round((exon.end - info.bpStart) / info.bpPerPixel);\n                    ePw = Math.max(1, ePx1 - ePx);\n\n                    if (exon.utr) {\n                        ctx.fillRect(ePx, py2, ePw, h2); // Entire exon is UTR\n                    } else {\n                        if (exon.cdStart) {\n                            ePxU = Math.round((exon.cdStart - info.bpStart) / info.bpPerPixel);\n                            ctx.fillRect(ePx, py2, ePxU - ePx, h2); // start is UTR\n                            ePw -= ePxU - ePx;\n                            ePx = ePxU;\n                        }\n                        if (exon.cdEnd) {\n                            ePxU = Math.round((exon.cdEnd - info.bpStart) / info.bpPerPixel);\n                            ctx.fillRect(ePxU, py2, ePx1 - ePxU, h2); // start is UTR\n                            ePw -= ePx1 - ePxU;\n                            ePx1 = ePxU;\n                        }\n\n                        ctx.fillRect(ePx, coord.py, ePw, coord.h);\n\n                        // Arrows\n                        if (ePw > step + 5) {\n                            ctx.fillStyle = \"white\";\n                            ctx.strokeStyle = \"white\";\n                            for (x = ePx + step / 2; x < ePx1; x += step) {\n                                // draw arrowheads along central line indicating transcribed orientation\n                                Graphics.strokeLine(ctx, x - direction * 2, cy - 2, x, cy);\n                                Graphics.strokeLine(ctx, x - direction * 2, cy + 2, x, cy);\n                            }\n                            ctx.fillStyle = color;\n                            ctx.strokeStyle = color;\n                        }\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"getFeatureAt\",\n        value: function getFeatureAt(genomicLocation, chr, coord, bpPerPixel) {\n            var yOffset = coord.y - this.top;\n            // We use the featureCache property rather than method to avoid async load.  If the\n            // feature is not already loaded this won't work,  but the user wouldn't be mousing over it either.\n            if (this.feature_source.featureCache) {\n\n                var tolerance = 2 * bpPerPixel,\n                    // We need some tolerance around genomicLocation, start with +/- 2 pixels\n                featureList = this.feature_source.featureCache.queryFeatures(chr, genomicLocation - tolerance, genomicLocation + tolerance),\n                    row;\n\n                if (this.config.displayMode != \"COLLAPSED\") {\n                    row = Math.floor(this.config.displayMode === \"SQUISHED\" ? yOffset / this.config.expandedCallHeight : yOffset / this.config.squishedCallHeight);\n                }\n\n                if (featureList && featureList.length > 0) {\n\n                    var popupData = [];\n                    var _iteratorNormalCompletion = true;\n                    var _didIteratorError = false;\n                    var _iteratorError = undefined;\n\n                    try {\n                        for (var _iterator = featureList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                            var feature = _step.value;\n\n                            if (feature.end >= genomicLocation - tolerance && feature.start <= genomicLocation + tolerance) {\n\n                                // If row number is specified use it\n                                if (row === undefined || feature.row === undefined || row === feature.row) {\n                                    console.log(feature.name);\n                                    return feature;\n                                }\n                            }\n                        }\n                    } catch (err) {\n                        _didIteratorError = true;\n                        _iteratorError = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion && _iterator.return) {\n                                _iterator.return();\n                            }\n                        } finally {\n                            if (_didIteratorError) {\n                                throw _iteratorError;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return null;\n        }\n    }]);\n\n    return MLVBedTrack;\n}(MLVTrack);\n\nvar MLVBigBedTrack = function (_MLVBedTrack) {\n    _inherits(MLVBigBedTrack, _MLVBedTrack);\n\n    function MLVBigBedTrack(config) {\n        _classCallCheck(this, MLVBigBedTrack);\n\n        return _possibleConstructorReturn(this, (MLVBigBedTrack.__proto__ || Object.getPrototypeOf(MLVBigBedTrack)).call(this, config));\n    }\n\n    _createClass(MLVBigBedTrack, [{\n        key: \"_setFeatureSource\",\n        value: function _setFeatureSource() {\n            this.feature_source = new _feature.BigBedFeatureSource(this.config);\n        }\n    }]);\n\n    return MLVBigBedTrack;\n}(MLVBedTrack);\n\nvar MLVWigTrack = function (_MLVTrack3) {\n    _inherits(MLVWigTrack, _MLVTrack3);\n\n    function MLVWigTrack(config) {\n        _classCallCheck(this, MLVWigTrack);\n\n        var _this4 = _possibleConstructorReturn(this, (MLVWigTrack.__proto__ || Object.getPrototypeOf(MLVWigTrack)).call(this, config));\n\n        _this4._setFeatureSource();\n        return _this4;\n    }\n\n    _createClass(MLVWigTrack, [{\n        key: \"_setFeatureSource\",\n        value: function _setFeatureSource() {\n            this.feature_source = new _bigwig.BWSource(this.config);\n        }\n    }, {\n        key: \"drawScale\",\n        value: function drawScale(pixel_height, ctx) {\n            var bot = pixel_height;\n            var top = 0;\n            if (this.scale_link_to) {\n                return;\n            }\n\n            if (this.config.discrete) {\n                top = this.top;\n                bot = this.bottom;\n            }\n            var range = this.max_y - this.min_y;\n            ctx.clearRect(0, 0, 200, pixel_height);\n            ctx.beginPath();\n            ctx.moveTo(0, top);\n            ctx.lineTo(0, bot);\n            ctx.moveTo(0, top);\n            ctx.lineTo(20, top);\n            ctx.moveTo(0, bot);\n            ctx.lineTo(20, bot);\n            ctx.font = \"12px Arial\";\n            ctx.stroke();\n            ctx.textBaseline = \"top\";\n            ctx.fillText(this.max_y, 20, top);\n            ctx.textBaseline = \"alphabetic\";\n            ctx.fillText(this.min_y, 20, bot);\n        }\n    }, {\n        key: \"drawFeatures\",\n        value: function drawFeatures(options) {\n            var self = this,\n                features = options.features,\n                color = self.config.color,\n                ctx = options.context,\n                bpPerPixel = options.bpPerPixel,\n                bpStart = options.bpStart,\n                pixelWidth = options.pixelWidth,\n                pixelHeight = options.pixelHeight,\n                y_offset = this.config.discrete ? options.top : 0,\n                bpEnd = bpStart + pixelWidth * bpPerPixel + 1,\n                featureValueMinimum = void 0,\n                featureValueMaximum = void 0,\n                featureValueRange = void 0,\n                $dataRangeTrackLabel = void 0,\n                str = void 0,\n                min = void 0,\n                max = void 0;\n            if (this.config.discrete) {\n                if (this.config.group) {\n                    pixelHeight = options.height;\n                } else {\n                    pixelHeight = this.config.height;\n                }\n            }\n\n            if (!color) {\n                color = \"black\";\n            }\n            self.prev_coords = { x: 0, y: 0 };\n\n            if (features) {\n                if (self.scale_link_to) {\n                    var t = self.scale_link_to.config;\n                    if (t) {\n                        self.config.scale = t.scale;\n                        self.max_y = self.scale_link_to.max_y;\n                        self.min_y = self.scale_link_to.min_y;\n                    }\n                } else if (self.max_y === undefined && self.config.scale === \"automatic\" || self.config.scale === \"dynamic\") {\n                    var s = autoscale(features);\n                    self.min_y = s.min;\n                    self.max_y = s.max;\n                } else if (self.config.scale === \"fixed\") {\n                    self.min_y = self.config.min_y;\n                    self.max_y = self.config.max_y;\n                }\n\n                featureValueRange = self.max_y - self.min_y;\n\n                //$dataRangeTrackLabel = $(this.trackView.trackDiv).find('.igv-data-range-track-label');\n                //\n                //min = (Math.floor(track.dataRange.min) === track.dataRange.min) ? track.dataRange.min : track.dataRange.min.toFixed(2);\n                //max = (Math.floor(track.dataRange.max) === track.dataRange.max) ? track.dataRange.max : track.dataRange.max.toFixed(2);\n                //str = '[' + min + ' - ' + max + ']';\n                //\n                //$dataRangeTrackLabel.text(str);\n                var prev_x = 0;\n                var prev_y = 0;\n                ctx.globalAlpha = this.config.opacity ? this.config.opacity : 1;\n                if (self.is_line) {\n                    var y = (1.0 - self.config.value / featureValueRange) * pixelHeight;\n                    Graphics.strokeLine(ctx, 0, y, pixelWidth, y, { \"strokeStyle\": self.config.color, \"lineWidth\": self.config.width ? self.config.width : 1 });\n                } else {\n                    features.forEach(renderFeature);\n                }\n                ctx.globalAlpha = 1;\n            }\n\n            function renderFeature(feature, index, featureList) {\n\n                var yUnitless, heightUnitLess, x, y, width, height, rectEnd, rectBaseline;\n\n                if (feature.end < bpStart) return;\n                if (feature.start > bpEnd) return;\n\n                x = Math.floor((feature.start - bpStart) / bpPerPixel);\n                rectEnd = Math.floor((feature.end - bpStart) / bpPerPixel);\n                width = Math.max(0, rectEnd - x);\n\n                //height = ((feature.value - featureValueMinimum) / featureValueRange) * pixelHeight;\n                //rectBaseline = pixelHeight - height;\n                //canvas.fillRect(rectOrigin, rectBaseline, rectWidth, rectHeight, {fillStyle: track.color});\n\n                if (signsDiffer(self.min_y, self.max_y)) {\n\n                    if (feature.value < 0) {\n                        yUnitless = self.max_y / featureValueRange;\n                        heightUnitLess = -feature.value / featureValueRange;\n                    } else {\n                        yUnitless = (self.max_y - feature.value) / featureValueRange;\n                        heightUnitLess = feature.value / featureValueRange;\n                    }\n                } else if (self.min_y < 0) {\n                    yUnitless = 0;\n                    heightUnitLess = -feature.value / featureValueRange;\n                } else {\n                    yUnitless = 1.0 - (feature.value - self.min_y) / featureValueRange;\n                    heightUnitLess = (feature.value + self.min_y) / featureValueRange;\n                }\n\n                y = yUnitless * pixelHeight + y_offset;\n                y = y < y_offset ? y_offset : y;\n                height = heightUnitLess * pixelHeight;\n                height = height > pixelHeight ? pixelHeight : height;\n\n                //canvas.fillRect(x, yUnitless * pixelHeight, width, heightUnitLess * pixelHeight, { fillStyle: igv.randomRGB(64, 255) });\n                if (self.config.display === 'line') {\n                    if (self.prev_coords.x) {\n                        Graphics.strokeLine(ctx, x, y, self.prev_coords.x, self.prev_coords.y, { \"strokeStyle\": color, \"lineWidth\": 3 });\n                    }\n                    self.prev_coords.x = x;\n                    self.prev_coords.y = y;\n                } else {\n                    Graphics.fillRect(ctx, x, y, width, height, { fillStyle: color });\n                }\n            }\n            function autoscale(features) {\n                var min = 0,\n                    max = -Number.MAX_VALUE;\n\n                features.forEach(function (f) {\n                    min = Math.min(min, f.value);\n                    max = Math.max(max, f.value);\n                });\n\n                return { min: min, max: max };\n            }\n\n            function signsDiffer(a, b) {\n                return a > 0 && b < 0 || a < 0 && b > 0;\n            }\n            this.top = y_offset;\n            this.bottom = y_offset + pixelHeight;\n            if (this.config.discrete) {\n                return this.bottom;\n            } else {\n                this.top = 0;\n                this.bottom = 0;\n            }\n        }\n    }]);\n\n    return MLVWigTrack;\n}(MLVTrack);\n\nvar LineTrack = function (_MLVWigTrack) {\n    _inherits(LineTrack, _MLVWigTrack);\n\n    function LineTrack(config) {\n        _classCallCheck(this, LineTrack);\n\n        var _this5 = _possibleConstructorReturn(this, (LineTrack.__proto__ || Object.getPrototypeOf(LineTrack)).call(this, config));\n\n        _this5.is_line = true;\n        return _this5;\n    }\n\n    _createClass(LineTrack, [{\n        key: \"getFeatures\",\n        value: function getFeatures(chr, bpStart, bpEnd) {\n            return new Promise(function (fulfill, reject) {\n                fulfill([]);\n            });\n        }\n    }]);\n\n    return LineTrack;\n}(MLVWigTrack);\n\nvar SequenceTrack = function (_MLVTrack4) {\n    _inherits(SequenceTrack, _MLVTrack4);\n\n    function SequenceTrack(config) {\n        _classCallCheck(this, SequenceTrack);\n\n        var _this6 = _possibleConstructorReturn(this, (SequenceTrack.__proto__ || Object.getPrototypeOf(SequenceTrack)).call(this, config));\n\n        _this6._setFeatureSource(config);\n        _this6.sequenceType = config.sequenceType || \"dna\";\n        _this6.height = 15;\n        return _this6;\n    }\n\n    _createClass(SequenceTrack, [{\n        key: \"_setFeatureSource\",\n        value: function _setFeatureSource(config) {\n            this.feature_source = new _feature.FastaSequence(config.url);\n        }\n    }, {\n        key: \"getFeatures\",\n        value: function getFeatures(chr, bpStart, bpEnd, force, data) {\n            var self = this;\n            return new Promise(function (fulfill, reject) {\n                if (data.bpPerPixel > 1 /*igv.browser.trackViewportWidthBP() > 30000*/) {\n                        fulfill(null);\n                    } else {\n                    self.feature_source.getSequence(chr, bpStart, bpEnd).then(fulfill).catch(reject);\n                }\n            });\n        }\n    }, {\n        key: \"drawFeatures\",\n        value: function drawFeatures(options) {\n\n            var sequence = options.features,\n                ctx = options.context,\n                bpPerPixel = options.bpPerPixel,\n                bpStart = options.bpStart,\n                pixelWidth = options.pixelWidth,\n                bpEnd = bpStart + pixelWidth * bpPerPixel + 1,\n                len,\n                w,\n                y,\n                pos,\n                offset,\n                b,\n                p0,\n                p1,\n                pc,\n                c;\n\n            var y_pos1 = options.top;\n            var y_pos2 = y_pos1 + 5;\n\n            if (sequence) {\n\n                len = sequence.length;\n                w = 1 / bpPerPixel;\n\n                y = y_pos1 + this.height / 2;\n                for (pos = bpStart; pos <= bpEnd; pos++) {\n\n                    offset = pos - bpStart;\n                    if (offset < len) {\n                        //                            var b = sequence.charAt(offset);\n                        b = sequence[offset];\n                        p0 = Math.floor(offset * w);\n                        p1 = Math.floor((offset + 1) * w);\n                        pc = Math.round((p0 + p1) / 2);\n\n                        if (this.color) {\n                            c = this.color;\n                        } else if (\"dna\" === this.sequenceType) {\n                            c = Graphics.nucleotideColors[b];\n                        } else {\n                            c = \"rgb(0, 0, 150)\";\n                        }\n\n                        if (!c) c = \"gray\";\n\n                        if (bpPerPixel > 0.15) {\n\n                            Graphics.fillRect(ctx, p0, y_pos1, p1 - p0, 10, { fillStyle: c });\n                        } else {\n\n                            Graphics.strokeText(ctx, b, pc, y, {\n                                strokeStyle: c,\n                                font: 'normal 10px Arial',\n                                textAlign: 'center'\n                            });\n                        }\n                    }\n                }\n            }\n            return y_pos1 + 10;\n        }\n    }]);\n\n    return SequenceTrack;\n}(MLVTrack);\n\n//*******js/ifv-canvas.js***********************\n\n\nvar Graphics = function () {\n    function Graphics() {\n        _classCallCheck(this, Graphics);\n    }\n\n    _createClass(Graphics, null, [{\n        key: \"setProperties\",\n        value: function setProperties(ctx, properties) {\n\n            for (var key in properties) {\n                if (properties.hasOwnProperty(key)) {\n                    var value = properties[key];\n                    ctx[key] = value;\n                }\n            }\n        }\n    }, {\n        key: \"strokeLine\",\n        value: function strokeLine(ctx, x1, y1, x2, y2, properties) {\n\n            x1 = Math.floor(x1) + 0.5;\n            y1 = Math.floor(y1) + 0.5;\n            x2 = Math.floor(x2) + 0.5;\n            y2 = Math.floor(y2) + 0.5;\n\n            //log(\"stroke line, prop: \" + properties);\n\n            ctx.save();\n            if (properties) Graphics.setProperties(ctx, properties);\n\n            ctx.beginPath();\n            ctx.moveTo(x1, y1);\n            ctx.lineTo(x2, y2);\n            ctx.stroke();\n            ctx.restore();\n        }\n    }, {\n        key: \"fillRect\",\n        value: function fillRect(ctx, x, y, w, h, properties) {\n\n            var c;\n            x = Math.round(x);\n            y = Math.round(y);\n\n            if (properties) {\n                ctx.save();\n                Graphics.setProperties(ctx, properties);\n            }\n\n            ctx.fillRect(x, y, w, h);\n\n            if (properties) ctx.restore();\n        }\n    }, {\n        key: \"fillPolygon\",\n        value: function fillPolygon(ctx, x, y, properties) {\n            ctx.save();\n            if (properties) Graphics.setProperties(ctx, properties);\n            Graphics.doPath(ctx, x, y);\n            ctx.fill();\n            ctx.restore();\n        }\n    }, {\n        key: \"strokePolygon\",\n        value: function strokePolygon(ctx, x, y, properties) {\n            ctx.save();\n            if (properties) Graphics.setProperties(ctx, properties);\n            Graphics.doPath(ctx, x, y);\n            ctx.stroke();\n            ctx.restore();\n        }\n    }, {\n        key: \"fillText\",\n        value: function fillText(ctx, text, x, y, properties, transforms) {\n\n            if (properties) {\n                ctx.save();\n                Graphics.setProperties(ctx, properties);\n            }\n\n            ctx.save();\n\n            ctx.translate(x, y);\n            if (transforms) {\n\n                for (var transform in transforms) {\n                    var value = transforms[transform];\n\n                    // TODO: Add error checking for robustness\n                    if (transform == 'translate') {\n                        ctx.translate(value['x'], value['y']);\n                    }\n                    if (transform == 'rotate') {\n                        ctx.rotate(value['angle'] * Math.PI / 180);\n                    }\n                }\n            }\n\n            ctx.fillText(text, 0, 0);\n            ctx.restore();\n\n            if (properties) ctx.restore();\n        }\n    }, {\n        key: \"strokeText\",\n        value: function strokeText(ctx, text, x, y, properties, transforms) {\n\n            ctx.save();\n            if (properties) {\n                Graphics.setProperties(ctx, properties);\n            }\n\n            ctx.translate(x, y);\n            if (transforms) {\n\n                for (var transform in transforms) {\n                    var value = transforms[transform];\n\n                    // TODO: Add error checking for robustness\n                    if (transform == 'translate') {\n                        ctx.translate(value['x'], value['y']);\n                    }\n                    if (transform == 'rotate') {\n                        ctx.rotate(value['angle'] * Math.PI / 180);\n                    }\n                }\n            }\n\n            ctx.strokeText(text, 0, 0);\n            ctx.restore();\n        }\n    }, {\n        key: \"strokeCircle\",\n        value: function strokeCircle(ctx, x, y, radius) {\n\n            ctx.beginPath();\n            ctx.arc(x, y, radius, 0, 2 * Math.PI);\n            ctx.stroke();\n        }\n    }, {\n        key: \"fillCircle\",\n        value: function fillCircle(ctx, x, y, radius) {\n\n            ctx.beginPath();\n            ctx.arc(x, y, radius, 0, 2 * Math.PI);\n            ctx.fill();\n        }\n    }, {\n        key: \"drawArrowhead\",\n        value: function drawArrowhead(ctx, x, y, size, lineWidth) {\n\n            ctx.save();\n            if (!size) {\n                size = 5;\n            }\n            if (lineWidth) {\n                ctx.lineWidth = lineWidth;\n            }\n            ctx.beginPath();\n            ctx.moveTo(x, y - size / 2);\n            ctx.lineTo(x, y + size / 2);\n            ctx.lineTo(x + size, y);\n            ctx.lineTo(x, y - size / 2);\n            ctx.closePath();\n            ctx.fill();\n            ctx.restore();\n        }\n    }, {\n        key: \"dashedLine\",\n        value: function dashedLine(ctx, x1, y1, x2, y2, dashLen, properties) {\n            ctx.save();\n            x1 = Math.round(x1);\n            y1 = Math.round(y1);\n            x2 = Math.round(x2);\n            y2 = Math.round(y2);\n            dashLen = Math.round(dashLen);\n            log(\"dashedLine\");\n            if (properties) Graphics.setProperties(ctx, properties);\n\n            if (dashLen == undefined) dashLen = 2;\n            ctx.moveTo(x1, y1);\n\n            var dX = x2 - x1;\n            var dY = y2 - y1;\n            var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\n            var dashX = dX / dashes;\n            var dashY = dY / dashes;\n\n            var q = 0;\n            while (q++ < dashes) {\n                x1 += dashX;\n                y1 += dashY;\n                ctx[q % 2 == 0 ? 'moveTo' : 'lineTo'](x1, y1);\n            }\n            ctx[q % 2 == 0 ? 'moveTo' : 'lineTo'](x2, y2);\n\n            ctx.restore();\n        }\n    }, {\n        key: \"doPath\",\n        value: function doPath(ctx, x, y) {\n\n            var i,\n                len = x.length;\n            for (i = 0; i < len; i++) {\n                x[i] = Math.round(x[i]);\n                y[i] = Math.round(y[i]);\n            }\n\n            ctx.beginPath();\n            ctx.moveTo(x[0], y[0]);\n            for (i = 1; i < len; i++) {\n                ctx.lineTo(x[i], y[i]);\n            }\n            ctx.closePath();\n        }\n    }]);\n\n    return Graphics;\n}();\n\nGraphics.nucleotideColors = {\n    \"A\": \"green\",\n    \"T\": \"red\",\n    \"G\": \"black\",\n    \"C\": \"blue\",\n    \"a\": \"green\",\n    \"t\": \"red\",\n    \"c\": \"black\",\n    \"g\": \"blue\"\n\n};\n\nexports.MLVTrack = MLVTrack;\nexports.MLVWigTrack = MLVWigTrack;\nexports.MLVBedTrack = MLVBedTrack;\nexports.RulerTrack = RulerTrack;\nexports.MLVBigBedTrack = MLVBigBedTrack;\nexports.Graphics = Graphics;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! extend */ \"extend\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdHJhY2tzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy90cmFja3MuanM/M2UzMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IEJyb2FkIEluc3RpdHV0ZVxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xyXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gKiBUSEUgU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuXHJcblxyXG5cclxuaW1wb3J0IHtCV1NvdXJjZX0gZnJvbSBcIi4vYmlnd2lnLmpzXCI7XHJcbmltcG9ydCB7RmVhdHVyZVNvdXJjZSxGYXN0YVNlcXVlbmNlLEJpZ0JlZEZlYXR1cmVTb3VyY2V9IGZyb20gXCIuL2ZlYXR1cmUuanNcIjtcclxuXHJcblxyXG5jbGFzcyBNTFZUcmFja3tcclxuXHRjb25zdHJ1Y3Rvcihjb25maWcpe1xyXG5cdFx0dGhpcy5jb25maWc9Y29uZmlnO1xyXG5cdH1cclxuXHJcblx0X3NldEZlYXR1cmVTb3VyY2UoKXtcclxuXHRcdC8vb3ZlcnJpZGVuIGJ5IHRyYWNrcyB3aXRoIGZlYXR1cmUgc291cmNlc1xyXG5cdH1cclxuXHJcblx0ZHJhd1NjYWxlKGN0eCl7XHJcblx0XHQvL292ZXJpZGRlbiBpbiB0cmFja3Mgd2l0aCBzY2FsZVxyXG5cdH1cclxuXHJcblx0Z2V0Q29uZmlnKCl7XHJcblx0XHRyZXR1cm4gJC5leHRlbmQodHJ1ZSwge30sIHRoaXMuY29uZmlnKTtcclxuXHR9XHJcblxyXG5cdHNldENvbmZpZ0F0dHJpYnV0ZShhdHRyaWJ1dGUsdmFsdWUpe1xyXG5cdFx0dGhpcy5jb25maWdbYXR0cmlidXRlXT12YWx1ZTtcclxuICAgIFx0aWYgKGF0dHJpYnV0ZT09PVwidXJsXCIpe1xyXG4gICAgXHRcdHRoaXMuX3NldEZlYXR1cmVTb3VyY2UoKTtcclxuICAgIFx0fVxyXG4gICAgfVxyXG4gICAgZ2V0RmVhdHVyZUF0KGdlbm9taWNMb2NhdGlvbiwgY2hyLHlPZmZzZXQsIGJwUGVyUGl4ZWwpe1xyXG4gICAgXHRyZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBzZXRDb25maWcoY29uZmlnKXtcclxuICAgIFx0aWYgKHRoaXMuY29uZmlnLnVybCAhPT0gY29uZmlnLnVybCl7XHJcbiAgICBcdFx0dGhpcy5jb25maWc9Y29uZmlnO1xyXG4gICAgXHRcdHRoaXMuX3NldEZlYXR1cmVTb3VyY2UoKTtcclxuICAgIFx0fVxyXG4gICAgXHRlbHNle1xyXG4gICAgXHRcdHRoaXMuX3NldEZlYXR1cmVTb3VyY2UoKTtcclxuICAgIFx0fVxyXG4gICAgfVxyXG5cdFxyXG5cdGdldEZlYXR1cmVzIChjaHIsIGJwU3RhcnQsIGJwRW5kLGZvcmNlLGRhdGEpIHtcclxuXHRcdHJldHVybiB0aGlzLmZlYXR1cmVfc291cmNlLmdldEZlYXR1cmVzKGNocixicFN0YXJ0LGJwRW5kLGZvcmNlLGRhdGEpO1xyXG5cdH1cclxuXHJcblxyXG5cdHN0YXRpYyBjYWxjdWxhdGVMYWJlbCh1cmwpe1xyXG5cdFx0bGV0IGFyciA9dXJsLnNwbGl0KFwiL1wiKTtcclxuXHRcdGxldCBsYWJlbD0gYXJyW2Fyci5sZW5ndGgtMV07XHJcblx0XHRhcnI9IGxhYmVsLnNwbGl0KFwiLlwiKTtcclxuXHRcdGxhYmVsID0gYXJyWzBdO1xyXG5cdFx0cmV0dXJuIGxhYmVsO1xyXG5cdH1cclxuXHJcblx0YWRkRXh0cmFDb250cm9scyhkaXYscGFuZWwpe1xyXG5cdH1cclxuXHJcblx0c3RhdGljIHBhcnNlQ29uZmlnKGNvbil7XHJcblx0XHRsZXQgY29uZmlnID0gJC5leHRlbmQodHJ1ZSwge30sY29uKTtcclxuXHRcdFxyXG5cdFx0aWYgKCghY29uZmlnLnR5cGUgfHwgIWNvbmZpZy5mb3JtYXQpICYmIGNvbmZpZy51cmwpe1xyXG5cdFx0XHRpZiAoY29uZmlnLnVybC5lbmRzV2l0aChcImJ3XCIpKXtcclxuXHRcdFx0XHRjb25maWcudHlwZT1cImJpZ3dpZ1wiO1xyXG5cdFx0XHRcdGNvbmZpZy5mb3JtYXQ9XCJ3aWdcIjtcclxuXHRcdFx0XHRcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoY29uZmlnLnVybC5lbmRzV2l0aChcIi5iZWQuZ3pcIikpe1xyXG5cdFx0XHRcdGNvbmZpZy50eXBlPVwiYmVkXCI7XHJcblx0XHRcdFx0Y29uZmlnLmZvcm1hdD1cImZlYXR1cmVcIlxyXG5cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoY29uZmlnLnVybC5lbmRzV2l0aChcIi5iYlwiKSAmJiAhKGNvbmZpZy50eXBlKSl7XHJcblx0XHRcdFx0Y29uZmlnLnR5cGU9XCJiaWdiZWRcIjtcclxuXHRcdFx0XHRjb25maWcuZm9ybWF0PVwiZmVhdHVyZVwiXHJcblxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChjb25maWcudXJsLmVuZHNXaXRoKFwiLmZhc3RhXCIpKXtcclxuXHRcdFx0XHRjb25maWcudHlwZT1cImZhc3RhXCI7XHJcblx0XHRcdFx0Y29uZmlnLmZvcm1hdD1cInNlcXVlbmNlXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGNvbmZpZy51cmwuZW5kc1dpdGgoXCIuYmFtXCIpKXtcclxuXHRcdFx0XHRjb25maWcudHlwZT1cImJhbVwiO1xyXG5cdFx0XHRcdGNvbmZpZy5mb3JtYXQ9XCJhbGlnbm1lbnRcIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKCFjb25maWcuc2hvcnRfbGFiZWwgJiYgY29uZmlnLnVybCl7XHJcblx0XHRcdGNvbmZpZy5zaG9ydF9sYWJlbD1NTFZUcmFjay5jYWxjdWxhdGVMYWJlbChjb25maWcudXJsKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0aWYgKCFjb25maWcudHJhY2tfaWQpe1xyXG5cdFx0XHRjb25maWcudHJhY2tfaWQ9Y29uZmlnLnVybDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29uZmlnLmZvcm1hdD09PVwiZmVhdHVyZVwiKXtcclxuXHRcdFx0Y29uZmlnLmRpc3BsYXlNb2RlID0gY29uZmlnLmRpc3BsYXlNb2RlIHx8IFwiQ09MTEFQU0VEXCI7ICAgIC8vIENPTExBUFNFRCB8IEVYUEFOREVEIHwgU1FVSVNIRURcclxuICAgICAgICBcdGNvbmZpZy5sYWJlbERpc3BsYXlNb2RlID0gXCJTTEFOVFwiO1xyXG4gICAgICAgIFx0Y29uZmlnLnNxdWlzaGVkQ2FsbEhlaWdodCA9IGNvbmZpZy5zcXVpc2hlZENhbGxIZWlnaHQgfHwgMzA7XHJcbiAgICAgICAgXHRjb25maWcuZXhwYW5kZWRDYWxsSGVpZ2h0ID0gY29uZmlnLmV4cGFuZGVkQ2FsbEhlaWdodCB8fCAxNTtcclxuICAgICAgICBcdGNvbmZpZy5mZWF0dXJlSGVpZ2h0PWNvbmZpZy5mZWF0dXJlSGVpZ2h0IHx8IDEyO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb25maWcuZm9ybWF0PT09XCJ3aWdcIil7XHJcblx0XHRcdGlmICghY29uZmlnLnNjYWxlKXtcclxuXHRcdFx0XHRjb25maWcuc2NhbGU9XCJhdXRvbWF0aWNcIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWNvbmZpZy5taW5feSl7XHJcblx0XHRcdFx0Y29uZmlnLm1pbl95PTA7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFjb25maWcubWF4eV95KXtcclxuXHRcdFx0XHRjb25maWcubWF4X3k9MTAwO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoY29uZmlnLnR5cGU9PT1cImJhbVwiKXtcclxuXHRcdFx0aWYgKCFjb25maWcuZmVhdHVyZUhlaWdodCl7XHJcblx0XHRcdFx0Y29uZmlnLmZlYXR1cmVIZWlnaHQ9MTI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWNvbmZpZy5jb2xvcil7XHJcblx0XHRcdGlmIChjb25maWcudHlwZT09PVwiYmFtXCIpe1xyXG5cdFx0XHRcdGNvbmZpZy5jb2xvcj1cIiNEM0QzRDNcIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNle1xyXG5cdFx0XHRcdGNvbmZpZy5jb2xvcj1cImJsYWNrXCI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmICghY29uZmlnLm9wYWNpdHkpe1xyXG5cdFx0XHRjb25maWcub3BhY2l0eT0xLjA7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY29uZmlnO1xyXG5cdH1cclxuXHJcblxyXG5cdFxyXG5cdHN0YXRpYyBnZXRUcmFjayhjb25maWcpe1xyXG5cclxuXHRcdGNvbmZpZz1NTFZUcmFjay5wYXJzZUNvbmZpZyhjb25maWcpO1xyXG5cdFx0XHJcblx0XHRpZiAoY29uZmlnLnR5cGU9PT1cImJpZ3dpZ1wiKXtcclxuXHRcdFx0cmV0dXJuIG5ldyBNTFZXaWdUcmFjayhjb25maWcpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoY29uZmlnLnR5cGU9PT1cImJlZFwiKXtcclxuXHRcdFx0cmV0dXJuIG5ldyBNTFZCZWRUcmFjayhjb25maWcpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoY29uZmlnLnR5cGU9PT1cInVjc2NcIil7XHJcblx0XHRcdHJldHVybiBuZXcgVUNTQ1RyYWNrKGNvbmZpZyk7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmIChjb25maWcudHlwZT09PVwibGluZVwiKXtcclxuXHRcdFx0cmV0dXJuIG5ldyBMaW5lVHJhY2soY29uZmlnKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKGNvbmZpZy50eXBlPT09XCJiaWdiZWRcIil7XHJcblx0XHRcdHJldHVybiBuZXcgTUxWQmlnQmVkVHJhY2soY29uZmlnKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKGNvbmZpZy50eXBlPT09XCJydWxlclwiKXtcclxuXHRcdFx0cmV0dXJuIG5ldyBSdWxlclRyYWNrKGNvbmZpZyk7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmIChjb25maWcudHlwZT09PVwiZmFzdGFcIil7XHJcblx0XHRcdHJldHVybiBuZXcgU2VxdWVuY2VUcmFjayhjb25maWcpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRlbHNle1xyXG5cdFx0XHRcclxuXHRcdFx0bGV0IGNsYXNzX3R5cGUgPSBNTFZUcmFjay5jdXN0b21fdHJhY2tzW2NvbmZpZy50eXBlXTtcclxuXHRcdFx0aWYgKGNsYXNzX3R5cGUpe1xyXG5cdFx0XHRcdHJldHVybiBuZXcgY2xhc3NfdHlwZShjb25maWcpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHRcdFxyXG59XHJcblxyXG5NTFZUcmFjay5jdXN0b21fdHJhY2tzPXt9O1xyXG5cclxuXHJcblxyXG5cclxuXHJcbi8vKioqKioqKioqKioqKioqKioqKmpzL3J1bGVyVHJhY2suanMqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cclxuY2xhc3MgUnVsZXJUcmFjayBleHRlbmRzIE1MVlRyYWNre1xyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRpZiAoIWNvbmZpZyl7XHJcblx0XHRcdGNvbmZpZz17XCJ0cmFja19pZFwiOlwicnVsZXJcIitSdWxlclRyYWNrLmNvdW50LGZvcm1hdDpcInJ1bGVyXCIsc2hvcnRfbGFiZWw6XCJSdWxlclwifTtcclxuXHRcdH1cclxuXHRcdHN1cGVyKGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAzMFxyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiXCI7XHJcbiAgICAgICBcclxuICAgICAgICB0aGlzLmRpc2FibGVCdXR0b25zID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmlnbm9yZVRyYWNrTWVudSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5vcmRlciA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICBcclxuICAgICAgICBSdWxlclRyYWNrLmNvdW50Kys7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmdWxmaWxsKFtdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3RmVhdHVyZXMob3B0aW9ucykge1xyXG5cclxuICAgICAgICB2YXIgZm9udFN0eWxlLFxyXG4gICAgICAgICAgICBjdHggPSBvcHRpb25zLmNvbnRleHQsXHJcbiAgICAgICAgICAgIHJhbmdlLFxyXG4gICAgICAgICAgICB0cyxcclxuICAgICAgICAgICAgc3BhY2luZyxcclxuICAgICAgICAgICAgblRpY2ssXHJcbiAgICAgICAgICAgIHg7XHJcblxyXG4gICAgICAgIGZvbnRTdHlsZSA9IHsgdGV4dEFsaWduOiAnY2VudGVyJywgZm9udDogJzEwcHggUFQgU2FucycsIGZpbGxTdHlsZTogXCJyZ2JhKDY0LCA2NCwgNjQsIDEpXCIsIHN0cm9rZVN0eWxlOiBcInJnYmEoNjQsIDY0LCA2NCwgMSlcIiB9O1xyXG5cclxuICAgICAgICByYW5nZSA9IE1hdGguZmxvb3IoMTEwMCAqIG9wdGlvbnMuYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgdHMgPSBSdWxlclRyYWNrLmZpbmRTcGFjaW5nKHJhbmdlKTtcclxuICAgICAgICBzcGFjaW5nID0gdHMubWFqb3JUaWNrO1xyXG5cclxuICAgICAgICAvLyBGaW5kIHN0YXJ0aW5nIHBvaW50IGNsb3Nlc3QgdG8gdGhlIGN1cnJlbnQgb3JpZ2luXHJcbiAgICAgICAgblRpY2sgPSBNYXRoLmZsb29yKG9wdGlvbnMuYnBTdGFydCAvIHNwYWNpbmcpIC0gMTtcclxuICAgICAgICB4ID0gMDtcclxuXHRcdGxldCB5X3Bvcz1vcHRpb25zLnRvcCt0aGlzLmhlaWdodDtcclxuICAgICAgICAvL2NhbnZhcy5zZXRQcm9wZXJ0aWVzKHt0ZXh0QWxpZ246ICdjZW50ZXInfSk7XHJcbiAgICAgICAgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIGZvbnRTdHlsZSApO1xyXG4gICAgICAgIHdoaWxlICh4IDwgb3B0aW9ucy5waXhlbFdpZHRoKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbCA9IE1hdGguZmxvb3IoblRpY2sgKiBzcGFjaW5nKSxcclxuICAgICAgICAgICAgICAgIHNoaW0gPSAyO1xyXG5cclxuICAgICAgICAgICAgeCA9IE1hdGgucm91bmQoKChsIC0gMSkgLSBvcHRpb25zLmJwU3RhcnQgKyAwLjUpIC8gb3B0aW9ucy5icFBlclBpeGVsKTtcclxuICAgICAgICAgICAgdmFyIGNoclBvc2l0aW9uID0gZm9ybWF0TnVtYmVyKGwgLyB0cy51bml0TXVsdGlwbGllciwgMCkgKyBcIiBcIiArIHRzLm1ham9yVW5pdDtcclxuXHJcbiAgICAgICAgICAgIGlmIChuVGljayAlIDEgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3MuZmlsbFRleHQoY3R4LCBjaHJQb3NpdGlvbiwgeCwgeV9wb3MgLSAxNSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEdyYXBoaWNzLnN0cm9rZUxpbmUoY3R4LCB4LCB5X3BvcyAtIDEwLCB4LCB5X3BvcyAtIHNoaW0pO1xyXG5cclxuICAgICAgICAgICAgblRpY2srKztcclxuICAgICAgICB9XHJcbiAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsIDAsIHlfcG9zIC0gc2hpbSwgb3B0aW9ucy5waXhlbFdpZHRoLCB5X3BvcyAtIHNoaW0pO1xyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKGFueW51bSwgZGVjaW1hbCkge1xyXG4gICAgICAgICAgICAvL2RlY2ltYWwgIC0gdGhlIG51bWJlciBvZiBkZWNpbWFscyBhZnRlciB0aGUgZGlnaXQgZnJvbSAwIHRvIDNcclxuICAgICAgICAgICAgLy8tLSBSZXR1cm5zIHRoZSBwYXNzZWQgbnVtYmVyIGFzIGEgc3RyaW5nIGluIHRoZSB4eHgseHh4Lnh4IGZvcm1hdC5cclxuICAgICAgICAgICAgLy9hbnludW0gPSBldmFsKG9iai52YWx1ZSk7XHJcbiAgICAgICAgICAgIHZhciBkaXZpZGVyID0gMTA7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZGVjaW1hbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZXIgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZXIgPSAxMDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBkaXZpZGVyID0gMTAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogICAgICAgLy9mb3IgMyBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZXIgPSAxMDAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgd29ya051bSA9IE1hdGguYWJzKChNYXRoLnJvdW5kKGFueW51bSAqIGRpdmlkZXIpIC8gZGl2aWRlcikpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHdvcmtTdHIgPSBcIlwiICsgd29ya051bVxyXG5cclxuICAgICAgICAgICAgaWYgKHdvcmtTdHIuaW5kZXhPZihcIi5cIikgPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHdvcmtTdHIgKz0gXCIuXCJcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRTdHIgPSB3b3JrU3RyLnN1YnN0cigwLCB3b3JrU3RyLmluZGV4T2YoXCIuXCIpKTtcclxuICAgICAgICAgICAgdmFyIGROdW0gPSBkU3RyIC0gMFxyXG4gICAgICAgICAgICB2YXIgcFN0ciA9IHdvcmtTdHIuc3Vic3RyKHdvcmtTdHIuaW5kZXhPZihcIi5cIikpXHJcblxyXG4gICAgICAgICAgICB3aGlsZSAocFN0ci5sZW5ndGggLSAxIDwgZGVjaW1hbCkge1xyXG4gICAgICAgICAgICAgICAgcFN0ciArPSBcIjBcIlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocFN0ciA9PSAnLicpIHBTdHIgPSAnJztcclxuXHJcbiAgICAgICAgICAgIC8vLS0tIEFkZHMgYSBjb21tYSBpbiB0aGUgdGhvdXNhbmRzIHBsYWNlLlxyXG4gICAgICAgICAgICBpZiAoZE51bSA+PSAxMDAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZExlbiA9IGRTdHIubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICBkU3RyID0gcGFyc2VJbnQoXCJcIiArIChkTnVtIC8gMTAwMCkpICsgXCIsXCIgKyBkU3RyLnN1YnN0cmluZyhkTGVuIC0gMywgZExlbilcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8tLSBBZGRzIGEgY29tbWEgaW4gdGhlIG1pbGxpb25zIHBsYWNlLlxyXG4gICAgICAgICAgICBpZiAoZE51bSA+PSAxMDAwMDAwKSB7XHJcbiAgICAgICAgICAgICAgICBkTGVuID0gZFN0ci5sZW5ndGhcclxuICAgICAgICAgICAgICAgIGRTdHIgPSBwYXJzZUludChcIlwiICsgKGROdW0gLyAxMDAwMDAwKSkgKyBcIixcIiArIGRTdHIuc3Vic3RyaW5nKGRMZW4gLSA3LCBkTGVuKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZXR2YWwgPSBkU3RyICsgcFN0clxyXG4gICAgICAgICAgICAvLy0tIFB1dCBudW1iZXJzIGluIHBhcmVudGhlc2VzIGlmIG5lZ2F0aXZlLlxyXG4gICAgICAgICAgICBpZiAoYW55bnVtIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXCIoXCIgKyByZXR2YWwgKyBcIilcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9Zb3UgY291bGQgaW5jbHVkZSBhIGRvbGxhciBzaWduIGluIHRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICAgICAgICAgIC8vcmV0dmFsID0gIFwiJFwiK3JldHZhbFxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geV9wb3M7XHJcblxyXG5cclxuICAgIH1cclxuICAgIHN0YXRpYyBmaW5kU3BhY2luZyhtYXhWYWx1ZSkge1xyXG5cclxuICAgICAgICBpZiAobWF4VmFsdWUgPCAxMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRpY2tTcGFjaW5nKDEsIFwiXCIsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vIE5vdyBtYW4gemVyb2VzP1xyXG4gICAgICAgIHZhciBuWmVyb2VzID0gTWF0aC5mbG9vcihsb2cxMChtYXhWYWx1ZSkpO1xyXG4gICAgICAgIHZhciBtYWpvclVuaXQgPSBcIlwiO1xyXG4gICAgICAgIHZhciB1bml0TXVsdGlwbGllciA9IDE7XHJcbiAgICAgICAgaWYgKG5aZXJvZXMgPiA5KSB7XHJcbiAgICAgICAgICAgIG1ham9yVW5pdCA9IFwiZ2JcIjtcclxuICAgICAgICAgICAgdW5pdE11bHRpcGxpZXIgPSAxMDAwMDAwMDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoblplcm9lcyA+IDYpIHtcclxuICAgICAgICAgICAgbWFqb3JVbml0ID0gXCJtYlwiO1xyXG4gICAgICAgICAgICB1bml0TXVsdGlwbGllciA9IDEwMDAwMDA7XHJcbiAgICAgICAgfSBlbHNlIGlmIChuWmVyb2VzID4gMykge1xyXG4gICAgICAgICAgICBtYWpvclVuaXQgPSBcImtiXCI7XHJcbiAgICAgICAgICAgIHVuaXRNdWx0aXBsaWVyID0gMTAwMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBuTWFqb3JUaWNrcyA9IG1heFZhbHVlIC8gTWF0aC5wb3coMTAsIG5aZXJvZXMgLSAxKTtcclxuICAgICAgICBpZiAobk1ham9yVGlja3MgPCAyNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRpY2tTcGFjaW5nKE1hdGgucG93KDEwLCBuWmVyb2VzIC0gMSksIG1ham9yVW5pdCwgdW5pdE11bHRpcGxpZXIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGlja1NwYWNpbmcoTWF0aC5wb3coMTAsIG5aZXJvZXMpIC8gMiwgbWFqb3JVbml0LCB1bml0TXVsdGlwbGllcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBsb2cxMCh4KSB7XHJcbiAgICAgICAgICAgIHZhciBkbiA9IE1hdGgubG9nKDEwKTtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gZG47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuUnVsZXJUcmFjay5jb3VudD0wO1xyXG5cclxuY2xhc3MgVGlja1NwYWNpbmd7XHJcblx0Y29uc3RydWN0b3IobWFqb3JUaWNrLCBtYWpvclVuaXQsIHVuaXRNdWx0aXBsaWVyKSB7XHJcbiAgICAgICAgdGhpcy5tYWpvclRpY2sgPSBtYWpvclRpY2s7XHJcbiAgICAgICAgdGhpcy5tYWpvclVuaXQgPSBtYWpvclVuaXQ7XHJcbiAgICAgICAgdGhpcy51bml0TXVsdGlwbGllciA9IHVuaXRNdWx0aXBsaWVyO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuIFxyXG5jbGFzcyBNTFZCZWRUcmFjayBleHRlbmRzIE1MVlRyYWNre1xyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRzdXBlcihjb25maWcpO1xyXG5cdFx0dGhpcy5fc2V0RmVhdHVyZVNvdXJjZSgpO1xyXG5cdFx0dGhpcy5maWx0ZXJfZnVuY3Rpb249bnVsbDtcclxuXHRcdHRoaXMuY29sb3JfZnVuY3Rpb249bnVsbDtcclxuXHRcdFxyXG5cdH1cclxuXHJcblx0X3NldEZlYXR1cmVTb3VyY2UoKXtcclxuXHRcdHRoaXMuZmVhdHVyZV9zb3VyY2U9IG5ldyBGZWF0dXJlU291cmNlKHRoaXMuY29uZmlnKVxyXG5cdH1cclxuXHJcblx0c2V0RmlsdGVyRnVuY3Rpb24oZnVuYyl7XHJcblx0XHR0aGlzLmZpbHRlcl9mdW5jdGlvbj1mdW5jO1xyXG5cdH1cclxuXHRzZXRDb2xvckZ1bmN0aW9uKGZ1bmMpe1xyXG5cdFx0dGhpcy5jb2xvcl9mdW5jdGlvbj1mdW5jO1xyXG5cdH1cclxuXHJcblx0Z2V0Q3VycmVudEZlYXR1cmVzKGNocixzdGFydCxlbmQpe1xyXG5cdFx0cmV0dXJuIHRoaXMuZmVhdHVyZV9zb3VyY2UuZmVhdHVyZUNhY2hlLnF1ZXJ5RmVhdHVyZXMoY2hyLHN0YXJ0LGVuZCk7XHJcblx0fVxyXG5cdFxyXG5cdGRyYXdGZWF0dXJlcyhvcHRpb25zKSB7XHJcblx0XHRsZXQgbWF4X3lfdmFsPTA7XHJcbiAgICAgICAgdmFyIHRyYWNrID0gdGhpcyxcclxuICAgICAgICBcdHB5LFxyXG4gICAgICAgICAgICBmZWF0dXJlTGlzdCA9IG9wdGlvbnMuZmVhdHVyZXMsXHJcbiAgICAgICAgICAgIGN0eCA9IG9wdGlvbnMuY29udGV4dCxcclxuICAgICAgICAgICAgYnBQZXJQaXhlbCA9IG9wdGlvbnMuYnBQZXJQaXhlbCxcclxuICAgICAgICAgICAgYnBTdGFydCA9IG9wdGlvbnMuYnBTdGFydCxcclxuICAgICAgICAgICAgcGl4ZWxXaWR0aCA9IG9wdGlvbnMucGl4ZWxXaWR0aCxcclxuICAgICAgICAgICAgcGl4ZWxIZWlnaHQgPSBvcHRpb25zLnBpeGVsSGVpZ2h0LFxyXG4gICAgICAgICAgICBvZmZzZXQ9MCxcclxuICAgICAgICAgICAgYnBFbmQgPSBicFN0YXJ0ICsgcGl4ZWxXaWR0aCAqIGJwUGVyUGl4ZWwgKyAxO1xyXG5cdCBcdGxldCB0b3A9MDtcclxuICAgICAgIFx0aWYob3B0aW9ucy50b3Ape1xyXG4gICAgICAgICAgIHRvcD1vcHRpb25zLnRvcDtcclxuICAgICAgIFx0fVxyXG4gICAgICAgXHR0aGlzLnRvcD10b3A7XHJcbiAgICAgICAgbGV0IGNvbmYgPSB0aGlzLmNvbmZpZztcclxuICAgICAgICBsZXQgd2luZG93WCA9IDA7XHJcbiAgICAgICAgbGV0IHdpbmRvd1gxID0gd2luZG93WCArIHBpeGVsV2lkdGg7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZmlnLnNxdWlzaGVkQ2FsbEhlaWdodCA9IHRoaXMuY29uZmlnLmZlYXR1cmVIZWlnaHQrMTA7XHJcbiAgICAgICAgdGhpcy5jb25maWcuZXhwYW5kZWRDYWxsSGVpZ2h0ID0gKHRoaXMuY29uZmlnLmZlYXR1cmVIZWlnaHQvMikrMjtcclxuXHJcblxyXG5cclxuICAgICAgICBpZiAoZmVhdHVyZUxpc3QpIHtcclxuICAgICAgICBcdGxldCBvcGFjaXR5ID0gdGhpcy5jb25maWcub3BhY2l0eT90aGlzLmNvbmZpZy5vcGFjaXR5OjE7XHJcbiAgICAgICAgXHRjdHguZ2xvYmFsQWxwaGE9b3BhY2l0eTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGdlbmUsIGkgPSAwLCBsZW4gPSBmZWF0dXJlTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZ2VuZSA9IGZlYXR1cmVMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyX2Z1bmN0aW9uICYmICF0aGlzLmZpbHRlcl9mdW5jdGlvbihnZW5lKSl7XHJcbiAgICAgICAgICAgICAgICBcdGdlbmUuX2Rpc3BsYXk9ZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBcdGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZ2VuZS5kaXNwbGF5PXRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZS5lbmQgPCBicFN0YXJ0KSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGlmIChnZW5lLnN0YXJ0ID4gYnBFbmQpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvb3JkID0gdGhpcy5jYWxjdWxhdGVGZWF0dXJlQ29vcmRpbmF0ZXMoZ2VuZSwgYnBTdGFydCxicFBlclBpeGVsKTtcclxuICAgICAgICAgICAgICAgIGxldCBoID0gY29uZi5mZWF0dXJlSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZi5kaXNwbGF5TW9kZSA9PT0gXCJTUVVJU0hFRFwiICYmIGdlbmUucm93ICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBcdFx0aCA9IGNvbmYuZmVhdHVyZUhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIFx0XHRweSA9IGNvbmYuZXhwYW5kZWRDYWxsSGVpZ2h0ICogZ2VuZS5yb3cgKyAyO1xyXG4gICAgICAgIFx0XHR9IGVsc2UgaWYgKGNvbmYuZGlzcGxheU1vZGUgPT09IFwiRVhQQU5ERURcIiAmJiBnZW5lLnJvdyAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgXHRcdHB5ID0gY29uZi5zcXVpc2hlZENhbGxIZWlnaHQgKiBnZW5lLnJvdyArIDU7XHJcbiAgICAgICAgXHRcdH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAvLyBjb2xsYXBzZWRcclxuICAgICAgICAgICBcdFx0XHQgcHkgPSA1O1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdHB5Kz10b3A7XHJcbiAgICAgICAgXHRcdGlmIChweStoPm1heF95X3ZhbCl7XHJcbiAgICAgICAgXHRcdFx0bWF4X3lfdmFsPXB5K2g7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0Y29vcmQucHk9cHk7XHJcbiAgICAgICAgXHRcdGNvb3JkLmg9aDtcclxuICAgICAgICBcdFx0bGV0IGluZm89e2JwUGVyUGl4ZWw6YnBQZXJQaXhlbCxicFN0YXJ0OmJwU3RhcnQscGl4ZWxXaWR0aDpwaXhlbFdpZHRofVxyXG4gICAgICAgIFx0XHRpZiAodGhpcy5jb2xvcl9mdW5jdGlvbil7XHJcbiAgICAgICAgXHRcdFx0Z2VuZS5jb2xvcj10aGlzLmNvbG9yX2Z1bmN0aW9uKGdlbmUpO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdFxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmVhdHVyZShnZW5lLGNvb3JkLGN0eCxpbmZvKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmVhdHVyZUxhYmVsKGN0eCwgZ2VuZSwgY29vcmQucHgsIGNvb3JkLnB4MSwgcHksIHdpbmRvd1gsIHdpbmRvd1gxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGE9MTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gZmVhdHVyZSBsaXN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJvdHRvbT1tYXhfeV92YWw7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmRpc3BsYXlNb2RlPT09XCJDT0xMQVBTRURcIil7XHJcbiAgICAgICAgXHRtYXhfeV92YWwrPTI1O1xyXG4gICAgICAgIH1cdFxyXG4gICAgXHRyZXR1cm4gbWF4X3lfdmFsO1xyXG4gICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgICAgIFxyXG5cclxuICAgIFxyXG4gIFxyXG5cdCAvKipcclxuICAgICAqIEBwYXJhbSBjdHggICAgICAgdGhlIGNhbnZhcyAyZCBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gZmVhdHVyZVxyXG4gICAgICogQHBhcmFtIGZlYXR1cmVYICBmZWF0dXJlIHN0YXJ0IHgtY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIGZlYXR1cmVYMSBmZWF0dXJlIGVuZCB4LWNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSBmZWF0dXJlWSAgZmVhdHVyZSB5LWNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB3aW5kb3dYICAgdmlzaWJsZSB3aW5kb3cgc3RhcnQgeC1jb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0gd2luZG93WDEgIHZpc2libGUgd2luZG93IGVuZCB4LWNvb3JkaW5hdGVcclxuICAgICAqL1xyXG4gIFxyXG5cclxuXHJcblxyXG5cdHJlbmRlckZlYXR1cmVMYWJlbChjdHgsIGZlYXR1cmUsIGZlYXR1cmVYLCBmZWF0dXJlWDEsIGZlYXR1cmVZLCB3aW5kb3dYLCB3aW5kb3dYMSkge1xyXG5cdFx0bGV0IGluZm8gPSB0aGlzLmNvbmZpZztcclxuICAgICAgICB2YXIgZ2VuZUNvbG9yLCBnZW5lRm9udFN0eWxlLCB0cmFuc2Zvcm0sXHJcbiAgICAgICAgICAgIGJveFgsIGJveFgxLCAgICAvLyBsYWJlbCBzaG91bGQgYmUgY2VudGVyZWQgYmV0d2VlbiB0aGVzZSB0d28geC1jb29yZGluYXRlc1xyXG4gICAgICAgICAgICBsYWJlbFgsIGxhYmVsWSxcclxuICAgICAgICAgICAgdGV4dEZpdHNJbkJveDtcclxuXHJcbiAgICAgICAgLy8gZmVhdHVyZSBvdXRzaWRlIG9mIHZpZXdhYmxlIHdpbmRvd1xyXG4gICAgICAgIGlmIChmZWF0dXJlWDEgPCB3aW5kb3dYIHx8IGZlYXR1cmVYID4gd2luZG93WDEpIHtcclxuICAgICAgICAgICAgYm94WCA9IGZlYXR1cmVYO1xyXG4gICAgICAgICAgICBib3hYMSA9IGZlYXR1cmVYMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBjZW50ZXIgbGFiZWwgd2l0aGluIHZpc2libGUgcG9ydGlvbiBvZiB0aGUgZmVhdHVyZVxyXG4gICAgICAgICAgICBib3hYID0gTWF0aC5tYXgoZmVhdHVyZVgsIHdpbmRvd1gpO1xyXG4gICAgICAgICAgICBib3hYMSA9IE1hdGgubWluKGZlYXR1cmVYMSwgd2luZG93WDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgIFxyXG5cclxuICAgICAgICAvL2lmIChpZ3YuYnJvd3Nlci5zZWxlY3Rpb24gJiYgXCJnZW5lc1wiID09PSB0aGlzLmNvbmZpZy50eXBlICYmIGZlYXR1cmUubmFtZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gLS0gZm9yIGd0ZXgsIGZpZ3VyZSBvdXQgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXNcclxuICAgICAgICAgICAgLy9nZW5lQ29sb3IgPSBpZ3YuYnJvd3Nlci5zZWxlY3Rpb24uY29sb3JGb3JHZW5lKGZlYXR1cmUubmFtZSk7XHJcbiAgICAgIC8vICB9XHJcblxyXG4gICAgICAgIHRleHRGaXRzSW5Cb3ggPSAoYm94WDEgLSBib3hYKSA+IGN0eC5tZWFzdXJlVGV4dChmZWF0dXJlLm5hbWUpLndpZHRoO1xyXG4gICAgICAgIC8vZ2VuZUNvbG9yPVwiYmxhY2tcIjtcclxuXHJcbiAgICAgICAgaWYgKCh0ZXh0Rml0c0luQm94IHx8IGdlbmVDb2xvcikgJiYgaW5mby5kaXNwbGF5TW9kZSAhPSBcIlNRVUlTSEVEXCIgJiYgZmVhdHVyZS5uYW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZ2VuZUZvbnRTdHlsZSA9IHtcclxuICAgICAgICAgICAgICAgIGZvbnQ6ICcxMHB4IFBUIFNhbnMnLFxyXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogZ2VuZUNvbG9yIHx8IGluZm8uY29sb3IsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogZ2VuZUNvbG9yIHx8IGluZm8uY29sb3JcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpbmZvLmRpc3BsYXlNb2RlID09PSBcIkNPTExBUFNFRFwiICYmIGluZm8ubGFiZWxEaXNwbGF5TW9kZSA9PT0gXCJTTEFOVFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gPSB7cm90YXRlOiB7YW5nbGU6IDQ1fX07XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZ2VuZUZvbnRTdHlsZS50ZXh0QWxpZ247XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxhYmVsWCA9IGJveFggKyAoKGJveFgxIC0gYm94WCkgLyAyKTtcclxuICAgICAgICAgICAgbGFiZWxZID0gZ2V0RmVhdHVyZUxhYmVsWShmZWF0dXJlWSwgdHJhbnNmb3JtKTtcclxuXHJcbiAgICAgICAgICAgIEdyYXBoaWNzLmZpbGxUZXh0KGN0eCwgZmVhdHVyZS5uYW1lLCBsYWJlbFgsIGxhYmVsWSwgZ2VuZUZvbnRTdHlsZSwgdHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0RmVhdHVyZUxhYmVsWShmZWF0dXJlWSwgdHJhbnNmb3JtKSB7XHJcbiAgICAgICAgXHRyZXR1cm4gdHJhbnNmb3JtID8gZmVhdHVyZVkgKyBpbmZvLmZlYXR1cmVIZWlnaHQrMTQgOiBmZWF0dXJlWSArIGluZm8uZmVhdHVyZUhlaWdodCs3O1xyXG4gICAgXHR9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblx0Y2FsY3VsYXRlRmVhdHVyZUNvb3JkaW5hdGVzKGZlYXR1cmUsIGJwU3RhcnQsIHhTY2FsZSkge1xyXG4gICAgXHR2YXIgcHggPSBNYXRoLnJvdW5kKChmZWF0dXJlLnN0YXJ0IC0gYnBTdGFydCkgLyB4U2NhbGUpLFxyXG4gICAgICAgIHB4MSA9IE1hdGgucm91bmQoKGZlYXR1cmUuZW5kIC0gYnBTdGFydCkgLyB4U2NhbGUpLFxyXG4gICAgICAgIHB3ID0gcHgxIC0gcHg7XHJcblxyXG4gICAgICAgIGlmIChwdyA8IDMpIHtcclxuICAgICAgICBcdHB3ID0gMztcclxuICAgICAgICAgICAgcHggLT0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgXHRweDogcHgsXHJcbiAgICAgICAgICAgIHB4MTogcHgxLFxyXG4gICAgICAgICAgICBwdzogcHdcclxuICAgICAgICB9O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcbiAgICAgKiBSZW5kZXJzIHRoZSBmZWF0dXJlIHRvIHRoZSBjYW52YXNcclxuICAgICAqIEBwYXJhbSBmZWF0dXJlIC0gVGhlIGZlYXR1cmUgaXRzZWxmXHJcbiAgICAgKiBAcGFyYW0gY29vcmQgQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gb24gd2hlcmUgdG8gZHJhdyB0aGUgZmVhdHVyZVxyXG4gICAgICogcHgxLHB4MiB0aGUgbGVmdCBhbmQgcmlnaHQgcGl4ZWxzIC0gcHcgLSB0aGUgd2lkdGhcclxuICAgICAqIHB5IHRoZSB0b3AsIGggLSB0aGUgaGVpZ2h0XHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdG8gZHJhdyB0aGUgZmVhdHVyZVxyXG4gICAgICogQHBhcmFtIGluZm8gLSBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZ2Vub21pYyBsb2NhdGlvblxyXG4gICAgICogYnBTdGFydC5icFBlclBpeGVsIGFuZCBwaXhlbFdpZHRoXHJcbiAgICAgKiBcclxuICAgICAqL1xyXG5cdFxyXG5cdHJlbmRlckZlYXR1cmUoZmVhdHVyZSwgY29vcmQsY3R4LGluZm8pe1xyXG5cdFx0dmFyIGUseCwgY3ksIGRpcmVjdGlvbiwgZXhvbiwgZVB4LCBlUHgxLCBlUHhVLCBlUHcsIHB5MiwgaDIsIFxyXG4gICAgICAgICAgICBzdGVwID0gMjAsXHJcbiAgICAgICAgICAgIGNvbG9yID0gdGhpcy5jb25maWcuY29sb3I7XHJcbiAgICAgICAgaWYgKGZlYXR1cmUuY29sb3IpIHtcclxuICAgICAgICAgICAgY29sb3IgPSBmZWF0dXJlLmNvbG9yO1xyXG4gICAgICAgIH1cclxuICBcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XHJcblxyXG5cclxuICAgICAgICBjeSA9IGNvb3JkLnB5ICsgY29vcmQuaCAvIDI7XHJcbiAgICAgICAgaDIgPSBjb29yZC5oIC8gMjtcclxuICAgICAgICBweTIgPSBjeSAtIGgyIC8gMjtcclxuXHJcblx0XHRsZXQgZXhvbkNvdW50ID0gZmVhdHVyZS5leG9ucyA/IGZlYXR1cmUuZXhvbnMubGVuZ3RoIDogMDtcclxuXHRcdFx0aWYgKGV4b25Db3VudCA9PSAwKSB7XHJcbiAgICAgICAgICAgIFx0Ly8gc2luZ2xlLWV4b24gdHJhbnNjcmlwdFxyXG4gICAgICAgICAgICBcdGN0eC5maWxsUmVjdChjb29yZC5weCwgY29vcmQucHksIGNvb3JkLnB3LCBjb29yZC5oKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAvLyBtdWx0aS1leG9uIHRyYW5zY3JpcHRcclxuICAgICAgICAgICAgY29vcmQucHg9TWF0aC5tYXgoY29vcmQucHgsMCk7XHJcbiAgICAgICAgICAgIGNvb3JkLnB4MT1NYXRoLm1pbihjb29yZC5weDEsaW5mby5waXhlbFdpZHRoKTtcclxuICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsIGNvb3JkLnB4ICsgMSwgY3ksIGNvb3JkLnB4MSAtIDEsIGN5KTsgLy8gY2VudGVyIGxpbmUgZm9yIGludHJvbnNcclxuICAgICAgICAgICAgZGlyZWN0aW9uID0gZmVhdHVyZS5zdHJhbmQgPT0gJysnID8gMSA6IC0xO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICBcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgICBmb3IgKCB4PWNvb3JkLnB4ICsgc3RlcCAvIDI7IHggPCAgY29vcmQucHgxOyB4ICs9IHN0ZXApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBkcmF3IGFycm93aGVhZHMgYWxvbmcgY2VudHJhbCBsaW5lIGluZGljYXRpbmcgdHJhbnNjcmliZWQgb3JpZW50YXRpb25cclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzLnN0cm9rZUxpbmUoY3R4LCB4IC0gZGlyZWN0aW9uICogMiwgY3kgLSAyLCB4LCBjeSk7XHJcbiAgICAgICAgICAgICAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCwgeCAtIGRpcmVjdGlvbiAqIDIsIGN5ICsgMiwgeCwgY3kpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoZSA9IDA7IGUgPCBleG9uQ291bnQ7IGUrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gZHJhdyB0aGUgZXhvbnNcclxuICAgICAgICAgICAgICAgIGV4b24gPSBmZWF0dXJlLmV4b25zW2VdO1xyXG4gICAgICAgICAgICAgICAgZVB4ID0gTWF0aC5yb3VuZCgoZXhvbi5zdGFydCAtIGluZm8uYnBTdGFydCkgLyBpbmZvLmJwUGVyUGl4ZWwpO1xyXG4gICAgICAgICAgICAgICAgZVB4MSA9IE1hdGgucm91bmQoKGV4b24uZW5kIC0gaW5mby5icFN0YXJ0KSAvIGluZm8uYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgICAgICAgICBlUHcgPSBNYXRoLm1heCgxLCBlUHgxIC0gZVB4KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZXhvbi51dHIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoZVB4LCBweTIsIGVQdywgaDIpOyAvLyBFbnRpcmUgZXhvbiBpcyBVVFJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleG9uLmNkU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVB4VSA9IE1hdGgucm91bmQoKGV4b24uY2RTdGFydCAtIGluZm8uYnBTdGFydCkgLyBpbmZvLmJwUGVyUGl4ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoZVB4LCBweTIsIGVQeFUgLSBlUHgsIGgyKTsgLy8gc3RhcnQgaXMgVVRSXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVQdyAtPSAoZVB4VSAtIGVQeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVQeCA9IGVQeFU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhvbi5jZEVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlUHhVID0gTWF0aC5yb3VuZCgoZXhvbi5jZEVuZCAtIGluZm8uYnBTdGFydCkgLyBpbmZvLmJwUGVyUGl4ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoZVB4VSwgcHkyLCBlUHgxIC0gZVB4VSwgaDIpOyAvLyBzdGFydCBpcyBVVFJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVB3IC09IChlUHgxIC0gZVB4VSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVQeDEgPSBlUHhVO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGVQeCwgY29vcmQucHksIGVQdywgY29vcmQuaCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFycm93c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlUHcgPiBzdGVwICsgNSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIndoaXRlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoeCA9IGVQeCArIHN0ZXAgLyAyOyB4IDwgZVB4MTsgeCArPSBzdGVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IGFycm93aGVhZHMgYWxvbmcgY2VudHJhbCBsaW5lIGluZGljYXRpbmcgdHJhbnNjcmliZWQgb3JpZW50YXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzLnN0cm9rZUxpbmUoY3R4LCB4IC0gZGlyZWN0aW9uICogMiwgY3kgLSAyLCB4LCBjeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCwgeCAtIGRpcmVjdGlvbiAqIDIsIGN5ICsgMiwgeCwgY3kpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblx0fVxyXG5cclxuXHRnZXRGZWF0dXJlQXQoZ2Vub21pY0xvY2F0aW9uLCBjaHIsIGNvb3JkLCBicFBlclBpeGVsKSB7XHJcblx0XHRsZXQgeU9mZnNldD1jb29yZC55LXRoaXMudG9wO1xyXG4gICAgICAgIC8vIFdlIHVzZSB0aGUgZmVhdHVyZUNhY2hlIHByb3BlcnR5IHJhdGhlciB0aGFuIG1ldGhvZCB0byBhdm9pZCBhc3luYyBsb2FkLiAgSWYgdGhlXHJcbiAgICAgICAgLy8gZmVhdHVyZSBpcyBub3QgYWxyZWFkeSBsb2FkZWQgdGhpcyB3b24ndCB3b3JrLCAgYnV0IHRoZSB1c2VyIHdvdWxkbid0IGJlIG1vdXNpbmcgb3ZlciBpdCBlaXRoZXIuXHJcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZV9zb3VyY2UuZmVhdHVyZUNhY2hlKSB7XHJcblxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHZhciB0b2xlcmFuY2UgPSAyICogYnBQZXJQaXhlbCwgIC8vIFdlIG5lZWQgc29tZSB0b2xlcmFuY2UgYXJvdW5kIGdlbm9taWNMb2NhdGlvbiwgc3RhcnQgd2l0aCArLy0gMiBwaXhlbHNcclxuICAgICAgICAgICAgICAgIGZlYXR1cmVMaXN0ID0gdGhpcy5mZWF0dXJlX3NvdXJjZS5mZWF0dXJlQ2FjaGUucXVlcnlGZWF0dXJlcyhjaHIsIGdlbm9taWNMb2NhdGlvbiAtIHRvbGVyYW5jZSwgZ2Vub21pY0xvY2F0aW9uICsgdG9sZXJhbmNlKSxcclxuICAgICAgICAgICAgICAgIHJvdztcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5kaXNwbGF5TW9kZSAhPSBcIkNPTExBUFNFRFwiKSB7XHJcbiAgICAgICAgICAgICAgICByb3cgPSAoTWF0aC5mbG9vcikodGhpcy5jb25maWcuZGlzcGxheU1vZGUgPT09IFwiU1FVSVNIRURcIiA/IHlPZmZzZXQgLyB0aGlzLmNvbmZpZy5leHBhbmRlZENhbGxIZWlnaHQgOiB5T2Zmc2V0IC8gdGhpcy5jb25maWcuc3F1aXNoZWRDYWxsSGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChmZWF0dXJlTGlzdCAmJiBmZWF0dXJlTGlzdC5sZW5ndGggPiAwKSB7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwb3B1cERhdGEgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGZlYXR1cmUgb2YgZmVhdHVyZUxpc3Qpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLmVuZCA+PSBnZW5vbWljTG9jYXRpb24gLSB0b2xlcmFuY2UgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5zdGFydCA8PSBnZW5vbWljTG9jYXRpb24gKyB0b2xlcmFuY2UpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHJvdyBudW1iZXIgaXMgc3BlY2lmaWVkIHVzZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93ID09PSB1bmRlZmluZWQgfHwgZmVhdHVyZS5yb3cgPT09IHVuZGVmaW5lZCB8fCByb3cgPT09IGZlYXR1cmUucm93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0Y29uc29sZS5sb2coZmVhdHVyZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcblxyXG59XHJcblxyXG5cclxuY2xhc3MgTUxWQmlnQmVkVHJhY2sgZXh0ZW5kcyBNTFZCZWRUcmFja3tcclxuXHRjb25zdHJ1Y3Rvcihjb25maWcpe1xyXG5cdFx0c3VwZXIoY29uZmlnKTtcclxuXHRcdFxyXG5cdH1cclxuXHRfc2V0RmVhdHVyZVNvdXJjZSgpe1xyXG5cdFx0dGhpcy5mZWF0dXJlX3NvdXJjZT1uZXcgQmlnQmVkRmVhdHVyZVNvdXJjZSh0aGlzLmNvbmZpZyk7XHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIE1MVldpZ1RyYWNrIGV4dGVuZHMgTUxWVHJhY2t7XHJcblx0Y29uc3RydWN0b3IoY29uZmlnKXtcclxuXHRcdHN1cGVyKGNvbmZpZyk7XHJcblx0XHR0aGlzLl9zZXRGZWF0dXJlU291cmNlKCk7XHJcblx0fVxyXG5cclxuXHRfc2V0RmVhdHVyZVNvdXJjZSgpe1xyXG5cdFx0dGhpcy5mZWF0dXJlX3NvdXJjZT1uZXcgQldTb3VyY2UodGhpcy5jb25maWcpO1x0XHJcblx0fVxyXG5cclxuXHJcblx0ZHJhd1NjYWxlKHBpeGVsX2hlaWdodCxjdHgpe1xyXG5cdFx0bGV0IGJvdD0gcGl4ZWxfaGVpZ2h0O1xyXG5cdFx0bGV0IHRvcCA9IDA7XHJcblx0XHRpZiAodGhpcy5zY2FsZV9saW5rX3RvKXtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLmNvbmZpZy5kaXNjcmV0ZSl7XHJcblx0XHRcdHRvcD10aGlzLnRvcDtcclxuXHRcdFx0Ym90ID0gdGhpcy5ib3R0b207XHJcblx0XHR9XHJcblx0XHRsZXQgcmFuZ2U9dGhpcy5tYXhfeS10aGlzLm1pbl95O1xyXG5cdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCAyMDAsIHBpeGVsX2hlaWdodCk7XHJcblx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRjdHgubW92ZVRvKDAsdG9wKTtcclxuXHRcdGN0eC5saW5lVG8oMCxib3QpO1xyXG5cdFx0Y3R4Lm1vdmVUbygwLHRvcCk7XHJcblx0XHRjdHgubGluZVRvKDIwLHRvcCk7XHJcblx0XHRjdHgubW92ZVRvKDAsYm90KTtcclxuXHRcdGN0eC5saW5lVG8oMjAsYm90KTtcclxuXHRcdGN0eC5mb250PVwiMTJweCBBcmlhbFwiO1xyXG5cdFx0Y3R4LnN0cm9rZSgpO1xyXG5cdFx0Y3R4LnRleHRCYXNlbGluZT1cInRvcFwiO1xyXG5cdFx0Y3R4LmZpbGxUZXh0KHRoaXMubWF4X3ksMjAsdG9wKTtcclxuXHRcdGN0eC50ZXh0QmFzZWxpbmU9XCJhbHBoYWJldGljXCI7XHJcblx0XHRjdHguZmlsbFRleHQodGhpcy5taW5feSwyMCxib3QpO1xyXG5cclxuXHR9XHJcblx0XHJcblx0ZHJhd0ZlYXR1cmVzKG9wdGlvbnMpIHtcclxuXHRcdGxldCBzZWxmID0gdGhpcyxcclxuXHQgICAgZmVhdHVyZXMgPSBvcHRpb25zLmZlYXR1cmVzLFxyXG5cdCAgICBjb2xvcj1zZWxmLmNvbmZpZy5jb2xvcixcclxuXHQgICAgY3R4ID0gb3B0aW9ucy5jb250ZXh0LFxyXG5cdCAgICBicFBlclBpeGVsID0gb3B0aW9ucy5icFBlclBpeGVsLFxyXG5cdCAgICBicFN0YXJ0ID0gb3B0aW9ucy5icFN0YXJ0LFxyXG5cdCAgICBwaXhlbFdpZHRoID0gb3B0aW9ucy5waXhlbFdpZHRoLFxyXG5cdCAgICBwaXhlbEhlaWdodCA9b3B0aW9ucy5waXhlbEhlaWdodCxcclxuXHQgICAgeV9vZmZzZXQ9dGhpcy5jb25maWcuZGlzY3JldGU/b3B0aW9ucy50b3A6MCxcclxuXHQgICAgYnBFbmQgPSBicFN0YXJ0ICsgcGl4ZWxXaWR0aCAqIGJwUGVyUGl4ZWwgKyAxLFxyXG5cdCAgICBmZWF0dXJlVmFsdWVNaW5pbXVtLFxyXG5cdCAgICBmZWF0dXJlVmFsdWVNYXhpbXVtLFxyXG5cdCAgICBmZWF0dXJlVmFsdWVSYW5nZSxcclxuXHQgICAgJGRhdGFSYW5nZVRyYWNrTGFiZWwsXHJcblx0ICAgIHN0cixcclxuXHQgICAgbWluLFxyXG5cdCAgICBtYXg7XHJcblx0ICAgIGlmKHRoaXMuY29uZmlnLmRpc2NyZXRlKXtcclxuXHQgICAgXHRpZiAodGhpcy5jb25maWcuZ3JvdXApe1xyXG5cdCAgICBcdFx0cGl4ZWxIZWlnaHQ9b3B0aW9ucy5oZWlnaHQ7XHJcblx0ICAgIFx0fVxyXG5cdCAgICBcdGVsc2V7XHJcblx0ICAgIFx0XHQgcGl4ZWxIZWlnaHQ9dGhpcy5jb25maWcuaGVpZ2h0O1xyXG5cdCAgICBcdH1cclxuXHQgICAgXHRcclxuXHQgICAgfVxyXG5cdCAgICAgICAgICBcclxuXHQgICAgaWYgKCFjb2xvcil7XHJcblx0ICAgIFx0Y29sb3I9XCJibGFja1wiOyAgICAgICBcclxuXHQgICAgfVxyXG5cdCAgICBzZWxmLnByZXZfY29vcmRzPXt4OjAseTowfTtcclxuXHJcblx0ICAgIGlmIChmZWF0dXJlcykge1xyXG5cdCAgICBcdGlmIChzZWxmLnNjYWxlX2xpbmtfdG8pe1xyXG5cdCAgICBcdFx0bGV0IHQgPSBzZWxmLnNjYWxlX2xpbmtfdG8uY29uZmlnO1xyXG5cdCAgICAgICAgICAgIGlmICh0KXtcclxuXHQgICAgICAgICAgICBcdHNlbGYuY29uZmlnLnNjYWxlPXQuc2NhbGU7XHJcblx0ICAgICAgICAgICAgICAgIHNlbGYubWF4X3k9c2VsZi5zY2FsZV9saW5rX3RvLm1heF95O1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLm1pbl95PXNlbGYuc2NhbGVfbGlua190by5taW5feTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgIH1cclxuXHQgICAgICAgZWxzZSBpZiAoIChzZWxmLm1heF95ID09PSB1bmRlZmluZWQgJiYgc2VsZi5jb25maWcuc2NhbGU9PT1cImF1dG9tYXRpY1wiKSB8fCBzZWxmLmNvbmZpZy5zY2FsZT09PVwiZHluYW1pY1wiKXtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHMgPSBhdXRvc2NhbGUoZmVhdHVyZXMpO1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLm1pbl95ID0gcy5taW47XHJcblx0ICAgICAgICAgICAgICAgIHNlbGYubWF4X3kgPSBzLm1heDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5jb25maWcuc2NhbGU9PT1cImZpeGVkXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5taW5feSA9IHNlbGYuY29uZmlnLm1pbl95O1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLm1heF95PXNlbGYuY29uZmlnLm1heF95O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgXHJcblxyXG5cdCAgICAgICAgICAgIGZlYXR1cmVWYWx1ZVJhbmdlID0gc2VsZi5tYXhfeSAtIHNlbGYubWluX3k7XHJcblxyXG5cdCAgICAgICAgICAgIC8vJGRhdGFSYW5nZVRyYWNrTGFiZWwgPSAkKHRoaXMudHJhY2tWaWV3LnRyYWNrRGl2KS5maW5kKCcuaWd2LWRhdGEtcmFuZ2UtdHJhY2stbGFiZWwnKTtcclxuXHQgICAgICAgICAgICAvL1xyXG5cdCAgICAgICAgICAgIC8vbWluID0gKE1hdGguZmxvb3IodHJhY2suZGF0YVJhbmdlLm1pbikgPT09IHRyYWNrLmRhdGFSYW5nZS5taW4pID8gdHJhY2suZGF0YVJhbmdlLm1pbiA6IHRyYWNrLmRhdGFSYW5nZS5taW4udG9GaXhlZCgyKTtcclxuXHQgICAgICAgICAgICAvL21heCA9IChNYXRoLmZsb29yKHRyYWNrLmRhdGFSYW5nZS5tYXgpID09PSB0cmFjay5kYXRhUmFuZ2UubWF4KSA/IHRyYWNrLmRhdGFSYW5nZS5tYXggOiB0cmFjay5kYXRhUmFuZ2UubWF4LnRvRml4ZWQoMik7XHJcblx0ICAgICAgICAgICAgLy9zdHIgPSAnWycgKyBtaW4gKyAnIC0gJyArIG1heCArICddJztcclxuXHQgICAgICAgICAgICAvL1xyXG5cdCAgICAgICAgICAgIC8vJGRhdGFSYW5nZVRyYWNrTGFiZWwudGV4dChzdHIpO1xyXG5cdCAgICAgICAgICAgIGxldCBwcmV2X3g9MDtcclxuXHQgICAgICAgICAgICBsZXQgcHJldl95PTA7XHJcblx0ICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhICAgPSB0aGlzLmNvbmZpZy5vcGFjaXR5P3RoaXMuY29uZmlnLm9wYWNpdHk6MTtcclxuXHQgICAgICAgICAgICBpZiAoc2VsZi5pc19saW5lKXsgIFxyXG5cdCAgICAgICAgICAgICAgICBsZXQgeSA9ICgxLjAgLSBzZWxmLmNvbmZpZy52YWx1ZSAvIGZlYXR1cmVWYWx1ZVJhbmdlKSpwaXhlbEhlaWdodDtcclxuXHQgICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsMCx5LHBpeGVsV2lkdGgseSx7XCJzdHJva2VTdHlsZVwiOnNlbGYuY29uZmlnLmNvbG9yLFwibGluZVdpZHRoXCI6c2VsZi5jb25maWcud2lkdGg/c2VsZi5jb25maWcud2lkdGg6MX0pO1xyXG5cdCAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZXtcclxuXHQgICAgICAgICAgICBcdGZlYXR1cmVzLmZvckVhY2gocmVuZGVyRmVhdHVyZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYT0xXHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAgXHJcblx0ICAgICAgICBmdW5jdGlvbiByZW5kZXJGZWF0dXJlKGZlYXR1cmUsIGluZGV4LCBmZWF0dXJlTGlzdCkge1xyXG5cclxuXHQgICAgICAgICAgICB2YXIgeVVuaXRsZXNzLFxyXG5cdCAgICAgICAgICAgICAgICBoZWlnaHRVbml0TGVzcyxcclxuXHQgICAgICAgICAgICAgICAgeCxcclxuXHQgICAgICAgICAgICAgICAgeSxcclxuXHQgICAgICAgICAgICAgICAgd2lkdGgsXHJcblx0ICAgICAgICAgICAgICAgIGhlaWdodCxcclxuXHQgICAgICAgICAgICAgICAgcmVjdEVuZCxcclxuXHQgICAgICAgICAgICAgICAgcmVjdEJhc2VsaW5lO1xyXG5cclxuXHQgICAgICAgICAgICBpZiAoZmVhdHVyZS5lbmQgPCBicFN0YXJ0KSByZXR1cm47XHJcblx0ICAgICAgICAgICAgaWYgKGZlYXR1cmUuc3RhcnQgPiBicEVuZCkgcmV0dXJuO1xyXG5cclxuXHQgICAgICAgICAgICB4ID0gTWF0aC5mbG9vcigoZmVhdHVyZS5zdGFydCAtIGJwU3RhcnQpIC8gYnBQZXJQaXhlbCk7XHJcblx0ICAgICAgICAgICAgcmVjdEVuZCA9IE1hdGguZmxvb3IoKGZlYXR1cmUuZW5kIC0gYnBTdGFydCkgLyBicFBlclBpeGVsKTtcclxuXHQgICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHJlY3RFbmQgLSB4KTtcclxuXHJcblx0ICAgICAgICAgICAgLy9oZWlnaHQgPSAoKGZlYXR1cmUudmFsdWUgLSBmZWF0dXJlVmFsdWVNaW5pbXVtKSAvIGZlYXR1cmVWYWx1ZVJhbmdlKSAqIHBpeGVsSGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIC8vcmVjdEJhc2VsaW5lID0gcGl4ZWxIZWlnaHQgLSBoZWlnaHQ7XHJcblx0ICAgICAgICAgICAgLy9jYW52YXMuZmlsbFJlY3QocmVjdE9yaWdpbiwgcmVjdEJhc2VsaW5lLCByZWN0V2lkdGgsIHJlY3RIZWlnaHQsIHtmaWxsU3R5bGU6IHRyYWNrLmNvbG9yfSk7XHJcblxyXG5cdCAgICAgICAgICAgIGlmIChzaWduc0RpZmZlcihzZWxmLm1pbl95LCBzZWxmLm1heF95KSkge1xyXG5cclxuXHQgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUudmFsdWUgPCAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB5VW5pdGxlc3MgPSBzZWxmLm1heF95LyBmZWF0dXJlVmFsdWVSYW5nZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGhlaWdodFVuaXRMZXNzID0gLWZlYXR1cmUudmFsdWUgLyBmZWF0dXJlVmFsdWVSYW5nZTtcclxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHlVbml0bGVzcyA9ICgoc2VsZi5tYXhfeSAtIGZlYXR1cmUudmFsdWUpIC8gZmVhdHVyZVZhbHVlUmFuZ2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaGVpZ2h0VW5pdExlc3MgPSBmZWF0dXJlLnZhbHVlIC8gZmVhdHVyZVZhbHVlUmFuZ2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYubWluX3kgPCAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHlVbml0bGVzcyA9IDA7XHJcblx0ICAgICAgICAgICAgICAgIGhlaWdodFVuaXRMZXNzID0gLWZlYXR1cmUudmFsdWUgLyBmZWF0dXJlVmFsdWVSYW5nZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHlVbml0bGVzcyA9IDEuMCAtICgoZmVhdHVyZS52YWx1ZS1zZWxmLm1pbl95KSAvIGZlYXR1cmVWYWx1ZVJhbmdlKTtcclxuXHQgICAgICAgICAgICAgICAgaGVpZ2h0VW5pdExlc3MgPSAoZmVhdHVyZS52YWx1ZStzZWxmLm1pbl95KSAvIGZlYXR1cmVWYWx1ZVJhbmdlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICBcdHkgPSAoeVVuaXRsZXNzKnBpeGVsSGVpZ2h0KSt5X29mZnNldDtcclxuXHQgICAgICAgICAgICB5PXk8eV9vZmZzZXQ/eV9vZmZzZXQ6eTtcclxuXHQgICAgICAgICAgICBoZWlnaHQ9aGVpZ2h0VW5pdExlc3MgKiBwaXhlbEhlaWdodDtcclxuXHQgICAgICAgICAgICBoZWlnaHQ9aGVpZ2h0PnBpeGVsSGVpZ2h0P3BpeGVsSGVpZ2h0OmhlaWdodFxyXG5cclxuXHQgICAgICAgICAgICAvL2NhbnZhcy5maWxsUmVjdCh4LCB5VW5pdGxlc3MgKiBwaXhlbEhlaWdodCwgd2lkdGgsIGhlaWdodFVuaXRMZXNzICogcGl4ZWxIZWlnaHQsIHsgZmlsbFN0eWxlOiBpZ3YucmFuZG9tUkdCKDY0LCAyNTUpIH0pO1xyXG5cdCAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5kaXNwbGF5PT09J2xpbmUnKXtcclxuXHQgICAgICAgICAgICAgICAgIGlmIChzZWxmLnByZXZfY29vcmRzLngpe1xyXG5cdCAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgseCx5LHNlbGYucHJldl9jb29yZHMueCxzZWxmLnByZXZfY29vcmRzLnkse1wic3Ryb2tlU3R5bGVcIjpjb2xvcixcImxpbmVXaWR0aFwiOjN9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgc2VsZi5wcmV2X2Nvb3Jkcy54PXg7XHJcblx0ICAgICAgICAgICAgICAgIHNlbGYucHJldl9jb29yZHMueT15O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNle1xyXG5cdCAgICAgICAgICAgICAgICBHcmFwaGljcy5maWxsUmVjdChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHtmaWxsU3R5bGU6IGNvbG9yfSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgIGZ1bmN0aW9uIGF1dG9zY2FsZShmZWF0dXJlcykge1xyXG4gICAgICAgIHZhciBtaW4gPSAwLFxyXG4gICAgICAgICAgICBtYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuXHJcbiAgICAgICAgZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xyXG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGYudmFsdWUpO1xyXG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGYudmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4ge21pbjogbWluLCBtYXg6IG1heH07XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNpZ25zRGlmZmVyKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gKGEgPiAwICYmIGIgPCAwIHx8IGEgPCAwICYmIGIgPiAwKTtcclxuICAgIH1cclxuICAgIHRoaXMudG9wPXlfb2Zmc2V0O1xyXG4gICAgdGhpcy5ib3R0b209eV9vZmZzZXQrcGl4ZWxIZWlnaHQ7XHJcbiAgICBpZiAodGhpcy5jb25maWcuZGlzY3JldGUpe1xyXG4gICAgXHRyZXR1cm4gdGhpcy5ib3R0b207XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgXHR0aGlzLnRvcD0wO1xyXG4gICAgXHR0aGlzLmJvdHRvbT0wO1xyXG4gICAgfVxyXG5cclxuXHQgICAgXHJcbn1cclxufVxyXG4gY2xhc3MgTGluZVRyYWNrIGV4dGVuZHMgTUxWV2lnVHJhY2t7XHJcblx0IGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHQgc3VwZXIoY29uZmlnKTtcclxuXHRcdCB0aGlzLmlzX2xpbmU9dHJ1ZTtcclxuXHQgfVxyXG5cdCBcclxuXHQgZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCkge1xyXG5cdFx0IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblx0XHRcdCBmdWxmaWxsKFtdKTtcclxuXHQgICAgIH0pO1xyXG5cdCB9XHJcblx0IFxyXG5cdCBcclxuIH1cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIFNlcXVlbmNlVHJhY2sgZXh0ZW5kcyBNTFZUcmFja3tcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRzdXBlcihjb25maWcpIFxyXG4gICAgICAgIHRoaXMuX3NldEZlYXR1cmVTb3VyY2UoY29uZmlnKTtcclxuICAgICAgICB0aGlzLnNlcXVlbmNlVHlwZSA9IGNvbmZpZy5zZXF1ZW5jZVR5cGUgfHwgXCJkbmFcIjsgIFxyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMTU7XHJcbiAgICB9XHJcblxyXG4gICAgX3NldEZlYXR1cmVTb3VyY2UoY29uZmlnKXtcclxuICAgIFx0dGhpcy5mZWF0dXJlX3NvdXJjZSA9IG5ldyBGYXN0YVNlcXVlbmNlKGNvbmZpZy51cmwpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCxmb3JjZSxkYXRhKSB7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEuYnBQZXJQaXhlbCA+IDEvKmlndi5icm93c2VyLnRyYWNrVmlld3BvcnRXaWR0aEJQKCkgPiAzMDAwMCovKSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5mZWF0dXJlX3NvdXJjZS5nZXRTZXF1ZW5jZShjaHIsIGJwU3RhcnQsIGJwRW5kKS50aGVuKGZ1bGZpbGwpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZHJhd0ZlYXR1cmVzKG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlcXVlbmNlID0gb3B0aW9ucy5mZWF0dXJlcyxcclxuICAgICAgICAgICAgY3R4ID0gb3B0aW9ucy5jb250ZXh0LFxyXG4gICAgICAgICAgICBicFBlclBpeGVsID0gb3B0aW9ucy5icFBlclBpeGVsLFxyXG4gICAgICAgICAgICBicFN0YXJ0ID0gb3B0aW9ucy5icFN0YXJ0LFxyXG4gICAgICAgICAgICBwaXhlbFdpZHRoID0gb3B0aW9ucy5waXhlbFdpZHRoLFxyXG4gICAgICAgICAgICBicEVuZCA9IGJwU3RhcnQgKyBwaXhlbFdpZHRoICogYnBQZXJQaXhlbCArIDEsXHJcbiAgICAgICAgICAgIGxlbiwgdywgeSwgcG9zLCBvZmZzZXQsIGIsIHAwLCBwMSwgcGMsIGM7XHJcblxyXG4gICAgICAgIGxldCB5X3BvczE9b3B0aW9ucy50b3A7XHJcbiAgICAgICAgbGV0IHlfcG9zMj15X3BvczErNTtcclxuXHJcbiAgICAgICAgaWYgKHNlcXVlbmNlKSB7XHJcblxyXG4gICAgICAgICAgICBsZW4gPSBzZXF1ZW5jZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHcgPSAxIC8gYnBQZXJQaXhlbDtcclxuXHJcbiAgICAgICAgICAgIHkgPSB5X3BvczErdGhpcy5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICBmb3IgKHBvcyA9IGJwU3RhcnQ7IHBvcyA8PSBicEVuZDsgcG9zKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBwb3MgLSBicFN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IGxlbikge1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHNlcXVlbmNlLmNoYXJBdChvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBzZXF1ZW5jZVtvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHAwID0gTWF0aC5mbG9vcihvZmZzZXQgKiB3KTtcclxuICAgICAgICAgICAgICAgICAgICBwMSA9IE1hdGguZmxvb3IoKG9mZnNldCArIDEpICogdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGMgPSBNYXRoLnJvdW5kKChwMCArIHAxKSAvIDIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy5jb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJkbmFcIiA9PT0gdGhpcy5zZXF1ZW5jZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IEdyYXBoaWNzLm51Y2xlb3RpZGVDb2xvcnNbYl07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gXCJyZ2IoMCwgMCwgMTUwKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjKSBjID0gXCJncmF5XCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChicFBlclBpeGVsID4wLjE1KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5maWxsUmVjdChjdHgsIHAwLCB5X3BvczEsIHAxIC0gcDAsIDEwLCB7ZmlsbFN0eWxlOiBjfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlVGV4dChjdHgsIGIsIHBjLCB5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQ6ICdub3JtYWwgMTBweCBBcmlhbCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgcmV0dXJuIHlfcG9zMSsxMDtcclxuXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuLy8qKioqKioqanMvaWZ2LWNhbnZhcy5qcyoqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cclxuY2xhc3MgR3JhcGhpY3N7XHJcblxyXG5cclxuICAgICAgIHN0YXRpYyBzZXRQcm9wZXJ0aWVzKGN0eCwgcHJvcGVydGllcykge1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwcm9wZXJ0aWVzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIHN0cm9rZUxpbmUgKGN0eCwgeDEsIHkxLCB4MiwgeTIsIHByb3BlcnRpZXMpIHtcclxuXHJcbiAgICAgICAgICAgIHgxID0gTWF0aC5mbG9vcih4MSkgKyAwLjU7XHJcbiAgICAgICAgICAgIHkxID0gTWF0aC5mbG9vcih5MSkgKyAwLjU7XHJcbiAgICAgICAgICAgIHgyID0gTWF0aC5mbG9vcih4MikgKyAwLjU7XHJcbiAgICAgICAgICAgIHkyID0gTWF0aC5mbG9vcih5MikgKyAwLjU7XHJcblxyXG4gICAgICAgICAgICAvL2xvZyhcInN0cm9rZSBsaW5lLCBwcm9wOiBcIiArIHByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCBwcm9wZXJ0aWVzKTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHgyLCB5Mik7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBmaWxsUmVjdChjdHgsIHgsIHksIHcsIGgsIHByb3BlcnRpZXMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjO1xyXG4gICAgICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcclxuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQoeSk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCBwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgZmlsbFBvbHlnb24oY3R4LCB4LCB5LCBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSAgIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCBwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgR3JhcGhpY3MuZG9QYXRoKGN0eCwgeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgc3Ryb2tlUG9seWdvbihjdHgsIHgsIHksIHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpICAgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICBHcmFwaGljcy5kb1BhdGgoY3R4LCB4LCB5KTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIGZpbGxUZXh0KGN0eCwgdGV4dCwgeCwgeSwgcHJvcGVydGllcywgdHJhbnNmb3Jtcykge1xyXG5cclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICBHcmFwaGljcy5zZXRQcm9wZXJ0aWVzKGN0eCwgcHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG5cclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0cmFuc2Zvcm0gaW4gdHJhbnNmb3Jtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybXNbdHJhbnNmb3JtXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogQWRkIGVycm9yIGNoZWNraW5nIGZvciByb2J1c3RuZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSA9PSAndHJhbnNsYXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHZhbHVlWyd4J10sIHZhbHVlWyd5J10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtID09ICdyb3RhdGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUodmFsdWVbJ2FuZ2xlJ10gKiBNYXRoLlBJIC8gMTgwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgMCwgMCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykgY3R4LnJlc3RvcmUoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgc3Ryb2tlVGV4dChjdHgsIHRleHQsIHgsIHksIHByb3BlcnRpZXMsIHRyYW5zZm9ybXMpIHtcclxuXHJcblxyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0cmFuc2Zvcm0gaW4gdHJhbnNmb3Jtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybXNbdHJhbnNmb3JtXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogQWRkIGVycm9yIGNoZWNraW5nIGZvciByb2J1c3RuZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSA9PSAndHJhbnNsYXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHZhbHVlWyd4J10sIHZhbHVlWyd5J10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtID09ICdyb3RhdGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUodmFsdWVbJ2FuZ2xlJ10gKiBNYXRoLlBJIC8gMTgwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlVGV4dCh0ZXh0LCAwLCAwKTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgc3Ryb2tlQ2lyY2xlKGN0eCwgeCwgeSwgcmFkaXVzKSB7XHJcblxyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBmaWxsQ2lyY2xlIChjdHgsIHgsIHksIHJhZGl1cykge1xyXG5cclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIGRyYXdBcnJvd2hlYWQoY3R4LCB4LCB5LCBzaXplLCBsaW5lV2lkdGgpIHtcclxuXHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGlmICghc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgc2l6ZSA9IDU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSAtIHNpemUgLyAyKTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgc2l6ZSAvIDIpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBzaXplLCB5KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5IC0gc2l6ZSAvIDIpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgZGFzaGVkTGluZShjdHgsIHgxLCB5MSwgeDIsIHkyLCBkYXNoTGVuLCBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIHgxID0gTWF0aC5yb3VuZCh4MSk7XHJcbiAgICAgICAgICAgIHkxID0gTWF0aC5yb3VuZCh5MSk7XHJcbiAgICAgICAgICAgIHgyID0gTWF0aC5yb3VuZCh4Mik7XHJcbiAgICAgICAgICAgIHkyID0gTWF0aC5yb3VuZCh5Mik7XHJcbiAgICAgICAgICAgIGRhc2hMZW4gPSBNYXRoLnJvdW5kKGRhc2hMZW4pO1xyXG4gICAgICAgICAgICBsb2coXCJkYXNoZWRMaW5lXCIpO1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIHByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhc2hMZW4gPT0gdW5kZWZpbmVkKSBkYXNoTGVuID0gMjtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRYID0geDIgLSB4MTtcclxuICAgICAgICAgICAgdmFyIGRZID0geTIgLSB5MTtcclxuICAgICAgICAgICAgdmFyIGRhc2hlcyA9IE1hdGguZmxvb3IoTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKSAvIGRhc2hMZW4pO1xyXG4gICAgICAgICAgICB2YXIgZGFzaFggPSBkWCAvIGRhc2hlcztcclxuICAgICAgICAgICAgdmFyIGRhc2hZID0gZFkgLyBkYXNoZXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgcSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChxKysgPCBkYXNoZXMpIHtcclxuICAgICAgICAgICAgICAgIHgxICs9IGRhc2hYO1xyXG4gICAgICAgICAgICAgICAgeTEgKz0gZGFzaFk7XHJcbiAgICAgICAgICAgICAgICBjdHhbcSAlIDIgPT0gMCA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKHgxLCB5MSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4W3EgJSAyID09IDAgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXSh4MiwgeTIpO1xyXG5cclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIFxyXG5cclxuICAgICAgICBzdGF0aWMgZG9QYXRoKGN0eCwgeCwgeSkge1xyXG5cclxuXHJcbiAgICAgICAgXHR2YXIgaSwgbGVuID0geC5sZW5ndGg7XHJcbiAgICAgICAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBcdFx0eFtpXSA9IE1hdGgucm91bmQoeFtpXSk7XHJcbiAgICAgICAgXHRcdHlbaV0gPSBNYXRoLnJvdW5kKHlbaV0pO1xyXG4gICAgICAgIFx0fVxyXG5cclxuICAgICAgICBcdGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBcdGN0eC5tb3ZlVG8oeFswXSwgeVswXSk7XHJcbiAgICAgICAgXHRmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBcdFx0Y3R4LmxpbmVUbyh4W2ldLCB5W2ldKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcblxyXG59XHJcblxyXG5HcmFwaGljcy5udWNsZW90aWRlQ29sb3JzPXtcclxuXHRcIkFcIjpcImdyZWVuXCIsXHJcblx0XCJUXCI6XCJyZWRcIixcclxuXHRcIkdcIjpcImJsYWNrXCIsXHJcblx0XCJDXCI6XCJibHVlXCIsXHJcblx0XCJhXCI6XCJncmVlblwiLFxyXG5cdFwidFwiOlwicmVkXCIsXHJcblx0XCJjXCI6XCJibGFja1wiLFxyXG5cdFwiZ1wiOlwiYmx1ZVwiXHJcblxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCB7TUxWVHJhY2ssTUxWV2lnVHJhY2ssTUxWQmVkVHJhY2ssUnVsZXJUcmFjayxNTFZCaWdCZWRUcmFjayxHcmFwaGljc30iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFXQTs7O0FBUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFYQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFoS0E7QUFDQTtBQW1LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU1BO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBSEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQWZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFrQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQS9UQTtBQUNBO0FBbVVBOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTs7OztBQVBBO0FBQ0E7QUFjQTs7O0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRkE7QUFHQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTs7OztBQTFNQTtBQUNBO0FBMk1BOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFGQTtBQUdBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFWQTtBQUNBO0FBaUJBOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFLQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQXJGQTtBQUNBO0FBeUZBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUtBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7QUFhQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/tracks.js\n");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($, XMLHttpRequest) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2014 Broad Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\n\nvar parseUri_options = {\n    strictMode: false,\n    key: [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"],\n    q: {\n        name: \"queryKey\",\n        parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n        strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n        loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n};\n\nvar Utils = function () {\n    function Utils() {\n        _classCallCheck(this, Utils);\n    }\n\n    _createClass(Utils, null, [{\n        key: \"addAlphaToRGB\",\n        value: function addAlphaToRGB(rgbString, alpha) {\n\n            if (rgbString.startsWith(\"rgb\")) {\n                return rgbString.replace(\"rgb\", \"rgba\").replace(\")\", \", \" + alpha + \")\");\n            } else {\n                console.log(rgbString + \" is not an rgb style string\");\n                return rgbString;\n            }\n        }\n    }, {\n        key: \"presentAlert\",\n        value: function presentAlert(div) {\n            $(div).append($('<i class=\"fas fa-exclamation-circle\"></i>').css({ color: \"red\", \"font-size\": \"16px\", position: \"absolute\", top: \"50%\", left: \"50%\" }));\n        }\n    }, {\n        key: \"spinner\",\n        value: function spinner(size) {\n\n            // spinner\n            var $container, $spinner;\n\n            $spinner = $('<i class=\"fa fa-lg fa-spinner fa-spin igv-spinner\">').css({ position: \"absolute\", top: \"50%\", left: \"50%\" });\n            if (size) {\n                $spinner.css(\"font-size\", size);\n            }\n\n            return $spinner[0];\n        }\n\n        /**\r\n         * Find spinner\r\n         */\n\n    }, {\n        key: \"getSpinnerObjectWithParentElement\",\n        value: function getSpinnerObjectWithParentElement(parentElement) {\n            return parentElement.find(\"div.igv-spinner-container\");\n        }\n    }, {\n        key: \"startSpinnerAtParentElement\",\n\n\n        /**\r\n         * Start the spinner for the parent element, if it has one\r\n         */\n        value: function startSpinnerAtParentElement(parentElement) {\n            parentElement.children(\".fa-spinner\").show();\n        }\n    }, {\n        key: \"stopSpinnerAtParentElement\",\n\n\n        /**\r\n         * Stop the spinner for the parent element, if it has one\r\n         * @param parentElement\r\n         */\n        value: function stopSpinnerAtParentElement(parentElement) {\n            parentElement.children(\".fa-spinner\").hide();\n        }\n    }, {\n        key: \"parseUri\",\n        value: function parseUri(str) {\n\n            var o = parseUri_options,\n                m = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str),\n                uri = {},\n                i = 14;\n\n            while (i--) {\n                uri[o.key[i]] = m[i] || \"\";\n            }uri[o.q.name] = {};\n            uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n                if ($1) uri[o.q.name][$1] = $2;\n            });\n\n            return uri;\n        }\n    }, {\n        key: \"domElementRectAsString\",\n        value: function domElementRectAsString(element) {\n            return \" x \" + element.clientLeft + \" y \" + element.clientTop + \" w \" + element.clientWidth + \" h \" + element.clientHeight;\n        }\n    }, {\n        key: \"isNumber\",\n        value: function isNumber(n) {\n\n            if (\"\" === n) {\n\n                return false;\n            } else if (undefined === n) {\n\n                return false;\n            } else {\n\n                return !isNaN(parseFloat(n)) && isFinite(n);\n            }\n        }\n    }, {\n        key: \"guid\",\n        value: function guid() {\n            return (\"0000\" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);\n        }\n    }, {\n        key: \"random\",\n\n\n        // Returns a random number between min (inclusive) and max (exclusive)\n        value: function random(min, max) {\n            return Math.random() * (max - min) + min;\n        }\n    }, {\n        key: \"numberFormatter\",\n\n\n        // StackOverflow: http://stackoverflow.com/a/10810674/116169\n        value: function numberFormatter(rawNumber) {\n\n            var dec = String(rawNumber).split(/[.,]/),\n                sep = ',',\n                decsep = '.';\n\n            return dec[0].split('').reverse().reduce(function (prev, now, i) {\n                return i % 3 === 0 ? prev + sep + now : prev + now;\n            }).split('').reverse().join('') + (dec[1] ? decsep + dec[1] : '');\n        }\n    }, {\n        key: \"numberUnFormatter\",\n        value: function numberUnFormatter(formatedNumber) {\n\n            return formatedNumber.split(\",\").join().replace(\",\", \"\", \"g\");\n        }\n    }, {\n        key: \"translateMouseCoordinates\",\n\n\n        /**\r\n         * Translate the mouse coordinates for the event to the coordinates for the given target element\r\n         * @param e\r\n         * @param target\r\n         * @returns {{x: number, y: number}}\r\n         */\n        value: function translateMouseCoordinates(e, target) {\n\n            var eFixed = $.event.fix(e),\n                // Sets pageX and pageY for browsers that don't support them\n            posx = eFixed.pageX - $(target).offset().left,\n                posy = eFixed.pageY - $(target).offset().top;\n\n            return { x: posx, y: posy };\n        }\n    }, {\n        key: \"formatPopoverText\",\n\n\n        /**\r\n         * Format markup for popover text from an array of name value pairs [{name, value}]\r\n         */\n        value: function formatPopoverText(nameValueArray) {\n\n            var markup = \"<table class=\\\"igv-popover-table\\\">\";\n\n            nameValueArray.forEach(function (nameValue) {\n\n                if (nameValue.name) {\n                    //markup += \"<tr><td class=\\\"igv-popover-td\\\">\" + \"<span class=\\\"igv-popoverName\\\">\" + nameValue.name + \"</span>\" + \"<span class=\\\"igv-popoverValue\\\">\" + nameValue.value + \"</span>\" + \"</td></tr>\";\n                    markup += \"<tr><td class=\\\"igv-popover-td\\\">\" + \"<div class=\\\"igv-popoverNameValue\\\">\" + \"<span class=\\\"igv-popoverName\\\">\" + nameValue.name + \"</span>\" + \"<span class=\\\"igv-popoverValue\\\">\" + nameValue.value + \"</span>\" + \"</div>\" + \"</td></tr>\";\n                } else {\n                    // not a name/value pair\n                    markup += \"<tr><td>\" + nameValue.toString() + \"</td></tr>\";\n                }\n            });\n\n            markup += \"</table>\";\n            return markup;\n        }\n    }, {\n        key: \"throttle\",\n        value: function throttle(fn, threshhold, scope) {\n            threshhold || (threshhold = 200);\n            var last, deferTimer;\n\n            return function () {\n                var context = scope || this;\n\n                var now = +new Date(),\n                    args = arguments;\n                if (last && now < last + threshhold) {\n                    // hold on to it\n                    clearTimeout(deferTimer);\n                    deferTimer = setTimeout(function () {\n                        last = now;\n                        fn.apply(context, args);\n                    }, threshhold);\n                } else {\n                    last = now;\n                    fn.apply(context, args);\n                }\n            };\n        }\n    }, {\n        key: \"splitStringRespectingQuotes\",\n        value: function splitStringRespectingQuotes(string, delim) {\n\n            var tokens = [],\n                len = string.length,\n                i,\n                n = 0,\n                quote = false,\n                c;\n\n            if (len > 0) {\n\n                tokens[n] = string.charAt(0);\n                for (i = 1; i < len; i++) {\n                    c = string.charAt(i);\n                    if (c === '\"') {\n                        quote = !quote;\n                    } else if (!quote && c === delim) {\n                        n++;\n                        tokens[n] = \"\";\n                    } else {\n                        tokens[n] += c;\n                    }\n                }\n            }\n            return tokens;\n        }\n    }, {\n        key: \"addAjaxExtensions\",\n\n\n        /**\r\n         * Extend jQuery's ajax function to handle binary requests.   Credit to Henry Algus:\r\n         *\r\n         * http://www.henryalgus.com/reading-binary-files-using-jquery-ajax/\r\n         */\n        value: function addAjaxExtensions() {\n\n            // use this transport for \"binary\" data type\n            $.ajaxTransport(\"+binary\", function (options, originalOptions, jqXHR) {\n\n                return {\n                    // create new XMLHttpRequest\n                    send: function send(_, callback) {\n                        // setup all variables\n                        var xhr = new XMLHttpRequest(),\n                            url = options.url,\n                            type = options.type,\n                            responseType = \"arraybuffer\",\n                            data = options.data || null;\n\n                        xhr.addEventListener('load', function () {\n                            var data = {};\n                            data[options.dataType] = xhr.response;\n                            // make callback and send data\n                            callback(xhr.status, xhr.statusText, data, xhr.getAllResponseHeaders());\n                        });\n\n                        xhr.open(type, url);\n                        xhr.responseType = responseType;\n\n                        if (options.headers) {\n                            for (var prop in options.headers) {\n                                if (options.headers.hasOwnProperty(prop)) {\n                                    xhr.setRequestHeader(prop, options.headers[prop]);\n                                }\n                            }\n                        }\n\n                        // TODO -- set any other options values\n                    },\n                    abort: function abort() {\n                        jqXHR.abort();\n                    }\n                };\n            });\n        }\n    }, {\n        key: \"isStringOrNumber\",\n\n\n        /**\r\n         * Test if the given value is a string or number.  Not using typeof as it fails on boxed primitives.\r\n         *\r\n         * @param value\r\n         * @returns boolean\r\n         */\n        value: function isStringOrNumber(value) {\n            return value.substring || value.toFixed ? true : false;\n        }\n    }, {\n        key: \"constrainBBox\",\n        value: function constrainBBox($child, $parent) {\n\n            var delta,\n                topLeft,\n                bboxChild = {},\n                bboxParent = {};\n\n            bboxParent.left = bboxParent.top = 0;\n            bboxParent.right = $parent.outerWidth();\n            bboxParent.bottom = $parent.outerHeight();\n\n            topLeft = $child.offset();\n\n            bboxChild.left = topLeft.left - $parent.offset().left;\n            bboxChild.top = topLeft.top - $parent.offset().top;\n            bboxChild.right = bboxChild.left + $child.outerWidth();\n            bboxChild.bottom = bboxChild.top + $child.outerHeight();\n\n            delta = bboxChild.bottom - bboxParent.bottom;\n            if (delta > 0) {\n\n                // clamp to trackContainer bottom\n                topLeft.top -= delta;\n\n                bboxChild.top -= delta;\n                bboxChild.bottom -= delta;\n\n                delta = bboxChild.top - bboxParent.top;\n                if (delta < 0) {\n                    topLeft.top -= delta;\n                }\n            }\n\n            return topLeft;\n        }\n    }, {\n        key: \"log\",\n        value: function log(message) {\n            if (igv.enableLogging && console && console.log) {\n                console.log(message);\n            }\n        }\n    }]);\n\n    return Utils;\n}();\n\nexports.Utils = Utils;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"jquery\"), __webpack_require__(/*! xhr2 */ \"xhr2\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3V0aWxzLmpzP2EzMDQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCcm9hZCBJbnN0aXR1dGVcclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuICogVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbmxldCBwYXJzZVVyaV9vcHRpb25zID0ge1xyXG4gICAgICAgIHN0cmljdE1vZGU6IGZhbHNlLFxyXG4gICAgICAgIGtleTogW1wic291cmNlXCIsIFwicHJvdG9jb2xcIiwgXCJhdXRob3JpdHlcIiwgXCJ1c2VySW5mb1wiLCBcInVzZXJcIiwgXCJwYXNzd29yZFwiLCBcImhvc3RcIiwgXCJwb3J0XCIsIFwicmVsYXRpdmVcIiwgXCJwYXRoXCIsIFwiZGlyZWN0b3J5XCIsIFwiZmlsZVwiLCBcInF1ZXJ5XCIsIFwiYW5jaG9yXCJdLFxyXG4gICAgICAgIHE6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJxdWVyeUtleVwiLFxyXG4gICAgICAgICAgICBwYXJzZXI6IC8oPzpefCYpKFteJj1dKik9PyhbXiZdKikvZ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGFyc2VyOiB7XHJcbiAgICAgICAgICAgIHN0cmljdDogL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPyhbXjpcXC8/I10qKSg/OjooXFxkKikpPykpPygoKCg/OltePyNcXC9dKlxcLykqKShbXj8jXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLyxcclxuICAgICAgICAgICAgbG9vc2U6IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKFteOlxcLz8jLl0rKTopPyg/OlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oW146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pL1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuXHJcbmNsYXNzIFV0aWxze1xyXG5cclxuICAgIFxyXG4gICAgc3RhdGljIGFkZEFscGhhVG9SR0IocmdiU3RyaW5nLCBhbHBoYSkge1xyXG5cclxuICAgICAgICBpZiAocmdiU3RyaW5nLnN0YXJ0c1dpdGgoXCJyZ2JcIikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJnYlN0cmluZy5yZXBsYWNlKFwicmdiXCIsIFwicmdiYVwiKS5yZXBsYWNlKFwiKVwiLCBcIiwgXCIgKyBhbHBoYSArIFwiKVwiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZ2JTdHJpbmcgKyBcIiBpcyBub3QgYW4gcmdiIHN0eWxlIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJnYlN0cmluZztcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBwcmVzZW50QWxlcnQoZGl2KXtcclxuICAgICAgICAgJChkaXYpLmFwcGVuZCgkKCc8aSBjbGFzcz1cImZhcyBmYS1leGNsYW1hdGlvbi1jaXJjbGVcIj48L2k+JykuY3NzKHtjb2xvcjpcInJlZFwiLFwiZm9udC1zaXplXCI6XCIxNnB4XCIscG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIjUwJVwiLGxlZnQ6XCI1MCVcIn0pKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgXHJcblxyXG4gICAgc3RhdGljIHNwaW5uZXIoc2l6ZSkge1xyXG5cclxuICAgICAgICAvLyBzcGlubmVyXHJcbiAgICAgICAgdmFyICRjb250YWluZXIsXHJcbiAgICAgICAgICAgICRzcGlubmVyO1xyXG5cclxuICAgICAgICAkc3Bpbm5lciA9ICQoJzxpIGNsYXNzPVwiZmEgZmEtbGcgZmEtc3Bpbm5lciBmYS1zcGluIGlndi1zcGlubmVyXCI+JykuY3NzKHtwb3NpdGlvbjpcImFic29sdXRlXCIsdG9wOlwiNTAlXCIsbGVmdDpcIjUwJVwifSk7XHJcbiAgICAgICAgaWYgKHNpemUpIHtcclxuICAgICAgICAgICAgJHNwaW5uZXIuY3NzKFwiZm9udC1zaXplXCIsIHNpemUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICBcclxuXHJcbiAgICAgICAgcmV0dXJuICRzcGlubmVyWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluZCBzcGlubmVyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRTcGlubmVyT2JqZWN0V2l0aFBhcmVudEVsZW1lbnQocGFyZW50RWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiBwYXJlbnRFbGVtZW50LmZpbmQoXCJkaXYuaWd2LXNwaW5uZXItY29udGFpbmVyXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IHRoZSBzcGlubmVyIGZvciB0aGUgcGFyZW50IGVsZW1lbnQsIGlmIGl0IGhhcyBvbmVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHN0YXJ0U3Bpbm5lckF0UGFyZW50RWxlbWVudChwYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgICBwYXJlbnRFbGVtZW50LmNoaWxkcmVuKFwiLmZhLXNwaW5uZXJcIikuc2hvdygpOyAgXHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3AgdGhlIHNwaW5uZXIgZm9yIHRoZSBwYXJlbnQgZWxlbWVudCwgaWYgaXQgaGFzIG9uZVxyXG4gICAgICogQHBhcmFtIHBhcmVudEVsZW1lbnRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHN0b3BTcGlubmVyQXRQYXJlbnRFbGVtZW50IChwYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgcGFyZW50RWxlbWVudC5jaGlsZHJlbihcIi5mYS1zcGlubmVyXCIpLmhpZGUoKTtcclxuICAgICAgIFxyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgcGFyc2VVcmkoc3RyKSB7XHJcblxyXG4gICAgICAgIHZhciBvID0gcGFyc2VVcmlfb3B0aW9ucyxcclxuICAgICAgICAgICAgbSA9IG8ucGFyc2VyW28uc3RyaWN0TW9kZSA/IFwic3RyaWN0XCIgOiBcImxvb3NlXCJdLmV4ZWMoc3RyKSxcclxuICAgICAgICAgICAgdXJpID0ge30sXHJcbiAgICAgICAgICAgIGkgPSAxNDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGktLSkgdXJpW28ua2V5W2ldXSA9IG1baV0gfHwgXCJcIjtcclxuXHJcbiAgICAgICAgdXJpW28ucS5uYW1lXSA9IHt9O1xyXG4gICAgICAgIHVyaVtvLmtleVsxMl1dLnJlcGxhY2Uoby5xLnBhcnNlciwgZnVuY3Rpb24gKCQwLCAkMSwgJDIpIHtcclxuICAgICAgICAgICAgaWYgKCQxKSB1cmlbby5xLm5hbWVdWyQxXSA9ICQyO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdXJpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBcclxuICAgIFxyXG4gIFxyXG4gICAgc3RhdGljIGRvbUVsZW1lbnRSZWN0QXNTdHJpbmcoZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiBcIiB4IFwiICsgZWxlbWVudC5jbGllbnRMZWZ0ICsgXCIgeSBcIiArIGVsZW1lbnQuY2xpZW50VG9wICsgXCIgdyBcIiArIGVsZW1lbnQuY2xpZW50V2lkdGggKyBcIiBoIFwiICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHN0YXRpYyBpc051bWJlcihuKSB7XHJcblxyXG4gICAgICAgIGlmIChcIlwiID09PSBuKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICB9IGVsc2UgaWYgKHVuZGVmaW5lZCA9PT0gbikge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHN0YXRpYyBndWlkICAoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcIjAwMDBcIiArIChNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMzYsIDQpIDw8IDApLnRvU3RyaW5nKDM2KSkuc2xpY2UoLTQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBSZXR1cm5zIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiAoaW5jbHVzaXZlKSBhbmQgbWF4IChleGNsdXNpdmUpXHJcbiAgICBzdGF0aWMgcmFuZG9tKG1pbiwgbWF4KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcclxuICAgIH07XHJcblxyXG4gICAgLy8gU3RhY2tPdmVyZmxvdzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTA4MTA2NzQvMTE2MTY5XHJcbiAgICBzdGF0aWMgbnVtYmVyRm9ybWF0dGVyKHJhd051bWJlcikge1xyXG5cclxuICAgICAgICB2YXIgZGVjID0gU3RyaW5nKHJhd051bWJlcikuc3BsaXQoL1suLF0vKSxcclxuICAgICAgICAgICAgc2VwID0gJywnLFxyXG4gICAgICAgICAgICBkZWNzZXAgPSAnLic7XHJcblxyXG4gICAgICAgIHJldHVybiBkZWNbMF0uc3BsaXQoJycpLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIG5vdywgaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgJSAzID09PSAwID8gcHJldiArIHNlcCArIG5vdyA6IHByZXYgKyBub3c7XHJcbiAgICAgICAgICAgIH0pLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykgKyAoZGVjWzFdID8gZGVjc2VwICsgZGVjWzFdIDogJycpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzdGF0aWMgbnVtYmVyVW5Gb3JtYXR0ZXIgKGZvcm1hdGVkTnVtYmVyKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBmb3JtYXRlZE51bWJlci5zcGxpdChcIixcIikuam9pbigpLnJlcGxhY2UoXCIsXCIsIFwiXCIsIFwiZ1wiKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGUgdGhlIG1vdXNlIGNvb3JkaW5hdGVzIGZvciB0aGUgZXZlbnQgdG8gdGhlIGNvb3JkaW5hdGVzIGZvciB0aGUgZ2l2ZW4gdGFyZ2V0IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSBlXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0XHJcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRyYW5zbGF0ZU1vdXNlQ29vcmRpbmF0ZXMoZSwgdGFyZ2V0KSB7XHJcblxyXG4gICAgICAgIHZhciBlRml4ZWQgPSAkLmV2ZW50LmZpeChlKSwgICAvLyBTZXRzIHBhZ2VYIGFuZCBwYWdlWSBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRoZW1cclxuICAgICAgICAgICAgcG9zeCA9IGVGaXhlZC5wYWdlWCAtICQodGFyZ2V0KS5vZmZzZXQoKS5sZWZ0LFxyXG4gICAgICAgICAgICBwb3N5ID0gZUZpeGVkLnBhZ2VZIC0gJCh0YXJnZXQpLm9mZnNldCgpLnRvcDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHt4OiBwb3N4LCB5OiBwb3N5fVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JtYXQgbWFya3VwIGZvciBwb3BvdmVyIHRleHQgZnJvbSBhbiBhcnJheSBvZiBuYW1lIHZhbHVlIHBhaXJzIFt7bmFtZSwgdmFsdWV9XVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZm9ybWF0UG9wb3ZlclRleHQgKG5hbWVWYWx1ZUFycmF5KSB7XHJcblxyXG4gICAgICAgIHZhciBtYXJrdXAgPSBcIjx0YWJsZSBjbGFzcz1cXFwiaWd2LXBvcG92ZXItdGFibGVcXFwiPlwiO1xyXG5cclxuICAgICAgICBuYW1lVmFsdWVBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lVmFsdWUpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChuYW1lVmFsdWUubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgLy9tYXJrdXAgKz0gXCI8dHI+PHRkIGNsYXNzPVxcXCJpZ3YtcG9wb3Zlci10ZFxcXCI+XCIgKyBcIjxzcGFuIGNsYXNzPVxcXCJpZ3YtcG9wb3Zlck5hbWVcXFwiPlwiICsgbmFtZVZhbHVlLm5hbWUgKyBcIjwvc3Bhbj5cIiArIFwiPHNwYW4gY2xhc3M9XFxcImlndi1wb3BvdmVyVmFsdWVcXFwiPlwiICsgbmFtZVZhbHVlLnZhbHVlICsgXCI8L3NwYW4+XCIgKyBcIjwvdGQ+PC90cj5cIjtcclxuICAgICAgICAgICAgICAgIG1hcmt1cCArPSBcIjx0cj48dGQgY2xhc3M9XFxcImlndi1wb3BvdmVyLXRkXFxcIj5cIiArIFwiPGRpdiBjbGFzcz1cXFwiaWd2LXBvcG92ZXJOYW1lVmFsdWVcXFwiPlwiICsgXCI8c3BhbiBjbGFzcz1cXFwiaWd2LXBvcG92ZXJOYW1lXFxcIj5cIiArIG5hbWVWYWx1ZS5uYW1lICsgXCI8L3NwYW4+XCIgKyBcIjxzcGFuIGNsYXNzPVxcXCJpZ3YtcG9wb3ZlclZhbHVlXFxcIj5cIiArIG5hbWVWYWx1ZS52YWx1ZSArIFwiPC9zcGFuPlwiICsgXCI8L2Rpdj5cIiArIFwiPC90ZD48L3RyPlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm90IGEgbmFtZS92YWx1ZSBwYWlyXHJcbiAgICAgICAgICAgICAgICBtYXJrdXAgKz0gXCI8dHI+PHRkPlwiICsgbmFtZVZhbHVlLnRvU3RyaW5nKCkgKyBcIjwvdGQ+PC90cj5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBtYXJrdXAgKz0gXCI8L3RhYmxlPlwiO1xyXG4gICAgICAgIHJldHVybiBtYXJrdXA7XHJcblxyXG5cclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIHRocm90dGxlKGZuLCB0aHJlc2hob2xkLCBzY29wZSkge1xyXG4gICAgICAgIHRocmVzaGhvbGQgfHwgKHRocmVzaGhvbGQgPSAyMDApO1xyXG4gICAgICAgIHZhciBsYXN0LCBkZWZlclRpbWVyO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHNjb3BlIHx8IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgbm93ID0gK25ldyBEYXRlLFxyXG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbm93IDwgbGFzdCArIHRocmVzaGhvbGQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGhvbGQgb24gdG8gaXRcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChkZWZlclRpbWVyKTtcclxuICAgICAgICAgICAgICAgIGRlZmVyVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gbm93O1xyXG4gICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfSwgdGhyZXNoaG9sZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0ID0gbm93O1xyXG4gICAgICAgICAgICAgICAgZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHN0YXRpYyBzcGxpdFN0cmluZ1Jlc3BlY3RpbmdRdW90ZXMoc3RyaW5nLCBkZWxpbSkge1xyXG5cclxuICAgICAgICB2YXIgdG9rZW5zID0gW10sXHJcbiAgICAgICAgICAgIGxlbiA9IHN0cmluZy5sZW5ndGgsXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIG4gPSAwLFxyXG4gICAgICAgICAgICBxdW90ZSA9IGZhbHNlLFxyXG4gICAgICAgICAgICBjO1xyXG5cclxuICAgICAgICBpZiAobGVuID4gMCkge1xyXG5cclxuICAgICAgICAgICAgdG9rZW5zW25dID0gc3RyaW5nLmNoYXJBdCgwKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjID0gc3RyaW5nLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgIGlmIChjID09PSAnXCInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSAhcXVvdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghcXVvdGUgJiYgYyA9PT0gZGVsaW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zW25dID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1tuXSArPSBjO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b2tlbnM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZW5kIGpRdWVyeSdzIGFqYXggZnVuY3Rpb24gdG8gaGFuZGxlIGJpbmFyeSByZXF1ZXN0cy4gICBDcmVkaXQgdG8gSGVucnkgQWxndXM6XHJcbiAgICAgKlxyXG4gICAgICogaHR0cDovL3d3dy5oZW5yeWFsZ3VzLmNvbS9yZWFkaW5nLWJpbmFyeS1maWxlcy11c2luZy1qcXVlcnktYWpheC9cclxuICAgICAqL1xyXG4gICBzdGF0aWMgYWRkQWpheEV4dGVuc2lvbnMgKCkge1xyXG5cclxuICAgICAgICAvLyB1c2UgdGhpcyB0cmFuc3BvcnQgZm9yIFwiYmluYXJ5XCIgZGF0YSB0eXBlXHJcbiAgICAgICAgJC5hamF4VHJhbnNwb3J0KFwiK2JpbmFyeVwiLCBmdW5jdGlvbiAob3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUikge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgWE1MSHR0cFJlcXVlc3RcclxuICAgICAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uIChfLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldHVwIGFsbCB2YXJpYWJsZXNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IG9wdGlvbnMudXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gb3B0aW9ucy50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBvcHRpb25zLmRhdGEgfHwgbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbb3B0aW9ucy5kYXRhVHlwZV0gPSB4aHIucmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgY2FsbGJhY2sgYW5kIHNlbmQgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh4aHIuc3RhdHVzLCB4aHIuc3RhdHVzVGV4dCwgZGF0YSwgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4odHlwZSwgdXJsKTtcclxuICAgICAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucy5oZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJzLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIocHJvcCwgb3B0aW9ucy5oZWFkZXJzW3Byb3BdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyAtLSBzZXQgYW55IG90aGVyIG9wdGlvbnMgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBqcVhIUi5hYm9ydCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHN0cmluZyBvciBudW1iZXIuICBOb3QgdXNpbmcgdHlwZW9mIGFzIGl0IGZhaWxzIG9uIGJveGVkIHByaW1pdGl2ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyBib29sZWFuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc1N0cmluZ09yTnVtYmVyKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuICh2YWx1ZS5zdWJzdHJpbmcgfHwgdmFsdWUudG9GaXhlZCkgPyB0cnVlIDogZmFsc2VcclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIGNvbnN0cmFpbkJCb3goJGNoaWxkLCAkcGFyZW50KSB7XHJcblxyXG4gICAgICAgIHZhciBkZWx0YSxcclxuICAgICAgICAgICAgdG9wTGVmdCxcclxuICAgICAgICAgICAgYmJveENoaWxkID0ge30sXHJcbiAgICAgICAgICAgIGJib3hQYXJlbnQgPSB7fTtcclxuXHJcbiAgICAgICAgYmJveFBhcmVudC5sZWZ0ID0gYmJveFBhcmVudC50b3AgPSAwO1xyXG4gICAgICAgIGJib3hQYXJlbnQucmlnaHQgPSAkcGFyZW50Lm91dGVyV2lkdGgoKTtcclxuICAgICAgICBiYm94UGFyZW50LmJvdHRvbSA9ICRwYXJlbnQub3V0ZXJIZWlnaHQoKTtcclxuXHJcbiAgICAgICAgdG9wTGVmdCA9ICRjaGlsZC5vZmZzZXQoKTtcclxuXHJcbiAgICAgICAgYmJveENoaWxkLmxlZnQgPSB0b3BMZWZ0LmxlZnQgLSAkcGFyZW50Lm9mZnNldCgpLmxlZnQ7XHJcbiAgICAgICAgYmJveENoaWxkLnRvcCA9IHRvcExlZnQudG9wIC0gJHBhcmVudC5vZmZzZXQoKS50b3A7XHJcbiAgICAgICAgYmJveENoaWxkLnJpZ2h0ID0gYmJveENoaWxkLmxlZnQgKyAkY2hpbGQub3V0ZXJXaWR0aCgpO1xyXG4gICAgICAgIGJib3hDaGlsZC5ib3R0b20gPSBiYm94Q2hpbGQudG9wICsgJGNoaWxkLm91dGVySGVpZ2h0KCk7XHJcblxyXG4gICAgICAgIGRlbHRhID0gYmJveENoaWxkLmJvdHRvbSAtIGJib3hQYXJlbnQuYm90dG9tO1xyXG4gICAgICAgIGlmIChkZWx0YSA+IDApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGNsYW1wIHRvIHRyYWNrQ29udGFpbmVyIGJvdHRvbVxyXG4gICAgICAgICAgICB0b3BMZWZ0LnRvcCAtPSBkZWx0YTtcclxuXHJcbiAgICAgICAgICAgIGJib3hDaGlsZC50b3AgLT0gZGVsdGE7XHJcbiAgICAgICAgICAgIGJib3hDaGlsZC5ib3R0b20gLT0gZGVsdGE7XHJcblxyXG4gICAgICAgICAgICBkZWx0YSA9IGJib3hDaGlsZC50b3AgLSBiYm94UGFyZW50LnRvcDtcclxuICAgICAgICAgICAgaWYgKGRlbHRhIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdG9wTGVmdC50b3AgLT0gZGVsdGE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdG9wTGVmdDtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHN0YXRpYyBsb2cobWVzc2FnZSkge1xyXG4gICAgICAgIGlmIChpZ3YuZW5hYmxlTG9nZ2luZyAmJiBjb25zb2xlICYmIGNvbnNvbGUubG9nKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxufVxyXG5cclxuZXhwb3J0IHtVdGlsc307Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQVBBO0FBQ0E7QUFjQTs7Ozs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUVBOzs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBRUE7OztBQUdBO0FBQ0E7QUFFQTs7Ozs7QUFFQTs7OztBQUlBO0FBQ0E7QUFHQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUtBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUVBOzs7OztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQ0E7QUFtQ0E7QUFDQTs7Ozs7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils.js\n");

/***/ }),

/***/ "./src/vendor/inflate.js":
/*!*******************************!*\
  !*** ./src/vendor/inflate.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Javascript ZLib\n// By Thomas Down 2010-2011\n//\n// Based very heavily on portions of jzlib (by ymnk@jcraft.com), who in\n// turn credits Jean-loup Gailly and Mark Adler for the original zlib code.\n//\n// inflate.js: ZLib inflate code\n//\n\n//\n// Shared constants\n//\n\nvar MAX_WBITS = 15; // 32K LZ77 window\nvar DEF_WBITS = MAX_WBITS;\nvar MAX_MEM_LEVEL = 9;\nvar MANY = 1440;\nvar BMAX = 15;\n\n// preset dictionary flag in zlib header\nvar PRESET_DICT = 0x20;\n\nvar Z_NO_FLUSH = 0;\nvar Z_PARTIAL_FLUSH = 1;\nvar Z_SYNC_FLUSH = 2;\nvar Z_FULL_FLUSH = 3;\nvar Z_FINISH = 4;\n\nvar Z_DEFLATED = 8;\n\nvar Z_OK = 0;\nvar Z_STREAM_END = 1;\nvar Z_NEED_DICT = 2;\nvar Z_ERRNO = -1;\nvar Z_STREAM_ERROR = -2;\nvar Z_DATA_ERROR = -3;\nvar Z_MEM_ERROR = -4;\nvar Z_BUF_ERROR = -5;\nvar Z_VERSION_ERROR = -6;\n\nvar METHOD = 0; // waiting for method byte\nvar FLAG = 1; // waiting for flag byte\nvar DICT4 = 2; // four dictionary check bytes to go\nvar DICT3 = 3; // three dictionary check bytes to go\nvar DICT2 = 4; // two dictionary check bytes to go\nvar DICT1 = 5; // one dictionary check byte to go\nvar DICT0 = 6; // waiting for inflateSetDictionary\nvar BLOCKS = 7; // decompressing blocks\nvar CHECK4 = 8; // four check bytes to go\nvar CHECK3 = 9; // three check bytes to go\nvar CHECK2 = 10; // two check bytes to go\nvar CHECK1 = 11; // one check byte to go\nvar DONE = 12; // finished check, done\nvar BAD = 13; // got an error--stay here\n\nvar inflate_mask = [0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff];\n\nvar IB_TYPE = 0; // get type bits (3, including end bit)\nvar IB_LENS = 1; // get lengths for stored\nvar IB_STORED = 2; // processing stored block\nvar IB_TABLE = 3; // get table lengths\nvar IB_BTREE = 4; // get bit lengths tree for a dynamic block\nvar IB_DTREE = 5; // get length, distance trees for a dynamic block\nvar IB_CODES = 6; // processing fixed or dynamic block\nvar IB_DRY = 7; // output remaining window bytes\nvar IB_DONE = 8; // finished last block, done\nvar IB_BAD = 9; // ot a data error--stuck here\n\nvar fixed_bl = 9;\nvar fixed_bd = 5;\n\nvar fixed_tl = [96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255];\nvar fixed_td = [80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5, 8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5, 24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577];\n\n// Tables for deflate from PKZIP's appnote.txt.\nvar cplens = [// Copy lengths for literal codes 257..285\n3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];\n\n// see note #13 above about 258\nvar cplext = [// Extra bits for literal codes 257..285\n0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112 // 112==invalid\n];\n\nvar cpdist = [// Copy offsets for distance codes 0..29\n1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];\n\nvar cpdext = [// Extra bits for distance codes\n0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\n\n//\n// ZStream.java\n//\n\nfunction ZStream() {}\n\nZStream.prototype.inflateInit = function (w, nowrap) {\n  if (!w) {\n    w = DEF_WBITS;\n  }\n  if (nowrap) {\n    nowrap = false;\n  }\n  this.istate = new Inflate();\n  return this.istate.inflateInit(this, nowrap ? -w : w);\n};\n\nZStream.prototype.inflate = function (f) {\n  if (this.istate == null) return Z_STREAM_ERROR;\n  return this.istate.inflate(this, f);\n};\n\nZStream.prototype.inflateEnd = function () {\n  if (this.istate == null) return Z_STREAM_ERROR;\n  var ret = istate.inflateEnd(this);\n  this.istate = null;\n  return ret;\n};\nZStream.prototype.inflateSync = function () {\n  // if(istate == null) return Z_STREAM_ERROR;\n  return istate.inflateSync(this);\n};\nZStream.prototype.inflateSetDictionary = function (dictionary, dictLength) {\n  // if(istate == null) return Z_STREAM_ERROR;\n  return istate.inflateSetDictionary(this, dictionary, dictLength);\n};\n\n/*\n\n  public int deflateInit(int level){\n    return deflateInit(level, MAX_WBITS);\n  }\n  public int deflateInit(int level, boolean nowrap){\n    return deflateInit(level, MAX_WBITS, nowrap);\n  }\n  public int deflateInit(int level, int bits){\n    return deflateInit(level, bits, false);\n  }\n  public int deflateInit(int level, int bits, boolean nowrap){\n    dstate=new Deflate();\n    return dstate.deflateInit(this, level, nowrap?-bits:bits);\n  }\n  public int deflate(int flush){\n    if(dstate==null){\n      return Z_STREAM_ERROR;\n    }\n    return dstate.deflate(this, flush);\n  }\n  public int deflateEnd(){\n    if(dstate==null) return Z_STREAM_ERROR;\n    int ret=dstate.deflateEnd();\n    dstate=null;\n    return ret;\n  }\n  public int deflateParams(int level, int strategy){\n    if(dstate==null) return Z_STREAM_ERROR;\n    return dstate.deflateParams(this, level, strategy);\n  }\n  public int deflateSetDictionary (byte[] dictionary, int dictLength){\n    if(dstate == null)\n      return Z_STREAM_ERROR;\n    return dstate.deflateSetDictionary(this, dictionary, dictLength);\n  }\n\n*/\n\n/*\n  // Flush as much pending output as possible. All deflate() output goes\n  // through this function so some applications may wish to modify it\n  // to avoid allocating a large strm->next_out buffer and copying into it.\n  // (See also read_buf()).\n  void flush_pending(){\n    int len=dstate.pending;\n\n    if(len>avail_out) len=avail_out;\n    if(len==0) return;\n\n    if(dstate.pending_buf.length<=dstate.pending_out ||\n       next_out.length<=next_out_index ||\n       dstate.pending_buf.length<(dstate.pending_out+len) ||\n       next_out.length<(next_out_index+len)){\n      System.out.println(dstate.pending_buf.length+\", \"+dstate.pending_out+\n\t\t\t \", \"+next_out.length+\", \"+next_out_index+\", \"+len);\n      System.out.println(\"avail_out=\"+avail_out);\n    }\n\n    System.arraycopy(dstate.pending_buf, dstate.pending_out,\n\t\t     next_out, next_out_index, len);\n\n    next_out_index+=len;\n    dstate.pending_out+=len;\n    total_out+=len;\n    avail_out-=len;\n    dstate.pending-=len;\n    if(dstate.pending==0){\n      dstate.pending_out=0;\n    }\n  }\n\n  // Read a new buffer from the current input stream, update the adler32\n  // and total number of bytes read.  All deflate() input goes through\n  // this function so some applications may wish to modify it to avoid\n  // allocating a large strm->next_in buffer and copying from it.\n  // (See also flush_pending()).\n  int read_buf(byte[] buf, int start, int size) {\n    int len=avail_in;\n\n    if(len>size) len=size;\n    if(len==0) return 0;\n\n    avail_in-=len;\n\n    if(dstate.noheader==0) {\n      adler=_adler.adler32(adler, next_in, next_in_index, len);\n    }\n    System.arraycopy(next_in, next_in_index, buf, start, len);\n    next_in_index  += len;\n    total_in += len;\n    return len;\n  }\n\n  public void free(){\n    next_in=null;\n    next_out=null;\n    msg=null;\n    _adler=null;\n  }\n}\n*/\n\n//\n// Inflate.java\n//\n\nfunction Inflate() {\n  this.was = [0];\n}\n\nInflate.prototype.inflateReset = function (z) {\n  if (z == null || z.istate == null) return Z_STREAM_ERROR;\n\n  z.total_in = z.total_out = 0;\n  z.msg = null;\n  z.istate.mode = z.istate.nowrap != 0 ? BLOCKS : METHOD;\n  z.istate.blocks.reset(z, null);\n  return Z_OK;\n};\n\nInflate.prototype.inflateEnd = function (z) {\n  if (this.blocks != null) this.blocks.free(z);\n  this.blocks = null;\n  return Z_OK;\n};\n\nInflate.prototype.inflateInit = function (z, w) {\n  z.msg = null;\n  this.blocks = null;\n\n  // handle undocumented nowrap option (no zlib header or check)\n  var nowrap = 0;\n  if (w < 0) {\n    w = -w;\n    nowrap = 1;\n  }\n\n  // set window size\n  if (w < 8 || w > 15) {\n    this.inflateEnd(z);\n    return Z_STREAM_ERROR;\n  }\n  this.wbits = w;\n\n  z.istate.blocks = new InfBlocks(z, z.istate.nowrap != 0 ? null : this, 1 << w);\n\n  // reset state\n  this.inflateReset(z);\n  return Z_OK;\n};\n\nInflate.prototype.inflate = function (z, f) {\n  var r, b;\n\n  if (z == null || z.istate == null || z.next_in == null) return Z_STREAM_ERROR;\n  f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n  r = Z_BUF_ERROR;\n  while (true) {\n    switch (z.istate.mode) {\n      case METHOD:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED) {\n          z.istate.mode = BAD;\n          z.msg = \"unknown compression method\";\n          z.istate.marker = 5; // can't try inflateSync\n          break;\n        }\n        if ((z.istate.method >> 4) + 8 > z.istate.wbits) {\n          z.istate.mode = BAD;\n          z.msg = \"invalid window size\";\n          z.istate.marker = 5; // can't try inflateSync\n          break;\n        }\n        z.istate.mode = FLAG;\n      case FLAG:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        b = z.next_in[z.next_in_index++] & 0xff;\n\n        if (((z.istate.method << 8) + b) % 31 != 0) {\n          z.istate.mode = BAD;\n          z.msg = \"incorrect header check\";\n          z.istate.marker = 5; // can't try inflateSync\n          break;\n        }\n\n        if ((b & PRESET_DICT) == 0) {\n          z.istate.mode = BLOCKS;\n          break;\n        }\n        z.istate.mode = DICT4;\n      case DICT4:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need = (z.next_in[z.next_in_index++] & 0xff) << 24 & 0xff000000;\n        z.istate.mode = DICT3;\n      case DICT3:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += (z.next_in[z.next_in_index++] & 0xff) << 16 & 0xff0000;\n        z.istate.mode = DICT2;\n      case DICT2:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += (z.next_in[z.next_in_index++] & 0xff) << 8 & 0xff00;\n        z.istate.mode = DICT1;\n      case DICT1:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += z.next_in[z.next_in_index++] & 0xff;\n        z.adler = z.istate.need;\n        z.istate.mode = DICT0;\n        return Z_NEED_DICT;\n      case DICT0:\n        z.istate.mode = BAD;\n        z.msg = \"need dictionary\";\n        z.istate.marker = 0; // can try inflateSync\n        return Z_STREAM_ERROR;\n      case BLOCKS:\n\n        r = z.istate.blocks.proc(z, r);\n        if (r == Z_DATA_ERROR) {\n          z.istate.mode = BAD;\n          z.istate.marker = 0; // can try inflateSync\n          break;\n        }\n        if (r == Z_OK) {\n          r = f;\n        }\n        if (r != Z_STREAM_END) {\n          return r;\n        }\n        r = f;\n        z.istate.blocks.reset(z, z.istate.was);\n        if (z.istate.nowrap != 0) {\n          z.istate.mode = DONE;\n          break;\n        }\n        z.istate.mode = CHECK4;\n      case CHECK4:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need = (z.next_in[z.next_in_index++] & 0xff) << 24 & 0xff000000;\n        z.istate.mode = CHECK3;\n      case CHECK3:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += (z.next_in[z.next_in_index++] & 0xff) << 16 & 0xff0000;\n        z.istate.mode = CHECK2;\n      case CHECK2:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += (z.next_in[z.next_in_index++] & 0xff) << 8 & 0xff00;\n        z.istate.mode = CHECK1;\n      case CHECK1:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += z.next_in[z.next_in_index++] & 0xff;\n\n        if (z.istate.was[0] != z.istate.need) {\n          z.istate.mode = BAD;\n          z.msg = \"incorrect data check\";\n          z.istate.marker = 5; // can't try inflateSync\n          break;\n        }\n\n        z.istate.mode = DONE;\n      case DONE:\n        return Z_STREAM_END;\n      case BAD:\n        return Z_DATA_ERROR;\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n};\n\nInflate.prototype.inflateSetDictionary = function (z, dictionary, dictLength) {\n  var index = 0;\n  var length = dictLength;\n  if (z == null || z.istate == null || z.istate.mode != DICT0) return Z_STREAM_ERROR;\n\n  if (z._adler.adler32(1, dictionary, 0, dictLength) != z.adler) {\n    return Z_DATA_ERROR;\n  }\n\n  z.adler = z._adler.adler32(0, null, 0, 0);\n\n  if (length >= 1 << z.istate.wbits) {\n    length = (1 << z.istate.wbits) - 1;\n    index = dictLength - length;\n  }\n  z.istate.blocks.set_dictionary(dictionary, index, length);\n  z.istate.mode = BLOCKS;\n  return Z_OK;\n};\n\n//  static private byte[] mark = {(byte)0, (byte)0, (byte)0xff, (byte)0xff};\nvar mark = [0, 0, 255, 255];\n\nInflate.prototype.inflateSync = function (z) {\n  var n; // number of bytes to look at\n  var p; // pointer to bytes\n  var m; // number of marker bytes found in a row\n  var r, w; // temporaries to save total_in and total_out\n\n  // set up\n  if (z == null || z.istate == null) return Z_STREAM_ERROR;\n  if (z.istate.mode != BAD) {\n    z.istate.mode = BAD;\n    z.istate.marker = 0;\n  }\n  if ((n = z.avail_in) == 0) return Z_BUF_ERROR;\n  p = z.next_in_index;\n  m = z.istate.marker;\n\n  // search\n  while (n != 0 && m < 4) {\n    if (z.next_in[p] == mark[m]) {\n      m++;\n    } else if (z.next_in[p] != 0) {\n      m = 0;\n    } else {\n      m = 4 - m;\n    }\n    p++;n--;\n  }\n\n  // restore\n  z.total_in += p - z.next_in_index;\n  z.next_in_index = p;\n  z.avail_in = n;\n  z.istate.marker = m;\n\n  // return no joy or set up to restart on a new block\n  if (m != 4) {\n    return Z_DATA_ERROR;\n  }\n  r = z.total_in;w = z.total_out;\n  this.inflateReset(z);\n  z.total_in = r;z.total_out = w;\n  z.istate.mode = BLOCKS;\n  return Z_OK;\n};\n\n// Returns true if inflate is currently at the end of a block generated\n// by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n// implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH\n// but removes the length bytes of the resulting empty stored block. When\n// decompressing, PPP checks that at the end of input packet, inflate is\n// waiting for these length bytes.\nInflate.prototype.inflateSyncPoint = function (z) {\n  if (z == null || z.istate == null || z.istate.blocks == null) return Z_STREAM_ERROR;\n  return z.istate.blocks.sync_point();\n};\n\n//\n// InfBlocks.java\n//\n\nvar INFBLOCKS_BORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\nfunction InfBlocks(z, checkfn, w) {\n  this.hufts = new Int32Array(MANY * 3);\n  this.window = new Uint8Array(w);\n  this.end = w;\n  this.checkfn = checkfn;\n  this.mode = IB_TYPE;\n  this.reset(z, null);\n\n  this.left = 0; // if STORED, bytes left to copy \n\n  this.table = 0; // table lengths (14 bits) \n  this.index = 0; // index into blens (or border) \n  this.blens = null; // bit lengths of codes \n  this.bb = new Int32Array(1); // bit length tree depth \n  this.tb = new Int32Array(1); // bit length decoding tree \n\n  this.codes = new InfCodes();\n\n  this.last = 0; // true if this block is the last block \n\n  // mode independent information \n  this.bitk = 0; // bits in bit buffer \n  this.bitb = 0; // bit buffer \n  this.read = 0; // window read pointer \n  this.write = 0; // window write pointer \n  this.check = 0; // check on output \n\n  this.inftree = new InfTree();\n}\n\nInfBlocks.prototype.reset = function (z, c) {\n  if (c) c[0] = this.check;\n  if (this.mode == IB_CODES) {\n    this.codes.free(z);\n  }\n  this.mode = IB_TYPE;\n  this.bitk = 0;\n  this.bitb = 0;\n  this.read = this.write = 0;\n\n  if (this.checkfn) z.adler = this.check = z._adler.adler32(0, null, 0, 0);\n};\n\nInfBlocks.prototype.proc = function (z, r) {\n  var t; // temporary storage\n  var b; // bit buffer\n  var k; // bits in bit buffer\n  var p; // input data pointer\n  var n; // bytes available there\n  var q; // output window write pointer\n  var m; // bytes to end of window or read pointer\n\n  // copy input/output information to locals (UPDATE macro restores)\n  {\n    p = z.next_in_index;n = z.avail_in;b = this.bitb;k = this.bitk;\n  }\n  {\n    q = this.write;m = q < this.read ? this.read - q - 1 : this.end - q;\n  }\n\n  // process input based on current state\n  while (true) {\n    switch (this.mode) {\n      case IB_TYPE:\n\n        while (k < 3) {\n          if (n != 0) {\n            r = Z_OK;\n          } else {\n            this.bitb = b;this.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;z.next_in_index = p;\n            this.write = q;\n            return this.inflate_flush(z, r);\n          };\n          n--;\n          b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n        t = b & 7;\n        this.last = t & 1;\n\n        switch (t >>> 1) {\n          case 0:\n            // stored \n            {\n              b >>>= 3;k -= 3;\n            }\n            t = k & 7; // go to byte boundary\n\n            {\n              b >>>= t;k -= t;\n            }\n            this.mode = IB_LENS; // get length of stored block\n            break;\n          case 1:\n            // fixed\n            {\n              var bl = new Int32Array(1);\n              var bd = new Int32Array(1);\n              var tl = [];\n              var td = [];\n\n              inflate_trees_fixed(bl, bd, tl, td, z);\n              this.codes.init(bl[0], bd[0], tl[0], 0, td[0], 0, z);\n            }\n\n            {\n              b >>>= 3;k -= 3;\n            }\n\n            this.mode = IB_CODES;\n            break;\n          case 2:\n            // dynamic\n\n            {\n              b >>>= 3;k -= 3;\n            }\n\n            this.mode = IB_TABLE;\n            break;\n          case 3:\n            // illegal\n\n            {\n              b >>>= 3;k -= 3;\n            }\n            this.mode = BAD;\n            z.msg = \"invalid block type\";\n            r = Z_DATA_ERROR;\n\n            this.bitb = b;this.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            this.write = q;\n            return this.inflate_flush(z, r);\n        }\n        break;\n      case IB_LENS:\n        while (k < 32) {\n          if (n != 0) {\n            r = Z_OK;\n          } else {\n            this.bitb = b;this.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;z.next_in_index = p;\n            this.write = q;\n            return this.inflate_flush(z, r);\n          };\n          n--;\n          b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        if ((~b >>> 16 & 0xffff) != (b & 0xffff)) {\n          this.mode = BAD;\n          z.msg = \"invalid stored block lengths\";\n          r = Z_DATA_ERROR;\n\n          this.bitb = b;this.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          this.write = q;\n          return this.inflate_flush(z, r);\n        }\n        this.left = b & 0xffff;\n        b = k = 0; // dump bits\n        this.mode = left != 0 ? IB_STORED : this.last != 0 ? IB_DRY : IB_TYPE;\n        break;\n      case IB_STORED:\n        if (n == 0) {\n          this.bitb = b;this.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          write = q;\n          return this.inflate_flush(z, r);\n        }\n\n        if (m == 0) {\n          if (q == end && read != 0) {\n            q = 0;m = q < this.read ? this.read - q - 1 : this.end - q;\n          }\n          if (m == 0) {\n            this.write = q;\n            r = this.inflate_flush(z, r);\n            q = this.write;m = q < this.read ? this.read - q - 1 : this.end - q;\n            if (q == this.end && this.read != 0) {\n              q = 0;m = q < this.read ? this.read - q - 1 : this.end - q;\n            }\n            if (m == 0) {\n              this.bitb = b;this.bitk = k;\n              z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n              this.write = q;\n              return this.inflate_flush(z, r);\n            }\n          }\n        }\n        r = Z_OK;\n\n        t = this.left;\n        if (t > n) t = n;\n        if (t > m) t = m;\n        arrayCopy(z.next_in, p, window, q, t);\n        p += t;n -= t;\n        q += t;m -= t;\n        if ((this.left -= t) != 0) break;\n        this.mode = this.last != 0 ? IB_DRY : IB_TYPE;\n        break;\n      case IB_TABLE:\n\n        while (k < 14) {\n          if (n != 0) {\n            r = Z_OK;\n          } else {\n            this.bitb = b;this.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;z.next_in_index = p;\n            this.write = q;\n            return this.inflate_flush(z, r);\n          };\n          n--;\n          b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        this.table = t = b & 0x3fff;\n        if ((t & 0x1f) > 29 || (t >> 5 & 0x1f) > 29) {\n          this.mode = IB_BAD;\n          z.msg = \"too many length or distance symbols\";\n          r = Z_DATA_ERROR;\n\n          this.bitb = b;this.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          this.write = q;\n          return this.inflate_flush(z, r);\n        }\n        t = 258 + (t & 0x1f) + (t >> 5 & 0x1f);\n        if (this.blens == null || this.blens.length < t) {\n          this.blens = new Int32Array(t);\n        } else {\n          for (var i = 0; i < t; i++) {\n            this.blens[i] = 0;\n          }\n        }\n\n        {\n          b >>>= 14;k -= 14;\n        }\n\n        this.index = 0;\n        this.mode = IB_BTREE;\n      case IB_BTREE:\n        while (this.index < 4 + (this.table >>> 10)) {\n          while (k < 3) {\n            if (n != 0) {\n              r = Z_OK;\n            } else {\n              this.bitb = b;this.bitk = k;\n              z.avail_in = n;\n              z.total_in += p - z.next_in_index;z.next_in_index = p;\n              this.write = q;\n              return this.inflate_flush(z, r);\n            };\n            n--;\n            b |= (z.next_in[p++] & 0xff) << k;\n            k += 8;\n          }\n\n          this.blens[INFBLOCKS_BORDER[this.index++]] = b & 7;\n\n          {\n            b >>>= 3;k -= 3;\n          }\n        }\n\n        while (this.index < 19) {\n          this.blens[INFBLOCKS_BORDER[this.index++]] = 0;\n        }\n\n        this.bb[0] = 7;\n        t = this.inftree.inflate_trees_bits(this.blens, this.bb, this.tb, this.hufts, z);\n        if (t != Z_OK) {\n          r = t;\n          if (r == Z_DATA_ERROR) {\n            this.blens = null;\n            this.mode = IB_BAD;\n          }\n\n          this.bitb = b;this.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          write = q;\n          return this.inflate_flush(z, r);\n        }\n\n        this.index = 0;\n        this.mode = IB_DTREE;\n      case IB_DTREE:\n        while (true) {\n          t = this.table;\n          if (!(this.index < 258 + (t & 0x1f) + (t >> 5 & 0x1f))) {\n            break;\n          }\n\n          var h; //int[]\n          var i, j, c;\n\n          t = this.bb[0];\n\n          while (k < t) {\n            if (n != 0) {\n              r = Z_OK;\n            } else {\n              this.bitb = b;this.bitk = k;\n              z.avail_in = n;\n              z.total_in += p - z.next_in_index;z.next_in_index = p;\n              this.write = q;\n              return this.inflate_flush(z, r);\n            };\n            n--;\n            b |= (z.next_in[p++] & 0xff) << k;\n            k += 8;\n          }\n\n          //\t  if (this.tb[0]==-1){\n          //            dlog(\"null...\");\n          //\t  }\n\n          t = this.hufts[(this.tb[0] + (b & inflate_mask[t])) * 3 + 1];\n          c = this.hufts[(this.tb[0] + (b & inflate_mask[t])) * 3 + 2];\n\n          if (c < 16) {\n            b >>>= t;k -= t;\n            this.blens[this.index++] = c;\n          } else {\n            // c == 16..18\n            i = c == 18 ? 7 : c - 14;\n            j = c == 18 ? 11 : 3;\n\n            while (k < t + i) {\n              if (n != 0) {\n                r = Z_OK;\n              } else {\n                this.bitb = b;this.bitk = k;\n                z.avail_in = n;\n                z.total_in += p - z.next_in_index;z.next_in_index = p;\n                this.write = q;\n                return this.inflate_flush(z, r);\n              };\n              n--;\n              b |= (z.next_in[p++] & 0xff) << k;\n              k += 8;\n            }\n\n            b >>>= t;k -= t;\n\n            j += b & inflate_mask[i];\n\n            b >>>= i;k -= i;\n\n            i = this.index;\n            t = this.table;\n            if (i + j > 258 + (t & 0x1f) + (t >> 5 & 0x1f) || c == 16 && i < 1) {\n              this.blens = null;\n              this.mode = IB_BAD;\n              z.msg = \"invalid bit length repeat\";\n              r = Z_DATA_ERROR;\n\n              this.bitb = b;this.bitk = k;\n              z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n              this.write = q;\n              return this.inflate_flush(z, r);\n            }\n\n            c = c == 16 ? this.blens[i - 1] : 0;\n            do {\n              this.blens[i++] = c;\n            } while (--j != 0);\n            this.index = i;\n          }\n        }\n\n        this.tb[0] = -1;\n        {\n          var bl = new Int32Array(1);\n          var bd = new Int32Array(1);\n          var tl = new Int32Array(1);\n          var td = new Int32Array(1);\n          bl[0] = 9; // must be <= 9 for lookahead assumptions\n          bd[0] = 6; // must be <= 9 for lookahead assumptions\n\n          t = this.table;\n          t = this.inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + (t >> 5 & 0x1f), this.blens, bl, bd, tl, td, this.hufts, z);\n\n          if (t != Z_OK) {\n            if (t == Z_DATA_ERROR) {\n              this.blens = null;\n              this.mode = BAD;\n            }\n            r = t;\n\n            this.bitb = b;this.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            this.write = q;\n            return this.inflate_flush(z, r);\n          }\n          this.codes.init(bl[0], bd[0], this.hufts, tl[0], this.hufts, td[0], z);\n        }\n        this.mode = IB_CODES;\n      case IB_CODES:\n        this.bitb = b;this.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        this.write = q;\n\n        if ((r = this.codes.proc(this, z, r)) != Z_STREAM_END) {\n          return this.inflate_flush(z, r);\n        }\n        r = Z_OK;\n        this.codes.free(z);\n\n        p = z.next_in_index;n = z.avail_in;b = this.bitb;k = this.bitk;\n        q = this.write;m = q < this.read ? this.read - q - 1 : this.end - q;\n\n        if (this.last == 0) {\n          this.mode = IB_TYPE;\n          break;\n        }\n        this.mode = IB_DRY;\n      case IB_DRY:\n        this.write = q;\n        r = this.inflate_flush(z, r);\n        q = this.write;m = q < this.read ? this.read - q - 1 : this.end - q;\n        if (this.read != this.write) {\n          this.bitb = b;this.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          this.write = q;\n          return this.inflate_flush(z, r);\n        }\n        this.mode = DONE;\n      case IB_DONE:\n        r = Z_STREAM_END;\n\n        this.bitb = b;this.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        this.write = q;\n        return this.inflate_flush(z, r);\n      case IB_BAD:\n        r = Z_DATA_ERROR;\n\n        this.bitb = b;this.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        this.write = q;\n        return this.inflate_flush(z, r);\n\n      default:\n        r = Z_STREAM_ERROR;\n\n        this.bitb = b;this.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        this.write = q;\n        return this.inflate_flush(z, r);\n    }\n  }\n};\n\nInfBlocks.prototype.free = function (z) {\n  this.reset(z, null);\n  this.window = null;\n  this.hufts = null;\n};\n\nInfBlocks.prototype.set_dictionary = function (d, start, n) {\n  arrayCopy(d, start, window, 0, n);\n  this.read = this.write = n;\n};\n\n// Returns true if inflate is currently at the end of a block generated\n// by Z_SYNC_FLUSH or Z_FULL_FLUSH. \nInfBlocks.prototype.sync_point = function () {\n  return this.mode == IB_LENS;\n};\n\n// copy as much as possible from the sliding window to the output area\nInfBlocks.prototype.inflate_flush = function (z, r) {\n  var n;\n  var p;\n  var q;\n\n  // local copies of source and destination pointers\n  p = z.next_out_index;\n  q = this.read;\n\n  // compute number of bytes to copy as far as end of window\n  n = (q <= this.write ? this.write : this.end) - q;\n  if (n > z.avail_out) n = z.avail_out;\n  if (n != 0 && r == Z_BUF_ERROR) r = Z_OK;\n\n  // update counters\n  z.avail_out -= n;\n  z.total_out += n;\n\n  // update check information\n  if (this.checkfn != null) z.adler = this.check = z._adler.adler32(this.check, this.window, q, n);\n\n  // copy as far as end of window\n  arrayCopy(this.window, q, z.next_out, p, n);\n  p += n;\n  q += n;\n\n  // see if more to copy at beginning of window\n  if (q == this.end) {\n    // wrap pointers\n    q = 0;\n    if (this.write == this.end) this.write = 0;\n\n    // compute bytes to copy\n    n = this.write - q;\n    if (n > z.avail_out) n = z.avail_out;\n    if (n != 0 && r == Z_BUF_ERROR) r = Z_OK;\n\n    // update counters\n    z.avail_out -= n;\n    z.total_out += n;\n\n    // update check information\n    if (this.checkfn != null) z.adler = this.check = z._adler.adler32(this.check, this.window, q, n);\n\n    // copy\n    arrayCopy(this.window, q, z.next_out, p, n);\n    p += n;\n    q += n;\n  }\n\n  // update pointers\n  z.next_out_index = p;\n  this.read = q;\n\n  // done\n  return r;\n};\n\n//\n// InfCodes.java\n//\n\nvar IC_START = 0; // x: set up for LEN\nvar IC_LEN = 1; // i: get length/literal/eob next\nvar IC_LENEXT = 2; // i: getting length extra (have base)\nvar IC_DIST = 3; // i: get distance next\nvar IC_DISTEXT = 4; // i: getting distance extra\nvar IC_COPY = 5; // o: copying bytes in window, waiting for space\nvar IC_LIT = 6; // o: got literal, waiting for output space\nvar IC_WASH = 7; // o: got eob, possibly still output waiting\nvar IC_END = 8; // x: got eob and all data flushed\nvar IC_BADCODE = 9; // x: got error\n\nfunction InfCodes() {}\n\nInfCodes.prototype.init = function (bl, bd, tl, tl_index, td, td_index, z) {\n  this.mode = IC_START;\n  this.lbits = bl;\n  this.dbits = bd;\n  this.ltree = tl;\n  this.ltree_index = tl_index;\n  this.dtree = td;\n  this.dtree_index = td_index;\n  this.tree = null;\n};\n\nInfCodes.prototype.proc = function (s, z, r) {\n  var j; // temporary storage\n  var t; // temporary pointer (int[])\n  var tindex; // temporary pointer\n  var e; // extra bits or operation\n  var b = 0; // bit buffer\n  var k = 0; // bits in bit buffer\n  var p = 0; // input data pointer\n  var n; // bytes available there\n  var q; // output window write pointer\n  var m; // bytes to end of window or read pointer\n  var f; // pointer to copy strings from\n\n  // copy input/output information to locals (UPDATE macro restores)\n  p = z.next_in_index;n = z.avail_in;b = s.bitb;k = s.bitk;\n  q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n  // process input and output based on current state\n  while (true) {\n    switch (this.mode) {\n      // waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\n      case IC_START:\n        // x: set up for LEN\n        if (m >= 258 && n >= 10) {\n\n          s.bitb = b;s.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          s.write = q;\n          r = this.inflate_fast(this.lbits, this.dbits, this.ltree, this.ltree_index, this.dtree, this.dtree_index, s, z);\n\n          p = z.next_in_index;n = z.avail_in;b = s.bitb;k = s.bitk;\n          q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n          if (r != Z_OK) {\n            this.mode = r == Z_STREAM_END ? IC_WASH : IC_BADCODE;\n            break;\n          }\n        }\n        this.need = this.lbits;\n        this.tree = this.ltree;\n        this.tree_index = this.ltree_index;\n\n        this.mode = IC_LEN;\n      case IC_LEN:\n        // i: get length/literal/eob next\n        j = this.need;\n\n        while (k < j) {\n          if (n != 0) r = Z_OK;else {\n\n            s.bitb = b;s.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            s.write = q;\n            return s.inflate_flush(z, r);\n          }\n          n--;\n          b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        tindex = (this.tree_index + (b & inflate_mask[j])) * 3;\n\n        b >>>= this.tree[tindex + 1];\n        k -= this.tree[tindex + 1];\n\n        e = this.tree[tindex];\n\n        if (e == 0) {\n          // literal\n          this.lit = this.tree[tindex + 2];\n          this.mode = IC_LIT;\n          break;\n        }\n        if ((e & 16) != 0) {\n          // length\n          this.get = e & 15;\n          this.len = this.tree[tindex + 2];\n          this.mode = IC_LENEXT;\n          break;\n        }\n        if ((e & 64) == 0) {\n          // next table\n          this.need = e;\n          this.tree_index = tindex / 3 + this.tree[tindex + 2];\n          break;\n        }\n        if ((e & 32) != 0) {\n          // end of block\n          this.mode = IC_WASH;\n          break;\n        }\n        this.mode = IC_BADCODE; // invalid code\n        z.msg = \"invalid literal/length code\";\n        r = Z_DATA_ERROR;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n        return s.inflate_flush(z, r);\n\n      case IC_LENEXT:\n        // i: getting length extra (have base)\n        j = this.get;\n\n        while (k < j) {\n          if (n != 0) r = Z_OK;else {\n\n            s.bitb = b;s.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            s.write = q;\n            return s.inflate_flush(z, r);\n          }\n          n--;b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        this.len += b & inflate_mask[j];\n\n        b >>= j;\n        k -= j;\n\n        this.need = this.dbits;\n        this.tree = this.dtree;\n        this.tree_index = this.dtree_index;\n        this.mode = IC_DIST;\n      case IC_DIST:\n        // i: get distance next\n        j = this.need;\n\n        while (k < j) {\n          if (n != 0) r = Z_OK;else {\n\n            s.bitb = b;s.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            s.write = q;\n            return s.inflate_flush(z, r);\n          }\n          n--;b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        tindex = (this.tree_index + (b & inflate_mask[j])) * 3;\n\n        b >>= this.tree[tindex + 1];\n        k -= this.tree[tindex + 1];\n\n        e = this.tree[tindex];\n        if ((e & 16) != 0) {\n          // distance\n          this.get = e & 15;\n          this.dist = this.tree[tindex + 2];\n          this.mode = IC_DISTEXT;\n          break;\n        }\n        if ((e & 64) == 0) {\n          // next table\n          this.need = e;\n          this.tree_index = tindex / 3 + this.tree[tindex + 2];\n          break;\n        }\n        this.mode = IC_BADCODE; // invalid code\n        z.msg = \"invalid distance code\";\n        r = Z_DATA_ERROR;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n        return s.inflate_flush(z, r);\n\n      case IC_DISTEXT:\n        // i: getting distance extra\n        j = this.get;\n\n        while (k < j) {\n          if (n != 0) r = Z_OK;else {\n\n            s.bitb = b;s.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            s.write = q;\n            return s.inflate_flush(z, r);\n          }\n          n--;b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        this.dist += b & inflate_mask[j];\n\n        b >>= j;\n        k -= j;\n\n        this.mode = IC_COPY;\n      case IC_COPY:\n        // o: copying bytes in window, waiting for space\n        f = q - this.dist;\n        while (f < 0) {\n          // modulo window size-\"while\" instead\n          f += s.end; // of \"if\" handles invalid distances\n        }\n        while (this.len != 0) {\n\n          if (m == 0) {\n            if (q == s.end && s.read != 0) {\n              q = 0;m = q < s.read ? s.read - q - 1 : s.end - q;\n            }\n            if (m == 0) {\n              s.write = q;r = s.inflate_flush(z, r);\n              q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n              if (q == s.end && s.read != 0) {\n                q = 0;m = q < s.read ? s.read - q - 1 : s.end - q;\n              }\n\n              if (m == 0) {\n                s.bitb = b;s.bitk = k;\n                z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n                s.write = q;\n                return s.inflate_flush(z, r);\n              }\n            }\n          }\n\n          s.window[q++] = s.window[f++];m--;\n\n          if (f == s.end) f = 0;\n          this.len--;\n        }\n        this.mode = IC_START;\n        break;\n      case IC_LIT:\n        // o: got literal, waiting for output space\n        if (m == 0) {\n          if (q == s.end && s.read != 0) {\n            q = 0;m = q < s.read ? s.read - q - 1 : s.end - q;\n          }\n          if (m == 0) {\n            s.write = q;r = s.inflate_flush(z, r);\n            q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n            if (q == s.end && s.read != 0) {\n              q = 0;m = q < s.read ? s.read - q - 1 : s.end - q;\n            }\n            if (m == 0) {\n              s.bitb = b;s.bitk = k;\n              z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n              s.write = q;\n              return s.inflate_flush(z, r);\n            }\n          }\n        }\n        r = Z_OK;\n\n        s.window[q++] = this.lit;m--;\n\n        this.mode = IC_START;\n        break;\n      case IC_WASH:\n        // o: got eob, possibly more output\n        if (k > 7) {\n          // return unused byte, if any\n          k -= 8;\n          n++;\n          p--; // can always return one\n        }\n\n        s.write = q;r = s.inflate_flush(z, r);\n        q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n        if (s.read != s.write) {\n          s.bitb = b;s.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          s.write = q;\n          return s.inflate_flush(z, r);\n        }\n        this.mode = IC_END;\n      case IC_END:\n        r = Z_STREAM_END;\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n        return s.inflate_flush(z, r);\n\n      case IC_BADCODE:\n        // x: got error\n\n        r = Z_DATA_ERROR;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n        return s.inflate_flush(z, r);\n\n      default:\n        r = Z_STREAM_ERROR;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n        return s.inflate_flush(z, r);\n    }\n  }\n};\n\nInfCodes.prototype.free = function (z) {}\n//  ZFREE(z, c);\n\n\n// Called with number of bytes left to write in window at least 258\n// (the maximum string length) and number of input bytes available\n// at least ten.  The ten bytes are six bytes for the longest length/\n// distance pair plus four bytes for overloading the bit buffer.\n\n;InfCodes.prototype.inflate_fast = function (bl, bd, tl, tl_index, td, td_index, s, z) {\n  var t; // temporary pointer\n  var tp; // temporary pointer (int[])\n  var tp_index; // temporary pointer\n  var e; // extra bits or operation\n  var b; // bit buffer\n  var k; // bits in bit buffer\n  var p; // input data pointer\n  var n; // bytes available there\n  var q; // output window write pointer\n  var m; // bytes to end of window or read pointer\n  var ml; // mask for literal/length tree\n  var md; // mask for distance tree\n  var c; // bytes to copy\n  var d; // distance back to copy from\n  var r; // copy source pointer\n\n  var tp_index_t_3; // (tp_index+t)*3\n\n  // load input, output, bit values\n  p = z.next_in_index;n = z.avail_in;b = s.bitb;k = s.bitk;\n  q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n  // initialize masks\n  ml = inflate_mask[bl];\n  md = inflate_mask[bd];\n\n  // do until not enough input or output space for fast loop\n  do {\n    // assume called with m >= 258 && n >= 10\n    // get literal/length code\n    while (k < 20) {\n      // max bits for literal/length code\n      n--;\n      b |= (z.next_in[p++] & 0xff) << k;k += 8;\n    }\n\n    t = b & ml;\n    tp = tl;\n    tp_index = tl_index;\n    tp_index_t_3 = (tp_index + t) * 3;\n    if ((e = tp[tp_index_t_3]) == 0) {\n      b >>= tp[tp_index_t_3 + 1];k -= tp[tp_index_t_3 + 1];\n\n      s.window[q++] = tp[tp_index_t_3 + 2];\n      m--;\n      continue;\n    }\n    do {\n\n      b >>= tp[tp_index_t_3 + 1];k -= tp[tp_index_t_3 + 1];\n\n      if ((e & 16) != 0) {\n        e &= 15;\n        c = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);\n\n        b >>= e;k -= e;\n\n        // decode distance base of block to copy\n        while (k < 15) {\n          // max bits for distance code\n          n--;\n          b |= (z.next_in[p++] & 0xff) << k;k += 8;\n        }\n\n        t = b & md;\n        tp = td;\n        tp_index = td_index;\n        tp_index_t_3 = (tp_index + t) * 3;\n        e = tp[tp_index_t_3];\n\n        do {\n\n          b >>= tp[tp_index_t_3 + 1];k -= tp[tp_index_t_3 + 1];\n\n          if ((e & 16) != 0) {\n            // get extra bits to add to distance base\n            e &= 15;\n            while (k < e) {\n              // get extra bits (up to 13)\n              n--;\n              b |= (z.next_in[p++] & 0xff) << k;k += 8;\n            }\n\n            d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);\n\n            b >>= e;k -= e;\n\n            // do the copy\n            m -= c;\n            if (q >= d) {\n              // offset before dest\n              //  just copy\n              r = q - d;\n              if (q - r > 0 && 2 > q - r) {\n                s.window[q++] = s.window[r++]; // minimum count is three,\n                s.window[q++] = s.window[r++]; // so unroll loop a little\n                c -= 2;\n              } else {\n                s.window[q++] = s.window[r++]; // minimum count is three,\n                s.window[q++] = s.window[r++]; // so unroll loop a little\n                c -= 2;\n              }\n            } else {\n              // else offset after destination\n              r = q - d;\n              do {\n                r += s.end; // force pointer in window\n              } while (r < 0); // covers invalid distances\n              e = s.end - r;\n              if (c > e) {\n                // if source crosses,\n                c -= e; // wrapped copy\n                if (q - r > 0 && e > q - r) {\n                  do {\n                    s.window[q++] = s.window[r++];\n                  } while (--e != 0);\n                } else {\n                  arrayCopy(s.window, r, s.window, q, e);\n                  q += e;r += e;e = 0;\n                }\n                r = 0; // copy rest from start of window\n              }\n            }\n\n            // copy all or what's left\n            do {\n              s.window[q++] = s.window[r++];\n            } while (--c != 0);\n            break;\n          } else if ((e & 64) == 0) {\n            t += tp[tp_index_t_3 + 2];\n            t += b & inflate_mask[e];\n            tp_index_t_3 = (tp_index + t) * 3;\n            e = tp[tp_index_t_3];\n          } else {\n            z.msg = \"invalid distance code\";\n\n            c = z.avail_in - n;c = k >> 3 < c ? k >> 3 : c;n += c;p -= c;k -= c << 3;\n\n            s.bitb = b;s.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            s.write = q;\n\n            return Z_DATA_ERROR;\n          }\n        } while (true);\n        break;\n      }\n\n      if ((e & 64) == 0) {\n        t += tp[tp_index_t_3 + 2];\n        t += b & inflate_mask[e];\n        tp_index_t_3 = (tp_index + t) * 3;\n        if ((e = tp[tp_index_t_3]) == 0) {\n\n          b >>= tp[tp_index_t_3 + 1];k -= tp[tp_index_t_3 + 1];\n\n          s.window[q++] = tp[tp_index_t_3 + 2];\n          m--;\n          break;\n        }\n      } else if ((e & 32) != 0) {\n\n        c = z.avail_in - n;c = k >> 3 < c ? k >> 3 : c;n += c;p -= c;k -= c << 3;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n\n        return Z_STREAM_END;\n      } else {\n        z.msg = \"invalid literal/length code\";\n\n        c = z.avail_in - n;c = k >> 3 < c ? k >> 3 : c;n += c;p -= c;k -= c << 3;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n\n        return Z_DATA_ERROR;\n      }\n    } while (true);\n  } while (m >= 258 && n >= 10);\n\n  // not enough input or output--restore pointers and return\n  c = z.avail_in - n;c = k >> 3 < c ? k >> 3 : c;n += c;p -= c;k -= c << 3;\n\n  s.bitb = b;s.bitk = k;\n  z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n  s.write = q;\n\n  return Z_OK;\n};\n\n//\n// InfTree.java\n//\n\nfunction InfTree() {}\n\nInfTree.prototype.huft_build = function (b, bindex, n, s, d, e, t, m, hp, hn, v) {\n\n  // Given a list of code lengths and a maximum table size, make a set of\n  // tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR\n  // if the given code set is incomplete (the tables are still built in this\n  // case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of\n  // lengths), or Z_MEM_ERROR if not enough memory.\n\n  var a; // counter for codes of length k\n  var f; // i repeats in table every f entries\n  var g; // maximum code length\n  var h; // table level\n  var i; // counter, current code\n  var j; // counter\n  var k; // number of bits in current code\n  var l; // bits per table (returned in m)\n  var mask; // (1 << w) - 1, to avoid cc -O bug on HP\n  var p; // pointer into c[], b[], or v[]\n  var q; // points to current table\n  var w; // bits before this table == (l * h)\n  var xp; // pointer into x\n  var y; // number of dummy codes added\n  var z; // number of entries in current table\n\n  // Generate counts for each bit length\n\n  p = 0;i = n;\n  do {\n    this.c[b[bindex + p]]++;p++;i--; // assume all entries <= BMAX\n  } while (i != 0);\n\n  if (this.c[0] == n) {\n    // null input--all zero length codes\n    t[0] = -1;\n    m[0] = 0;\n    return Z_OK;\n  }\n\n  // Find minimum and maximum length, bound *m by those\n  l = m[0];\n  for (j = 1; j <= BMAX; j++) {\n    if (this.c[j] != 0) break;\n  }k = j; // minimum code length\n  if (l < j) {\n    l = j;\n  }\n  for (i = BMAX; i != 0; i--) {\n    if (this.c[i] != 0) break;\n  }\n  g = i; // maximum code length\n  if (l > i) {\n    l = i;\n  }\n  m[0] = l;\n\n  // Adjust last length count to fill out codes, if needed\n  for (y = 1 << j; j < i; j++, y <<= 1) {\n    if ((y -= this.c[j]) < 0) {\n      return Z_DATA_ERROR;\n    }\n  }\n  if ((y -= this.c[i]) < 0) {\n    return Z_DATA_ERROR;\n  }\n  this.c[i] += y;\n\n  // Generate starting offsets into the value table for each length\n  this.x[1] = j = 0;\n  p = 1;xp = 2;\n  while (--i != 0) {\n    // note that i == g from above\n    this.x[xp] = j += this.c[p];\n    xp++;\n    p++;\n  }\n\n  // Make a table of values in order of bit lengths\n  i = 0;p = 0;\n  do {\n    if ((j = b[bindex + p]) != 0) {\n      this.v[this.x[j]++] = i;\n    }\n    p++;\n  } while (++i < n);\n  n = this.x[g]; // set n to length of v\n\n  // Generate the Huffman codes and for each, make the table entries\n  this.x[0] = i = 0; // first Huffman code is zero\n  p = 0; // grab values in bit order\n  h = -1; // no tables yet--level -1\n  w = -l; // bits decoded == (l * h)\n  this.u[0] = 0; // just to keep compilers happy\n  q = 0; // ditto\n  z = 0; // ditto\n\n  // go through the bit lengths (k already is bits in shortest code)\n  for (; k <= g; k++) {\n    a = this.c[k];\n    while (a-- != 0) {\n      // here i is the Huffman code of length k bits for value *p\n      // make tables up to required level\n      while (k > w + l) {\n        h++;\n        w += l; // previous table always l bits\n        // compute minimum size table less than or equal to l bits\n        z = g - w;\n        z = z > l ? l : z; // table size upper limit\n        if ((f = 1 << (j = k - w)) > a + 1) {\n          // try a k-w bit table\n          // too few codes for k-w bit table\n          f -= a + 1; // deduct codes from patterns left\n          xp = k;\n          if (j < z) {\n            while (++j < z) {\n              // try smaller tables up to z bits\n              if ((f <<= 1) <= this.c[++xp]) break; // enough codes to use up j bits\n              f -= this.c[xp]; // else deduct codes from patterns\n            }\n          }\n        }\n        z = 1 << j; // table entries for j-bit table\n\n        // allocate new table\n        if (this.hn[0] + z > MANY) {\n          // (note: doesn't matter for fixed)\n          return Z_DATA_ERROR; // overflow of MANY\n        }\n        this.u[h] = q = /*hp+*/this.hn[0]; // DEBUG\n        this.hn[0] += z;\n\n        // connect to last table, if there is one\n        if (h != 0) {\n          this.x[h] = i; // save pattern for backing up\n          this.r[0] = j; // bits in this table\n          this.r[1] = l; // bits to dump before this table\n          j = i >>> w - l;\n          this.r[2] = q - this.u[h - 1] - j; // offset to this table\n          arrayCopy(this.r, 0, hp, (this.u[h - 1] + j) * 3, 3); // connect to last table\n        } else {\n          t[0] = q; // first table is returned result\n        }\n      }\n\n      // set up table entry in r\n      this.r[1] = k - w;\n      if (p >= n) {\n        this.r[0] = 128 + 64; // out of values--invalid code\n      } else if (v[p] < s) {\n        this.r[0] = this.v[p] < 256 ? 0 : 32 + 64; // 256 is end-of-block\n        this.r[2] = this.v[p++]; // simple code is just the value\n      } else {\n        this.r[0] = e[this.v[p] - s] + 16 + 64; // non-simple--look up in lists\n        this.r[2] = d[this.v[p++] - s];\n      }\n\n      // fill code-like entries with r\n      f = 1 << k - w;\n      for (j = i >>> w; j < z; j += f) {\n        arrayCopy(this.r, 0, hp, (q + j) * 3, 3);\n      }\n\n      // backwards increment the k-bit code i\n      for (j = 1 << k - 1; (i & j) != 0; j >>>= 1) {\n        i ^= j;\n      }\n      i ^= j;\n\n      // backup over finished tables\n      mask = (1 << w) - 1; // needed on HP, cc -O bug\n      while ((i & mask) != this.x[h]) {\n        h--; // don't need to update q\n        w -= l;\n        mask = (1 << w) - 1;\n      }\n    }\n  }\n  // Return Z_BUF_ERROR if we were given an incomplete table\n  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n};\n\nInfTree.prototype.inflate_trees_bits = function (c, bb, tb, hp, z) {\n  var result;\n  this.initWorkArea(19);\n  this.hn[0] = 0;\n  result = this.huft_build(c, 0, 19, 19, null, null, tb, bb, hp, this.hn, this.v);\n\n  if (result == Z_DATA_ERROR) {\n    z.msg = \"oversubscribed dynamic bit lengths tree\";\n  } else if (result == Z_BUF_ERROR || bb[0] == 0) {\n    z.msg = \"incomplete dynamic bit lengths tree\";\n    result = Z_DATA_ERROR;\n  }\n  return result;\n};\n\nInfTree.prototype.inflate_trees_dynamic = function (nl, nd, c, bl, bd, tl, td, hp, z) {\n  var result;\n\n  // build literal/length tree\n  this.initWorkArea(288);\n  this.hn[0] = 0;\n  result = this.huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, this.hn, this.v);\n  if (result != Z_OK || bl[0] == 0) {\n    if (result == Z_DATA_ERROR) {\n      z.msg = \"oversubscribed literal/length tree\";\n    } else if (result != Z_MEM_ERROR) {\n      z.msg = \"incomplete literal/length tree\";\n      result = Z_DATA_ERROR;\n    }\n    return result;\n  }\n\n  // build distance tree\n  this.initWorkArea(288);\n  result = this.huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, this.hn, this.v);\n\n  if (result != Z_OK || bd[0] == 0 && nl > 257) {\n    if (result == Z_DATA_ERROR) {\n      z.msg = \"oversubscribed distance tree\";\n    } else if (result == Z_BUF_ERROR) {\n      z.msg = \"incomplete distance tree\";\n      result = Z_DATA_ERROR;\n    } else if (result != Z_MEM_ERROR) {\n      z.msg = \"empty distance tree with lengths\";\n      result = Z_DATA_ERROR;\n    }\n    return result;\n  }\n\n  return Z_OK;\n};\n/*\n  static int inflate_trees_fixed(int[] bl,  //literal desired/actual bit depth\n                                 int[] bd,  //distance desired/actual bit depth\n                                 int[][] tl,//literal/length tree result\n                                 int[][] td,//distance tree result \n                                 ZStream z  //for memory allocation\n\t\t\t\t ){\n\n*/\n\nfunction inflate_trees_fixed(bl, bd, tl, td, z) {\n  bl[0] = fixed_bl;\n  bd[0] = fixed_bd;\n  tl[0] = fixed_tl;\n  td[0] = fixed_td;\n  return Z_OK;\n}\n\nInfTree.prototype.initWorkArea = function (vsize) {\n  if (this.hn == null) {\n    this.hn = new Int32Array(1);\n    this.v = new Int32Array(vsize);\n    this.c = new Int32Array(BMAX + 1);\n    this.r = new Int32Array(3);\n    this.u = new Int32Array(BMAX);\n    this.x = new Int32Array(BMAX + 1);\n  }\n  if (this.v.length < vsize) {\n    this.v = new Int32Array(vsize);\n  }\n  for (var i = 0; i < vsize; i++) {\n    this.v[i] = 0;\n  }\n  for (var i = 0; i < BMAX + 1; i++) {\n    this.c[i] = 0;\n  }\n  for (var i = 0; i < 3; i++) {\n    this.r[i] = 0;\n  }\n  //  for(int i=0; i<BMAX; i++){u[i]=0;}\n  arrayCopy(this.c, 0, this.u, 0, BMAX);\n  //  for(int i=0; i<BMAX+1; i++){x[i]=0;}\n  arrayCopy(this.c, 0, this.x, 0, BMAX + 1);\n};\n\nvar testArray = new Uint8Array(1);\nvar hasSubarray = typeof testArray.subarray === 'function';\nvar hasSlice = false; /* (typeof testArray.slice === 'function'); */ // Chrome slice performance is so dire that we're currently not using it...\n\nfunction arrayCopy(src, srcOffset, dest, destOffset, count) {\n  if (count == 0) {\n    return;\n  }\n  if (!src) {\n    throw \"Undef src\";\n  } else if (!dest) {\n    throw \"Undef dest\";\n  }\n\n  if (srcOffset == 0 && count == src.length) {\n    arrayCopy_fast(src, dest, destOffset);\n  } else if (hasSubarray) {\n    arrayCopy_fast(src.subarray(srcOffset, srcOffset + count), dest, destOffset);\n  } else if (src.BYTES_PER_ELEMENT == 1 && count > 100) {\n    arrayCopy_fast(new Uint8Array(src.buffer, src.byteOffset + srcOffset, count), dest, destOffset);\n  } else {\n    arrayCopy_slow(src, srcOffset, dest, destOffset, count);\n  }\n}\n\nfunction arrayCopy_slow(src, srcOffset, dest, destOffset, count) {\n\n  // dlog('_slow call: srcOffset=' + srcOffset + '; destOffset=' + destOffset + '; count=' + count);\n\n  for (var i = 0; i < count; ++i) {\n    dest[destOffset + i] = src[srcOffset + i];\n  }\n}\n\nfunction arrayCopy_fast(src, dest, destOffset) {\n  dest.set(src, destOffset);\n}\n\n// largest prime smaller than 65536\nvar ADLER_BASE = 65521;\n// NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1\nvar ADLER_NMAX = 5552;\n\nfunction adler32(adler, /* byte[] */buf, index, len) {\n  if (buf == null) {\n    return 1;\n  }\n\n  var s1 = adler & 0xffff;\n  var s2 = adler >> 16 & 0xffff;\n  var k;\n\n  while (len > 0) {\n    k = len < ADLER_NMAX ? len : ADLER_NMAX;\n    len -= k;\n    while (k >= 16) {\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      k -= 16;\n    }\n    if (k != 0) {\n      do {\n        s1 += buf[index++] & 0xff;s2 += s1;\n      } while (--k != 0);\n    }\n    s1 %= ADLER_BASE;\n    s2 %= ADLER_BASE;\n  }\n  return s2 << 16 | s1;\n}\n\nfunction jszlib_inflate_buffer(buffer, start, length, afterUncOffset) {\n  if (!start) {\n    buffer = new Uint8Array(buffer);\n  } else {\n    buffer = new Uint8Array(buffer, start, length);\n  }\n\n  var z = new ZStream();\n  z.inflateInit(DEF_WBITS, true);\n  z.next_in = buffer;\n  z.next_in_index = 0;\n  z.avail_in = buffer.length;\n\n  var oBlockList = [];\n  var totalSize = 0;\n  while (true) {\n    var obuf = new Uint8Array(32000);\n    z.next_out = obuf;\n    z.next_out_index = 0;\n    z.avail_out = obuf.length;\n    var status = z.inflate(Z_NO_FLUSH);\n    if (status != Z_OK && status != Z_STREAM_END) {\n      throw z.msg;\n    }\n    if (z.avail_out != 0) {\n      var newob = new Uint8Array(obuf.length - z.avail_out);\n      arrayCopy(obuf, 0, newob, 0, obuf.length - z.avail_out);\n      obuf = newob;\n    }\n    oBlockList.push(obuf);\n    totalSize += obuf.length;\n    if (status == Z_STREAM_END) {\n      break;\n    }\n  }\n\n  if (afterUncOffset) {\n    afterUncOffset[0] = (start || 0) + z.next_in_index;\n  }\n\n  if (oBlockList.length == 1) {\n    return oBlockList[0].buffer;\n  } else {\n    var out = new Uint8Array(totalSize);\n    var cursor = 0;\n    for (var i = 0; i < oBlockList.length; ++i) {\n      var b = oBlockList[i];\n      arrayCopy(b, 0, out, cursor, b.length);\n      cursor += b.length;\n    }\n    return out.buffer;\n  }\n}\n\nexports.jszlib_inflate_buffer = jszlib_inflate_buffer;\nexports.arrayCopy = arrayCopy;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmVuZG9yL2luZmxhdGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3ZlbmRvci9pbmZsYXRlLmpzPzkxZTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gSmF2YXNjcmlwdCBaTGliXG4vLyBCeSBUaG9tYXMgRG93biAyMDEwLTIwMTFcbi8vXG4vLyBCYXNlZCB2ZXJ5IGhlYXZpbHkgb24gcG9ydGlvbnMgb2YganpsaWIgKGJ5IHltbmtAamNyYWZ0LmNvbSksIHdobyBpblxuLy8gdHVybiBjcmVkaXRzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXIgZm9yIHRoZSBvcmlnaW5hbCB6bGliIGNvZGUuXG4vL1xuLy8gaW5mbGF0ZS5qczogWkxpYiBpbmZsYXRlIGNvZGVcbi8vXG5cbi8vXG4vLyBTaGFyZWQgY29uc3RhbnRzXG4vL1xuXG52YXIgTUFYX1dCSVRTPTE1OyAvLyAzMksgTFo3NyB3aW5kb3dcbnZhciBERUZfV0JJVFM9TUFYX1dCSVRTO1xudmFyIE1BWF9NRU1fTEVWRUw9OTtcbnZhciBNQU5ZPTE0NDA7XG52YXIgQk1BWCA9IDE1O1xuXG4vLyBwcmVzZXQgZGljdGlvbmFyeSBmbGFnIGluIHpsaWIgaGVhZGVyXG52YXIgUFJFU0VUX0RJQ1Q9MHgyMDtcblxudmFyIFpfTk9fRkxVU0g9MDtcbnZhciBaX1BBUlRJQUxfRkxVU0g9MTtcbnZhciBaX1NZTkNfRkxVU0g9MjtcbnZhciBaX0ZVTExfRkxVU0g9MztcbnZhciBaX0ZJTklTSD00O1xuXG52YXIgWl9ERUZMQVRFRD04O1xuXG52YXIgWl9PSz0wO1xudmFyIFpfU1RSRUFNX0VORD0xO1xudmFyIFpfTkVFRF9ESUNUPTI7XG52YXIgWl9FUlJOTz0tMTtcbnZhciBaX1NUUkVBTV9FUlJPUj0tMjtcbnZhciBaX0RBVEFfRVJST1I9LTM7XG52YXIgWl9NRU1fRVJST1I9LTQ7XG52YXIgWl9CVUZfRVJST1I9LTU7XG52YXIgWl9WRVJTSU9OX0VSUk9SPS02O1xuXG52YXIgTUVUSE9EPTA7ICAgLy8gd2FpdGluZyBmb3IgbWV0aG9kIGJ5dGVcbnZhciBGTEFHPTE7ICAgICAvLyB3YWl0aW5nIGZvciBmbGFnIGJ5dGVcbnZhciBESUNUND0yOyAgICAvLyBmb3VyIGRpY3Rpb25hcnkgY2hlY2sgYnl0ZXMgdG8gZ29cbnZhciBESUNUMz0zOyAgICAvLyB0aHJlZSBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGVzIHRvIGdvXG52YXIgRElDVDI9NDsgICAgLy8gdHdvIGRpY3Rpb25hcnkgY2hlY2sgYnl0ZXMgdG8gZ29cbnZhciBESUNUMT01OyAgICAvLyBvbmUgZGljdGlvbmFyeSBjaGVjayBieXRlIHRvIGdvXG52YXIgRElDVDA9NjsgICAgLy8gd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnlcbnZhciBCTE9DS1M9NzsgICAvLyBkZWNvbXByZXNzaW5nIGJsb2Nrc1xudmFyIENIRUNLND04OyAgIC8vIGZvdXIgY2hlY2sgYnl0ZXMgdG8gZ29cbnZhciBDSEVDSzM9OTsgICAvLyB0aHJlZSBjaGVjayBieXRlcyB0byBnb1xudmFyIENIRUNLMj0xMDsgIC8vIHR3byBjaGVjayBieXRlcyB0byBnb1xudmFyIENIRUNLMT0xMTsgIC8vIG9uZSBjaGVjayBieXRlIHRvIGdvXG52YXIgRE9ORT0xMjsgICAgLy8gZmluaXNoZWQgY2hlY2ssIGRvbmVcbnZhciBCQUQ9MTM7ICAgICAvLyBnb3QgYW4gZXJyb3ItLXN0YXkgaGVyZVxuXG52YXIgaW5mbGF0ZV9tYXNrID0gWzB4MDAwMDAwMDAsIDB4MDAwMDAwMDEsIDB4MDAwMDAwMDMsIDB4MDAwMDAwMDcsIDB4MDAwMDAwMGYsIDB4MDAwMDAwMWYsIDB4MDAwMDAwM2YsIDB4MDAwMDAwN2YsIDB4MDAwMDAwZmYsIDB4MDAwMDAxZmYsIDB4MDAwMDAzZmYsIDB4MDAwMDA3ZmYsIDB4MDAwMDBmZmYsIDB4MDAwMDFmZmYsIDB4MDAwMDNmZmYsIDB4MDAwMDdmZmYsIDB4MDAwMGZmZmZdO1xuXG52YXIgSUJfVFlQRT0wOyAgLy8gZ2V0IHR5cGUgYml0cyAoMywgaW5jbHVkaW5nIGVuZCBiaXQpXG52YXIgSUJfTEVOUz0xOyAgLy8gZ2V0IGxlbmd0aHMgZm9yIHN0b3JlZFxudmFyIElCX1NUT1JFRD0yOy8vIHByb2Nlc3Npbmcgc3RvcmVkIGJsb2NrXG52YXIgSUJfVEFCTEU9MzsgLy8gZ2V0IHRhYmxlIGxlbmd0aHNcbnZhciBJQl9CVFJFRT00OyAvLyBnZXQgYml0IGxlbmd0aHMgdHJlZSBmb3IgYSBkeW5hbWljIGJsb2NrXG52YXIgSUJfRFRSRUU9NTsgLy8gZ2V0IGxlbmd0aCwgZGlzdGFuY2UgdHJlZXMgZm9yIGEgZHluYW1pYyBibG9ja1xudmFyIElCX0NPREVTPTY7IC8vIHByb2Nlc3NpbmcgZml4ZWQgb3IgZHluYW1pYyBibG9ja1xudmFyIElCX0RSWT03OyAgIC8vIG91dHB1dCByZW1haW5pbmcgd2luZG93IGJ5dGVzXG52YXIgSUJfRE9ORT04OyAgLy8gZmluaXNoZWQgbGFzdCBibG9jaywgZG9uZVxudmFyIElCX0JBRD05OyAgIC8vIG90IGEgZGF0YSBlcnJvci0tc3R1Y2sgaGVyZVxuXG52YXIgZml4ZWRfYmwgPSA5O1xudmFyIGZpeGVkX2JkID0gNTtcblxudmFyIGZpeGVkX3RsID0gW1xuICAgIDk2LDcsMjU2LCAwLDgsODAsIDAsOCwxNiwgODQsOCwxMTUsXG4gICAgODIsNywzMSwgMCw4LDExMiwgMCw4LDQ4LCAwLDksMTkyLFxuICAgIDgwLDcsMTAsIDAsOCw5NiwgMCw4LDMyLCAwLDksMTYwLFxuICAgIDAsOCwwLCAwLDgsMTI4LCAwLDgsNjQsIDAsOSwyMjQsXG4gICAgODAsNyw2LCAwLDgsODgsIDAsOCwyNCwgMCw5LDE0NCxcbiAgICA4Myw3LDU5LCAwLDgsMTIwLCAwLDgsNTYsIDAsOSwyMDgsXG4gICAgODEsNywxNywgMCw4LDEwNCwgMCw4LDQwLCAwLDksMTc2LFxuICAgIDAsOCw4LCAwLDgsMTM2LCAwLDgsNzIsIDAsOSwyNDAsXG4gICAgODAsNyw0LCAwLDgsODQsIDAsOCwyMCwgODUsOCwyMjcsXG4gICAgODMsNyw0MywgMCw4LDExNiwgMCw4LDUyLCAwLDksMjAwLFxuICAgIDgxLDcsMTMsIDAsOCwxMDAsIDAsOCwzNiwgMCw5LDE2OCxcbiAgICAwLDgsNCwgMCw4LDEzMiwgMCw4LDY4LCAwLDksMjMyLFxuICAgIDgwLDcsOCwgMCw4LDkyLCAwLDgsMjgsIDAsOSwxNTIsXG4gICAgODQsNyw4MywgMCw4LDEyNCwgMCw4LDYwLCAwLDksMjE2LFxuICAgIDgyLDcsMjMsIDAsOCwxMDgsIDAsOCw0NCwgMCw5LDE4NCxcbiAgICAwLDgsMTIsIDAsOCwxNDAsIDAsOCw3NiwgMCw5LDI0OCxcbiAgICA4MCw3LDMsIDAsOCw4MiwgMCw4LDE4LCA4NSw4LDE2MyxcbiAgICA4Myw3LDM1LCAwLDgsMTE0LCAwLDgsNTAsIDAsOSwxOTYsXG4gICAgODEsNywxMSwgMCw4LDk4LCAwLDgsMzQsIDAsOSwxNjQsXG4gICAgMCw4LDIsIDAsOCwxMzAsIDAsOCw2NiwgMCw5LDIyOCxcbiAgICA4MCw3LDcsIDAsOCw5MCwgMCw4LDI2LCAwLDksMTQ4LFxuICAgIDg0LDcsNjcsIDAsOCwxMjIsIDAsOCw1OCwgMCw5LDIxMixcbiAgICA4Miw3LDE5LCAwLDgsMTA2LCAwLDgsNDIsIDAsOSwxODAsXG4gICAgMCw4LDEwLCAwLDgsMTM4LCAwLDgsNzQsIDAsOSwyNDQsXG4gICAgODAsNyw1LCAwLDgsODYsIDAsOCwyMiwgMTkyLDgsMCxcbiAgICA4Myw3LDUxLCAwLDgsMTE4LCAwLDgsNTQsIDAsOSwyMDQsXG4gICAgODEsNywxNSwgMCw4LDEwMiwgMCw4LDM4LCAwLDksMTcyLFxuICAgIDAsOCw2LCAwLDgsMTM0LCAwLDgsNzAsIDAsOSwyMzYsXG4gICAgODAsNyw5LCAwLDgsOTQsIDAsOCwzMCwgMCw5LDE1NixcbiAgICA4NCw3LDk5LCAwLDgsMTI2LCAwLDgsNjIsIDAsOSwyMjAsXG4gICAgODIsNywyNywgMCw4LDExMCwgMCw4LDQ2LCAwLDksMTg4LFxuICAgIDAsOCwxNCwgMCw4LDE0MiwgMCw4LDc4LCAwLDksMjUyLFxuICAgIDk2LDcsMjU2LCAwLDgsODEsIDAsOCwxNywgODUsOCwxMzEsXG4gICAgODIsNywzMSwgMCw4LDExMywgMCw4LDQ5LCAwLDksMTk0LFxuICAgIDgwLDcsMTAsIDAsOCw5NywgMCw4LDMzLCAwLDksMTYyLFxuICAgIDAsOCwxLCAwLDgsMTI5LCAwLDgsNjUsIDAsOSwyMjYsXG4gICAgODAsNyw2LCAwLDgsODksIDAsOCwyNSwgMCw5LDE0NixcbiAgICA4Myw3LDU5LCAwLDgsMTIxLCAwLDgsNTcsIDAsOSwyMTAsXG4gICAgODEsNywxNywgMCw4LDEwNSwgMCw4LDQxLCAwLDksMTc4LFxuICAgIDAsOCw5LCAwLDgsMTM3LCAwLDgsNzMsIDAsOSwyNDIsXG4gICAgODAsNyw0LCAwLDgsODUsIDAsOCwyMSwgODAsOCwyNTgsXG4gICAgODMsNyw0MywgMCw4LDExNywgMCw4LDUzLCAwLDksMjAyLFxuICAgIDgxLDcsMTMsIDAsOCwxMDEsIDAsOCwzNywgMCw5LDE3MCxcbiAgICAwLDgsNSwgMCw4LDEzMywgMCw4LDY5LCAwLDksMjM0LFxuICAgIDgwLDcsOCwgMCw4LDkzLCAwLDgsMjksIDAsOSwxNTQsXG4gICAgODQsNyw4MywgMCw4LDEyNSwgMCw4LDYxLCAwLDksMjE4LFxuICAgIDgyLDcsMjMsIDAsOCwxMDksIDAsOCw0NSwgMCw5LDE4NixcbiAgICAwLDgsMTMsIDAsOCwxNDEsIDAsOCw3NywgMCw5LDI1MCxcbiAgICA4MCw3LDMsIDAsOCw4MywgMCw4LDE5LCA4NSw4LDE5NSxcbiAgICA4Myw3LDM1LCAwLDgsMTE1LCAwLDgsNTEsIDAsOSwxOTgsXG4gICAgODEsNywxMSwgMCw4LDk5LCAwLDgsMzUsIDAsOSwxNjYsXG4gICAgMCw4LDMsIDAsOCwxMzEsIDAsOCw2NywgMCw5LDIzMCxcbiAgICA4MCw3LDcsIDAsOCw5MSwgMCw4LDI3LCAwLDksMTUwLFxuICAgIDg0LDcsNjcsIDAsOCwxMjMsIDAsOCw1OSwgMCw5LDIxNCxcbiAgICA4Miw3LDE5LCAwLDgsMTA3LCAwLDgsNDMsIDAsOSwxODIsXG4gICAgMCw4LDExLCAwLDgsMTM5LCAwLDgsNzUsIDAsOSwyNDYsXG4gICAgODAsNyw1LCAwLDgsODcsIDAsOCwyMywgMTkyLDgsMCxcbiAgICA4Myw3LDUxLCAwLDgsMTE5LCAwLDgsNTUsIDAsOSwyMDYsXG4gICAgODEsNywxNSwgMCw4LDEwMywgMCw4LDM5LCAwLDksMTc0LFxuICAgIDAsOCw3LCAwLDgsMTM1LCAwLDgsNzEsIDAsOSwyMzgsXG4gICAgODAsNyw5LCAwLDgsOTUsIDAsOCwzMSwgMCw5LDE1OCxcbiAgICA4NCw3LDk5LCAwLDgsMTI3LCAwLDgsNjMsIDAsOSwyMjIsXG4gICAgODIsNywyNywgMCw4LDExMSwgMCw4LDQ3LCAwLDksMTkwLFxuICAgIDAsOCwxNSwgMCw4LDE0MywgMCw4LDc5LCAwLDksMjU0LFxuICAgIDk2LDcsMjU2LCAwLDgsODAsIDAsOCwxNiwgODQsOCwxMTUsXG4gICAgODIsNywzMSwgMCw4LDExMiwgMCw4LDQ4LCAwLDksMTkzLFxuXG4gICAgODAsNywxMCwgMCw4LDk2LCAwLDgsMzIsIDAsOSwxNjEsXG4gICAgMCw4LDAsIDAsOCwxMjgsIDAsOCw2NCwgMCw5LDIyNSxcbiAgICA4MCw3LDYsIDAsOCw4OCwgMCw4LDI0LCAwLDksMTQ1LFxuICAgIDgzLDcsNTksIDAsOCwxMjAsIDAsOCw1NiwgMCw5LDIwOSxcbiAgICA4MSw3LDE3LCAwLDgsMTA0LCAwLDgsNDAsIDAsOSwxNzcsXG4gICAgMCw4LDgsIDAsOCwxMzYsIDAsOCw3MiwgMCw5LDI0MSxcbiAgICA4MCw3LDQsIDAsOCw4NCwgMCw4LDIwLCA4NSw4LDIyNyxcbiAgICA4Myw3LDQzLCAwLDgsMTE2LCAwLDgsNTIsIDAsOSwyMDEsXG4gICAgODEsNywxMywgMCw4LDEwMCwgMCw4LDM2LCAwLDksMTY5LFxuICAgIDAsOCw0LCAwLDgsMTMyLCAwLDgsNjgsIDAsOSwyMzMsXG4gICAgODAsNyw4LCAwLDgsOTIsIDAsOCwyOCwgMCw5LDE1MyxcbiAgICA4NCw3LDgzLCAwLDgsMTI0LCAwLDgsNjAsIDAsOSwyMTcsXG4gICAgODIsNywyMywgMCw4LDEwOCwgMCw4LDQ0LCAwLDksMTg1LFxuICAgIDAsOCwxMiwgMCw4LDE0MCwgMCw4LDc2LCAwLDksMjQ5LFxuICAgIDgwLDcsMywgMCw4LDgyLCAwLDgsMTgsIDg1LDgsMTYzLFxuICAgIDgzLDcsMzUsIDAsOCwxMTQsIDAsOCw1MCwgMCw5LDE5NyxcbiAgICA4MSw3LDExLCAwLDgsOTgsIDAsOCwzNCwgMCw5LDE2NSxcbiAgICAwLDgsMiwgMCw4LDEzMCwgMCw4LDY2LCAwLDksMjI5LFxuICAgIDgwLDcsNywgMCw4LDkwLCAwLDgsMjYsIDAsOSwxNDksXG4gICAgODQsNyw2NywgMCw4LDEyMiwgMCw4LDU4LCAwLDksMjEzLFxuICAgIDgyLDcsMTksIDAsOCwxMDYsIDAsOCw0MiwgMCw5LDE4MSxcbiAgICAwLDgsMTAsIDAsOCwxMzgsIDAsOCw3NCwgMCw5LDI0NSxcbiAgICA4MCw3LDUsIDAsOCw4NiwgMCw4LDIyLCAxOTIsOCwwLFxuICAgIDgzLDcsNTEsIDAsOCwxMTgsIDAsOCw1NCwgMCw5LDIwNSxcbiAgICA4MSw3LDE1LCAwLDgsMTAyLCAwLDgsMzgsIDAsOSwxNzMsXG4gICAgMCw4LDYsIDAsOCwxMzQsIDAsOCw3MCwgMCw5LDIzNyxcbiAgICA4MCw3LDksIDAsOCw5NCwgMCw4LDMwLCAwLDksMTU3LFxuICAgIDg0LDcsOTksIDAsOCwxMjYsIDAsOCw2MiwgMCw5LDIyMSxcbiAgICA4Miw3LDI3LCAwLDgsMTEwLCAwLDgsNDYsIDAsOSwxODksXG4gICAgMCw4LDE0LCAwLDgsMTQyLCAwLDgsNzgsIDAsOSwyNTMsXG4gICAgOTYsNywyNTYsIDAsOCw4MSwgMCw4LDE3LCA4NSw4LDEzMSxcbiAgICA4Miw3LDMxLCAwLDgsMTEzLCAwLDgsNDksIDAsOSwxOTUsXG4gICAgODAsNywxMCwgMCw4LDk3LCAwLDgsMzMsIDAsOSwxNjMsXG4gICAgMCw4LDEsIDAsOCwxMjksIDAsOCw2NSwgMCw5LDIyNyxcbiAgICA4MCw3LDYsIDAsOCw4OSwgMCw4LDI1LCAwLDksMTQ3LFxuICAgIDgzLDcsNTksIDAsOCwxMjEsIDAsOCw1NywgMCw5LDIxMSxcbiAgICA4MSw3LDE3LCAwLDgsMTA1LCAwLDgsNDEsIDAsOSwxNzksXG4gICAgMCw4LDksIDAsOCwxMzcsIDAsOCw3MywgMCw5LDI0MyxcbiAgICA4MCw3LDQsIDAsOCw4NSwgMCw4LDIxLCA4MCw4LDI1OCxcbiAgICA4Myw3LDQzLCAwLDgsMTE3LCAwLDgsNTMsIDAsOSwyMDMsXG4gICAgODEsNywxMywgMCw4LDEwMSwgMCw4LDM3LCAwLDksMTcxLFxuICAgIDAsOCw1LCAwLDgsMTMzLCAwLDgsNjksIDAsOSwyMzUsXG4gICAgODAsNyw4LCAwLDgsOTMsIDAsOCwyOSwgMCw5LDE1NSxcbiAgICA4NCw3LDgzLCAwLDgsMTI1LCAwLDgsNjEsIDAsOSwyMTksXG4gICAgODIsNywyMywgMCw4LDEwOSwgMCw4LDQ1LCAwLDksMTg3LFxuICAgIDAsOCwxMywgMCw4LDE0MSwgMCw4LDc3LCAwLDksMjUxLFxuICAgIDgwLDcsMywgMCw4LDgzLCAwLDgsMTksIDg1LDgsMTk1LFxuICAgIDgzLDcsMzUsIDAsOCwxMTUsIDAsOCw1MSwgMCw5LDE5OSxcbiAgICA4MSw3LDExLCAwLDgsOTksIDAsOCwzNSwgMCw5LDE2NyxcbiAgICAwLDgsMywgMCw4LDEzMSwgMCw4LDY3LCAwLDksMjMxLFxuICAgIDgwLDcsNywgMCw4LDkxLCAwLDgsMjcsIDAsOSwxNTEsXG4gICAgODQsNyw2NywgMCw4LDEyMywgMCw4LDU5LCAwLDksMjE1LFxuICAgIDgyLDcsMTksIDAsOCwxMDcsIDAsOCw0MywgMCw5LDE4MyxcbiAgICAwLDgsMTEsIDAsOCwxMzksIDAsOCw3NSwgMCw5LDI0NyxcbiAgICA4MCw3LDUsIDAsOCw4NywgMCw4LDIzLCAxOTIsOCwwLFxuICAgIDgzLDcsNTEsIDAsOCwxMTksIDAsOCw1NSwgMCw5LDIwNyxcbiAgICA4MSw3LDE1LCAwLDgsMTAzLCAwLDgsMzksIDAsOSwxNzUsXG4gICAgMCw4LDcsIDAsOCwxMzUsIDAsOCw3MSwgMCw5LDIzOSxcbiAgICA4MCw3LDksIDAsOCw5NSwgMCw4LDMxLCAwLDksMTU5LFxuICAgIDg0LDcsOTksIDAsOCwxMjcsIDAsOCw2MywgMCw5LDIyMyxcbiAgICA4Miw3LDI3LCAwLDgsMTExLCAwLDgsNDcsIDAsOSwxOTEsXG4gICAgMCw4LDE1LCAwLDgsMTQzLCAwLDgsNzksIDAsOSwyNTVcbl07XG52YXIgZml4ZWRfdGQgPSBbXG4gICAgODAsNSwxLCA4Nyw1LDI1NywgODMsNSwxNywgOTEsNSw0MDk3LFxuICAgIDgxLDUsNSwgODksNSwxMDI1LCA4NSw1LDY1LCA5Myw1LDE2Mzg1LFxuICAgIDgwLDUsMywgODgsNSw1MTMsIDg0LDUsMzMsIDkyLDUsODE5MyxcbiAgICA4Miw1LDksIDkwLDUsMjA0OSwgODYsNSwxMjksIDE5Miw1LDI0NTc3LFxuICAgIDgwLDUsMiwgODcsNSwzODUsIDgzLDUsMjUsIDkxLDUsNjE0NSxcbiAgICA4MSw1LDcsIDg5LDUsMTUzNywgODUsNSw5NywgOTMsNSwyNDU3NyxcbiAgICA4MCw1LDQsIDg4LDUsNzY5LCA4NCw1LDQ5LCA5Miw1LDEyMjg5LFxuICAgIDgyLDUsMTMsIDkwLDUsMzA3MywgODYsNSwxOTMsIDE5Miw1LDI0NTc3XG5dO1xuXG4gIC8vIFRhYmxlcyBmb3IgZGVmbGF0ZSBmcm9tIFBLWklQJ3MgYXBwbm90ZS50eHQuXG4gIHZhciBjcGxlbnMgPSBbIC8vIENvcHkgbGVuZ3RocyBmb3IgbGl0ZXJhbCBjb2RlcyAyNTcuLjI4NVxuICAgICAgICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAgICAgICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuICBdO1xuXG4gIC8vIHNlZSBub3RlICMxMyBhYm92ZSBhYm91dCAyNThcbiAgdmFyIGNwbGV4dCA9IFsgLy8gRXh0cmEgYml0cyBmb3IgbGl0ZXJhbCBjb2RlcyAyNTcuLjI4NVxuICAgICAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLFxuICAgICAgICAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCAwLCAxMTIsIDExMiAgLy8gMTEyPT1pbnZhbGlkXG4gIF07XG5cbiB2YXIgY3BkaXN0ID0gWyAvLyBDb3B5IG9mZnNldHMgZm9yIGRpc3RhbmNlIGNvZGVzIDAuLjI5XG4gICAgICAgIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MyxcbiAgICAgICAgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LFxuICAgICAgICA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3XG4gIF07XG5cbiAgdmFyIGNwZGV4dCA9IFsgLy8gRXh0cmEgYml0cyBmb3IgZGlzdGFuY2UgY29kZXNcbiAgICAgICAgMCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNixcbiAgICAgICAgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsXG4gICAgICAgIDEyLCAxMiwgMTMsIDEzXTtcblxuLy9cbi8vIFpTdHJlYW0uamF2YVxuLy9cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbn1cblxuXG5aU3RyZWFtLnByb3RvdHlwZS5pbmZsYXRlSW5pdCA9IGZ1bmN0aW9uKHcsIG5vd3JhcCkge1xuICAgIGlmICghdykge1xuXHR3ID0gREVGX1dCSVRTO1xuICAgIH1cbiAgICBpZiAobm93cmFwKSB7XG5cdG5vd3JhcCA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlzdGF0ZSA9IG5ldyBJbmZsYXRlKCk7XG4gICAgcmV0dXJuIHRoaXMuaXN0YXRlLmluZmxhdGVJbml0KHRoaXMsIG5vd3JhcD8tdzp3KTtcbn1cblxuWlN0cmVhbS5wcm90b3R5cGUuaW5mbGF0ZSA9IGZ1bmN0aW9uKGYpIHtcbiAgICBpZih0aGlzLmlzdGF0ZT09bnVsbCkgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIHJldHVybiB0aGlzLmlzdGF0ZS5pbmZsYXRlKHRoaXMsIGYpO1xufVxuXG5aU3RyZWFtLnByb3RvdHlwZS5pbmZsYXRlRW5kID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLmlzdGF0ZT09bnVsbCkgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIHZhciByZXQ9aXN0YXRlLmluZmxhdGVFbmQodGhpcyk7XG4gICAgdGhpcy5pc3RhdGUgPSBudWxsO1xuICAgIHJldHVybiByZXQ7XG59XG5aU3RyZWFtLnByb3RvdHlwZS5pbmZsYXRlU3luYyA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gaWYoaXN0YXRlID09IG51bGwpIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICByZXR1cm4gaXN0YXRlLmluZmxhdGVTeW5jKHRoaXMpO1xufVxuWlN0cmVhbS5wcm90b3R5cGUuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBmdW5jdGlvbihkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKXtcbiAgICAvLyBpZihpc3RhdGUgPT0gbnVsbCkgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIHJldHVybiBpc3RhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcywgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7XG59XG5cbi8qXG5cbiAgcHVibGljIGludCBkZWZsYXRlSW5pdChpbnQgbGV2ZWwpe1xuICAgIHJldHVybiBkZWZsYXRlSW5pdChsZXZlbCwgTUFYX1dCSVRTKTtcbiAgfVxuICBwdWJsaWMgaW50IGRlZmxhdGVJbml0KGludCBsZXZlbCwgYm9vbGVhbiBub3dyYXApe1xuICAgIHJldHVybiBkZWZsYXRlSW5pdChsZXZlbCwgTUFYX1dCSVRTLCBub3dyYXApO1xuICB9XG4gIHB1YmxpYyBpbnQgZGVmbGF0ZUluaXQoaW50IGxldmVsLCBpbnQgYml0cyl7XG4gICAgcmV0dXJuIGRlZmxhdGVJbml0KGxldmVsLCBiaXRzLCBmYWxzZSk7XG4gIH1cbiAgcHVibGljIGludCBkZWZsYXRlSW5pdChpbnQgbGV2ZWwsIGludCBiaXRzLCBib29sZWFuIG5vd3JhcCl7XG4gICAgZHN0YXRlPW5ldyBEZWZsYXRlKCk7XG4gICAgcmV0dXJuIGRzdGF0ZS5kZWZsYXRlSW5pdCh0aGlzLCBsZXZlbCwgbm93cmFwPy1iaXRzOmJpdHMpO1xuICB9XG4gIHB1YmxpYyBpbnQgZGVmbGF0ZShpbnQgZmx1c2gpe1xuICAgIGlmKGRzdGF0ZT09bnVsbCl7XG4gICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgfVxuICAgIHJldHVybiBkc3RhdGUuZGVmbGF0ZSh0aGlzLCBmbHVzaCk7XG4gIH1cbiAgcHVibGljIGludCBkZWZsYXRlRW5kKCl7XG4gICAgaWYoZHN0YXRlPT1udWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgaW50IHJldD1kc3RhdGUuZGVmbGF0ZUVuZCgpO1xuICAgIGRzdGF0ZT1udWxsO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgcHVibGljIGludCBkZWZsYXRlUGFyYW1zKGludCBsZXZlbCwgaW50IHN0cmF0ZWd5KXtcbiAgICBpZihkc3RhdGU9PW51bGwpIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICByZXR1cm4gZHN0YXRlLmRlZmxhdGVQYXJhbXModGhpcywgbGV2ZWwsIHN0cmF0ZWd5KTtcbiAgfVxuICBwdWJsaWMgaW50IGRlZmxhdGVTZXREaWN0aW9uYXJ5IChieXRlW10gZGljdGlvbmFyeSwgaW50IGRpY3RMZW5ndGgpe1xuICAgIGlmKGRzdGF0ZSA9PSBudWxsKVxuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIHJldHVybiBkc3RhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcywgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7XG4gIH1cblxuKi9cblxuLypcbiAgLy8gRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICAvLyB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gIC8vIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5uZXh0X291dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAgLy8gKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICB2b2lkIGZsdXNoX3BlbmRpbmcoKXtcbiAgICBpbnQgbGVuPWRzdGF0ZS5wZW5kaW5nO1xuXG4gICAgaWYobGVuPmF2YWlsX291dCkgbGVuPWF2YWlsX291dDtcbiAgICBpZihsZW49PTApIHJldHVybjtcblxuICAgIGlmKGRzdGF0ZS5wZW5kaW5nX2J1Zi5sZW5ndGg8PWRzdGF0ZS5wZW5kaW5nX291dCB8fFxuICAgICAgIG5leHRfb3V0Lmxlbmd0aDw9bmV4dF9vdXRfaW5kZXggfHxcbiAgICAgICBkc3RhdGUucGVuZGluZ19idWYubGVuZ3RoPChkc3RhdGUucGVuZGluZ19vdXQrbGVuKSB8fFxuICAgICAgIG5leHRfb3V0Lmxlbmd0aDwobmV4dF9vdXRfaW5kZXgrbGVuKSl7XG4gICAgICBTeXN0ZW0ub3V0LnByaW50bG4oZHN0YXRlLnBlbmRpbmdfYnVmLmxlbmd0aCtcIiwgXCIrZHN0YXRlLnBlbmRpbmdfb3V0K1xuXHRcdFx0IFwiLCBcIituZXh0X291dC5sZW5ndGgrXCIsIFwiK25leHRfb3V0X2luZGV4K1wiLCBcIitsZW4pO1xuICAgICAgU3lzdGVtLm91dC5wcmludGxuKFwiYXZhaWxfb3V0PVwiK2F2YWlsX291dCk7XG4gICAgfVxuXG4gICAgU3lzdGVtLmFycmF5Y29weShkc3RhdGUucGVuZGluZ19idWYsIGRzdGF0ZS5wZW5kaW5nX291dCxcblx0XHQgICAgIG5leHRfb3V0LCBuZXh0X291dF9pbmRleCwgbGVuKTtcblxuICAgIG5leHRfb3V0X2luZGV4Kz1sZW47XG4gICAgZHN0YXRlLnBlbmRpbmdfb3V0Kz1sZW47XG4gICAgdG90YWxfb3V0Kz1sZW47XG4gICAgYXZhaWxfb3V0LT1sZW47XG4gICAgZHN0YXRlLnBlbmRpbmctPWxlbjtcbiAgICBpZihkc3RhdGUucGVuZGluZz09MCl7XG4gICAgICBkc3RhdGUucGVuZGluZ19vdXQ9MDtcbiAgICB9XG4gIH1cblxuICAvLyBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gIC8vIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gIC8vIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXG4gIC8vIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5uZXh0X2luIGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICAvLyAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cbiAgaW50IHJlYWRfYnVmKGJ5dGVbXSBidWYsIGludCBzdGFydCwgaW50IHNpemUpIHtcbiAgICBpbnQgbGVuPWF2YWlsX2luO1xuXG4gICAgaWYobGVuPnNpemUpIGxlbj1zaXplO1xuICAgIGlmKGxlbj09MCkgcmV0dXJuIDA7XG5cbiAgICBhdmFpbF9pbi09bGVuO1xuXG4gICAgaWYoZHN0YXRlLm5vaGVhZGVyPT0wKSB7XG4gICAgICBhZGxlcj1fYWRsZXIuYWRsZXIzMihhZGxlciwgbmV4dF9pbiwgbmV4dF9pbl9pbmRleCwgbGVuKTtcbiAgICB9XG4gICAgU3lzdGVtLmFycmF5Y29weShuZXh0X2luLCBuZXh0X2luX2luZGV4LCBidWYsIHN0YXJ0LCBsZW4pO1xuICAgIG5leHRfaW5faW5kZXggICs9IGxlbjtcbiAgICB0b3RhbF9pbiArPSBsZW47XG4gICAgcmV0dXJuIGxlbjtcbiAgfVxuXG4gIHB1YmxpYyB2b2lkIGZyZWUoKXtcbiAgICBuZXh0X2luPW51bGw7XG4gICAgbmV4dF9vdXQ9bnVsbDtcbiAgICBtc2c9bnVsbDtcbiAgICBfYWRsZXI9bnVsbDtcbiAgfVxufVxuKi9cblxuXG4vL1xuLy8gSW5mbGF0ZS5qYXZhXG4vL1xuXG5mdW5jdGlvbiBJbmZsYXRlKCkge1xuICAgIHRoaXMud2FzID0gWzBdO1xufVxuXG5JbmZsYXRlLnByb3RvdHlwZS5pbmZsYXRlUmVzZXQgPSBmdW5jdGlvbih6KSB7XG4gICAgaWYoeiA9PSBudWxsIHx8IHouaXN0YXRlID09IG51bGwpIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICBcbiAgICB6LnRvdGFsX2luID0gei50b3RhbF9vdXQgPSAwO1xuICAgIHoubXNnID0gbnVsbDtcbiAgICB6LmlzdGF0ZS5tb2RlID0gei5pc3RhdGUubm93cmFwIT0wID8gQkxPQ0tTIDogTUVUSE9EO1xuICAgIHouaXN0YXRlLmJsb2Nrcy5yZXNldCh6LCBudWxsKTtcbiAgICByZXR1cm4gWl9PSztcbn1cblxuSW5mbGF0ZS5wcm90b3R5cGUuaW5mbGF0ZUVuZCA9IGZ1bmN0aW9uKHope1xuICAgIGlmKHRoaXMuYmxvY2tzICE9IG51bGwpXG4gICAgICB0aGlzLmJsb2Nrcy5mcmVlKHopO1xuICAgIHRoaXMuYmxvY2tzPW51bGw7XG4gICAgcmV0dXJuIFpfT0s7XG59XG5cbkluZmxhdGUucHJvdG90eXBlLmluZmxhdGVJbml0ID0gZnVuY3Rpb24oeiwgdyl7XG4gICAgei5tc2cgPSBudWxsO1xuICAgIHRoaXMuYmxvY2tzID0gbnVsbDtcblxuICAgIC8vIGhhbmRsZSB1bmRvY3VtZW50ZWQgbm93cmFwIG9wdGlvbiAobm8gemxpYiBoZWFkZXIgb3IgY2hlY2spXG4gICAgbGV0IG5vd3JhcCA9IDA7XG4gICAgaWYodyA8IDApe1xuICAgICAgdyA9IC0gdztcbiAgICAgIG5vd3JhcCA9IDE7XG4gICAgfVxuXG4gICAgLy8gc2V0IHdpbmRvdyBzaXplXG4gICAgaWYodzw4IHx8dz4xNSl7XG4gICAgICB0aGlzLmluZmxhdGVFbmQoeik7XG4gICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgfVxuICAgIHRoaXMud2JpdHM9dztcblxuICAgIHouaXN0YXRlLmJsb2Nrcz1uZXcgSW5mQmxvY2tzKHosIFxuXHRcdFx0XHQgIHouaXN0YXRlLm5vd3JhcCE9MCA/IG51bGwgOiB0aGlzLFxuXHRcdFx0XHQgIDE8PHcpO1xuXG4gICAgLy8gcmVzZXQgc3RhdGVcbiAgICB0aGlzLmluZmxhdGVSZXNldCh6KTtcbiAgICByZXR1cm4gWl9PSztcbiAgfVxuXG5JbmZsYXRlLnByb3RvdHlwZS5pbmZsYXRlID0gZnVuY3Rpb24oeiwgZil7XG4gICAgdmFyIHIsIGI7XG5cbiAgICBpZih6ID09IG51bGwgfHwgei5pc3RhdGUgPT0gbnVsbCB8fCB6Lm5leHRfaW4gPT0gbnVsbClcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICBmID0gZiA9PSBaX0ZJTklTSCA/IFpfQlVGX0VSUk9SIDogWl9PSztcbiAgICByID0gWl9CVUZfRVJST1I7XG4gICAgd2hpbGUgKHRydWUpe1xuICAgICAgc3dpdGNoICh6LmlzdGF0ZS5tb2RlKXtcbiAgICAgIGNhc2UgTUVUSE9EOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICBpZigoKHouaXN0YXRlLm1ldGhvZCA9IHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10pJjB4ZikhPVpfREVGTEFURUQpe1xuICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgei5tc2c9XCJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZFwiO1xuICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDU7ICAgICAgIC8vIGNhbid0IHRyeSBpbmZsYXRlU3luY1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmKCh6LmlzdGF0ZS5tZXRob2Q+PjQpKzg+ei5pc3RhdGUud2JpdHMpe1xuICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgei5tc2c9XCJpbnZhbGlkIHdpbmRvdyBzaXplXCI7XG4gICAgICAgICAgei5pc3RhdGUubWFya2VyID0gNTsgICAgICAgLy8gY2FuJ3QgdHJ5IGluZmxhdGVTeW5jXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgei5pc3RhdGUubW9kZT1GTEFHO1xuICAgICAgY2FzZSBGTEFHOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICBiID0gKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10pJjB4ZmY7XG5cbiAgICAgICAgaWYoKCgoei5pc3RhdGUubWV0aG9kIDw8IDgpK2IpICUgMzEpIT0wKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIHoubXNnID0gXCJpbmNvcnJlY3QgaGVhZGVyIGNoZWNrXCI7XG4gICAgICAgICAgei5pc3RhdGUubWFya2VyID0gNTsgICAgICAgLy8gY2FuJ3QgdHJ5IGluZmxhdGVTeW5jXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZigoYiZQUkVTRVRfRElDVCk9PTApe1xuICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCTE9DS1M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgei5pc3RhdGUubW9kZSA9IERJQ1Q0O1xuICAgICAgY2FzZSBESUNUNDpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZD0oKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik8PDI0KSYweGZmMDAwMDAwO1xuICAgICAgICB6LmlzdGF0ZS5tb2RlPURJQ1QzO1xuICAgICAgY2FzZSBESUNUMzpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZCs9KCh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpPDwxNikmMHhmZjAwMDA7XG4gICAgICAgIHouaXN0YXRlLm1vZGU9RElDVDI7XG4gICAgICBjYXNlIERJQ1QyOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkKz0oKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik8PDgpJjB4ZmYwMDtcbiAgICAgICAgei5pc3RhdGUubW9kZT1ESUNUMTtcbiAgICAgIGNhc2UgRElDVDE6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQgKz0gKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik7XG4gICAgICAgIHouYWRsZXIgPSB6LmlzdGF0ZS5uZWVkO1xuICAgICAgICB6LmlzdGF0ZS5tb2RlID0gRElDVDA7XG4gICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgIGNhc2UgRElDVDA6XG4gICAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIHoubXNnID0gXCJuZWVkIGRpY3Rpb25hcnlcIjtcbiAgICAgICAgei5pc3RhdGUubWFya2VyID0gMDsgICAgICAgLy8gY2FuIHRyeSBpbmZsYXRlU3luY1xuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgICBjYXNlIEJMT0NLUzpcblxuICAgICAgICByID0gei5pc3RhdGUuYmxvY2tzLnByb2Moeiwgcik7XG4gICAgICAgIGlmKHIgPT0gWl9EQVRBX0VSUk9SKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDA7ICAgICAvLyBjYW4gdHJ5IGluZmxhdGVTeW5jXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYociA9PSBaX09LKXtcbiAgICAgICAgICByID0gZjtcbiAgICAgICAgfVxuICAgICAgICBpZihyICE9IFpfU1RSRUFNX0VORCl7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgICAgciA9IGY7XG4gICAgICAgIHouaXN0YXRlLmJsb2Nrcy5yZXNldCh6LCB6LmlzdGF0ZS53YXMpO1xuICAgICAgICBpZih6LmlzdGF0ZS5ub3dyYXAhPTApe1xuICAgICAgICAgIHouaXN0YXRlLm1vZGU9RE9ORTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB6LmlzdGF0ZS5tb2RlPUNIRUNLNDtcbiAgICAgIGNhc2UgQ0hFQ0s0OlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkPSgoei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTw8MjQpJjB4ZmYwMDAwMDA7XG4gICAgICAgIHouaXN0YXRlLm1vZGU9Q0hFQ0szO1xuICAgICAgY2FzZSBDSEVDSzM6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQrPSgoei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTw8MTYpJjB4ZmYwMDAwO1xuICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQ0hFQ0syO1xuICAgICAgY2FzZSBDSEVDSzI6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQrPSgoei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTw8OCkmMHhmZjAwO1xuICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQ0hFQ0sxO1xuICAgICAgY2FzZSBDSEVDSzE6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQrPSh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpO1xuXG4gICAgICAgIGlmKCgoei5pc3RhdGUud2FzWzBdKSkgIT0gKCh6LmlzdGF0ZS5uZWVkKSkpe1xuICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgei5tc2cgPSBcImluY29ycmVjdCBkYXRhIGNoZWNrXCI7XG4gICAgICAgICAgei5pc3RhdGUubWFya2VyID0gNTsgICAgICAgLy8gY2FuJ3QgdHJ5IGluZmxhdGVTeW5jXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB6LmlzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgIGNhc2UgRE9ORTpcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VORDtcbiAgICAgIGNhc2UgQkFEOlxuICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbkluZmxhdGUucHJvdG90eXBlLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gZnVuY3Rpb24oeiwgIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpIHtcbiAgICB2YXIgaW5kZXg9MDtcbiAgICB2YXIgbGVuZ3RoID0gZGljdExlbmd0aDtcbiAgICBpZih6PT1udWxsIHx8IHouaXN0YXRlID09IG51bGx8fCB6LmlzdGF0ZS5tb2RlICE9IERJQ1QwKVxuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuXG4gICAgaWYoei5fYWRsZXIuYWRsZXIzMigxLCBkaWN0aW9uYXJ5LCAwLCBkaWN0TGVuZ3RoKSE9ei5hZGxlcil7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cblxuICAgIHouYWRsZXIgPSB6Ll9hZGxlci5hZGxlcjMyKDAsIG51bGwsIDAsIDApO1xuXG4gICAgaWYobGVuZ3RoID49ICgxPDx6LmlzdGF0ZS53Yml0cykpe1xuICAgICAgbGVuZ3RoID0gKDE8PHouaXN0YXRlLndiaXRzKS0xO1xuICAgICAgaW5kZXg9ZGljdExlbmd0aCAtIGxlbmd0aDtcbiAgICB9XG4gICAgei5pc3RhdGUuYmxvY2tzLnNldF9kaWN0aW9uYXJ5KGRpY3Rpb25hcnksIGluZGV4LCBsZW5ndGgpO1xuICAgIHouaXN0YXRlLm1vZGUgPSBCTE9DS1M7XG4gICAgcmV0dXJuIFpfT0s7XG4gIH1cblxuLy8gIHN0YXRpYyBwcml2YXRlIGJ5dGVbXSBtYXJrID0geyhieXRlKTAsIChieXRlKTAsIChieXRlKTB4ZmYsIChieXRlKTB4ZmZ9O1xudmFyIG1hcmsgPSBbMCwgMCwgMjU1LCAyNTVdXG5cbkluZmxhdGUucHJvdG90eXBlLmluZmxhdGVTeW5jID0gZnVuY3Rpb24oeil7XG4gICAgdmFyIG47ICAgICAgIC8vIG51bWJlciBvZiBieXRlcyB0byBsb29rIGF0XG4gICAgdmFyIHA7ICAgICAgIC8vIHBvaW50ZXIgdG8gYnl0ZXNcbiAgICB2YXIgbTsgICAgICAgLy8gbnVtYmVyIG9mIG1hcmtlciBieXRlcyBmb3VuZCBpbiBhIHJvd1xuICAgIHZhciByLCB3OyAgIC8vIHRlbXBvcmFyaWVzIHRvIHNhdmUgdG90YWxfaW4gYW5kIHRvdGFsX291dFxuXG4gICAgLy8gc2V0IHVwXG4gICAgaWYoeiA9PSBudWxsIHx8IHouaXN0YXRlID09IG51bGwpXG4gICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgaWYoei5pc3RhdGUubW9kZSAhPSBCQUQpe1xuICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgIHouaXN0YXRlLm1hcmtlciA9IDA7XG4gICAgfVxuICAgIGlmKChuPXouYXZhaWxfaW4pPT0wKVxuICAgICAgcmV0dXJuIFpfQlVGX0VSUk9SO1xuICAgIHA9ei5uZXh0X2luX2luZGV4O1xuICAgIG09ei5pc3RhdGUubWFya2VyO1xuXG4gICAgLy8gc2VhcmNoXG4gICAgd2hpbGUgKG4hPTAgJiYgbSA8IDQpe1xuICAgICAgaWYoei5uZXh0X2luW3BdID09IG1hcmtbbV0pe1xuICAgICAgICBtKys7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKHoubmV4dF9pbltwXSE9MCl7XG4gICAgICAgIG0gPSAwO1xuICAgICAgfVxuICAgICAgZWxzZXtcbiAgICAgICAgbSA9IDQgLSBtO1xuICAgICAgfVxuICAgICAgcCsrOyBuLS07XG4gICAgfVxuXG4gICAgLy8gcmVzdG9yZVxuICAgIHoudG90YWxfaW4gKz0gcC16Lm5leHRfaW5faW5kZXg7XG4gICAgei5uZXh0X2luX2luZGV4ID0gcDtcbiAgICB6LmF2YWlsX2luID0gbjtcbiAgICB6LmlzdGF0ZS5tYXJrZXIgPSBtO1xuXG4gICAgLy8gcmV0dXJuIG5vIGpveSBvciBzZXQgdXAgdG8gcmVzdGFydCBvbiBhIG5ldyBibG9ja1xuICAgIGlmKG0gIT0gNCl7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgICByPXoudG90YWxfaW47ICB3PXoudG90YWxfb3V0O1xuICAgIHRoaXMuaW5mbGF0ZVJlc2V0KHopO1xuICAgIHoudG90YWxfaW49cjsgIHoudG90YWxfb3V0ID0gdztcbiAgICB6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xuICAgIHJldHVybiBaX09LO1xufVxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiBpbmZsYXRlIGlzIGN1cnJlbnRseSBhdCB0aGUgZW5kIG9mIGEgYmxvY2sgZ2VuZXJhdGVkXG4gIC8vIGJ5IFpfU1lOQ19GTFVTSCBvciBaX0ZVTExfRkxVU0guIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBieSBvbmUgUFBQXG4gIC8vIGltcGxlbWVudGF0aW9uIHRvIHByb3ZpZGUgYW4gYWRkaXRpb25hbCBzYWZldHkgY2hlY2suIFBQUCB1c2VzIFpfU1lOQ19GTFVTSFxuICAvLyBidXQgcmVtb3ZlcyB0aGUgbGVuZ3RoIGJ5dGVzIG9mIHRoZSByZXN1bHRpbmcgZW1wdHkgc3RvcmVkIGJsb2NrLiBXaGVuXG4gIC8vIGRlY29tcHJlc3NpbmcsIFBQUCBjaGVja3MgdGhhdCBhdCB0aGUgZW5kIG9mIGlucHV0IHBhY2tldCwgaW5mbGF0ZSBpc1xuICAvLyB3YWl0aW5nIGZvciB0aGVzZSBsZW5ndGggYnl0ZXMuXG5JbmZsYXRlLnByb3RvdHlwZS5pbmZsYXRlU3luY1BvaW50ID0gZnVuY3Rpb24oeil7XG4gICAgaWYoeiA9PSBudWxsIHx8IHouaXN0YXRlID09IG51bGwgfHwgei5pc3RhdGUuYmxvY2tzID09IG51bGwpXG4gICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgcmV0dXJuIHouaXN0YXRlLmJsb2Nrcy5zeW5jX3BvaW50KCk7XG59XG5cblxuLy9cbi8vIEluZkJsb2Nrcy5qYXZhXG4vL1xuXG52YXIgSU5GQkxPQ0tTX0JPUkRFUiA9IFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XTtcblxuZnVuY3Rpb24gSW5mQmxvY2tzKHosIGNoZWNrZm4sIHcpIHtcbiAgICB0aGlzLmh1ZnRzPW5ldyBJbnQzMkFycmF5KE1BTlkqMyk7XG4gICAgdGhpcy53aW5kb3c9bmV3IFVpbnQ4QXJyYXkodyk7XG4gICAgdGhpcy5lbmQ9dztcbiAgICB0aGlzLmNoZWNrZm4gPSBjaGVja2ZuO1xuICAgIHRoaXMubW9kZSA9IElCX1RZUEU7XG4gICAgdGhpcy5yZXNldCh6LCBudWxsKTtcblxuICAgIHRoaXMubGVmdCA9IDA7ICAgICAgICAgICAgLy8gaWYgU1RPUkVELCBieXRlcyBsZWZ0IHRvIGNvcHkgXG5cbiAgICB0aGlzLnRhYmxlID0gMDsgICAgICAgICAgIC8vIHRhYmxlIGxlbmd0aHMgKDE0IGJpdHMpIFxuICAgIHRoaXMuaW5kZXggPSAwOyAgICAgICAgICAgLy8gaW5kZXggaW50byBibGVucyAob3IgYm9yZGVyKSBcbiAgICB0aGlzLmJsZW5zID0gbnVsbDsgICAgICAgICAvLyBiaXQgbGVuZ3RocyBvZiBjb2RlcyBcbiAgICB0aGlzLmJiPW5ldyBJbnQzMkFycmF5KDEpOyAvLyBiaXQgbGVuZ3RoIHRyZWUgZGVwdGggXG4gICAgdGhpcy50Yj1uZXcgSW50MzJBcnJheSgxKTsgLy8gYml0IGxlbmd0aCBkZWNvZGluZyB0cmVlIFxuXG4gICAgdGhpcy5jb2RlcyA9IG5ldyBJbmZDb2RlcygpO1xuXG4gICAgdGhpcy5sYXN0ID0gMDsgICAgICAgICAgICAvLyB0cnVlIGlmIHRoaXMgYmxvY2sgaXMgdGhlIGxhc3QgYmxvY2sgXG5cbiAgLy8gbW9kZSBpbmRlcGVuZGVudCBpbmZvcm1hdGlvbiBcbiAgICB0aGlzLmJpdGsgPSAwOyAgICAgICAgICAgIC8vIGJpdHMgaW4gYml0IGJ1ZmZlciBcbiAgICB0aGlzLmJpdGIgPSAwOyAgICAgICAgICAgIC8vIGJpdCBidWZmZXIgXG4gICAgdGhpcy5yZWFkID0gMDsgICAgICAgICAgICAvLyB3aW5kb3cgcmVhZCBwb2ludGVyIFxuICAgIHRoaXMud3JpdGUgPSAwOyAgICAgICAgICAgLy8gd2luZG93IHdyaXRlIHBvaW50ZXIgXG4gICAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgIC8vIGNoZWNrIG9uIG91dHB1dCBcblxuICAgIHRoaXMuaW5mdHJlZT1uZXcgSW5mVHJlZSgpO1xufVxuXG5cblxuXG5JbmZCbG9ja3MucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oeiwgYyl7XG4gICAgaWYoYykgY1swXT10aGlzLmNoZWNrO1xuICAgIGlmKHRoaXMubW9kZT09SUJfQ09ERVMpe1xuICAgICAgdGhpcy5jb2Rlcy5mcmVlKHopO1xuICAgIH1cbiAgICB0aGlzLm1vZGU9SUJfVFlQRTtcbiAgICB0aGlzLmJpdGs9MDtcbiAgICB0aGlzLmJpdGI9MDtcbiAgICB0aGlzLnJlYWQ9dGhpcy53cml0ZT0wO1xuXG4gICAgaWYodGhpcy5jaGVja2ZuKVxuICAgICAgei5hZGxlcj10aGlzLmNoZWNrPXouX2FkbGVyLmFkbGVyMzIoMCwgbnVsbCwgMCwgMCk7XG4gIH1cblxuIEluZkJsb2Nrcy5wcm90b3R5cGUucHJvYyA9IGZ1bmN0aW9uKHosIHIpe1xuICAgIHZhciB0OyAgICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IHN0b3JhZ2VcbiAgICB2YXIgYjsgICAgICAgICAgICAgIC8vIGJpdCBidWZmZXJcbiAgICB2YXIgazsgICAgICAgICAgICAgIC8vIGJpdHMgaW4gYml0IGJ1ZmZlclxuICAgIHZhciBwOyAgICAgICAgICAgICAgLy8gaW5wdXQgZGF0YSBwb2ludGVyXG4gICAgdmFyIG47ICAgICAgICAgICAgICAvLyBieXRlcyBhdmFpbGFibGUgdGhlcmVcbiAgICB2YXIgcTsgICAgICAgICAgICAgIC8vIG91dHB1dCB3aW5kb3cgd3JpdGUgcG9pbnRlclxuICAgIHZhciBtOyAgICAgICAgICAgICAgLy8gYnl0ZXMgdG8gZW5kIG9mIHdpbmRvdyBvciByZWFkIHBvaW50ZXJcblxuICAgIC8vIGNvcHkgaW5wdXQvb3V0cHV0IGluZm9ybWF0aW9uIHRvIGxvY2FscyAoVVBEQVRFIG1hY3JvIHJlc3RvcmVzKVxuICAgIHtwPXoubmV4dF9pbl9pbmRleDtuPXouYXZhaWxfaW47Yj10aGlzLmJpdGI7az10aGlzLmJpdGs7fVxuICAgIHtxPXRoaXMud3JpdGU7bT0ocTx0aGlzLnJlYWQgPyB0aGlzLnJlYWQtcS0xIDogdGhpcy5lbmQtcSk7fVxuXG4gICAgLy8gcHJvY2VzcyBpbnB1dCBiYXNlZCBvbiBjdXJyZW50IHN0YXRlXG4gICAgd2hpbGUodHJ1ZSl7XG4gICAgICBzd2l0Y2ggKHRoaXMubW9kZSl7XG4gICAgICBjYXNlIElCX1RZUEU6XG5cblx0d2hpbGUoazwoMykpe1xuXHQgIGlmKG4hPTApe1xuXHQgICAgcj1aX09LO1xuXHQgIH1cblx0ICBlbHNle1xuXHQgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgIHouYXZhaWxfaW49bjtcblx0ICAgIHoudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgIH07XG5cdCAgbi0tO1xuXHQgIGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICBrKz04O1xuXHR9XG5cdHQgPSAoYiAmIDcpO1xuXHR0aGlzLmxhc3QgPSB0ICYgMTtcblxuXHRzd2l0Y2ggKHQgPj4+IDEpe1xuICAgICAgICBjYXNlIDA6ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlZCBcbiAgICAgICAgICB7Yj4+Pj0oMyk7ay09KDMpO31cbiAgICAgICAgICB0ID0gayAmIDc7ICAgICAgICAgICAgICAgICAgICAvLyBnbyB0byBieXRlIGJvdW5kYXJ5XG5cbiAgICAgICAgICB7Yj4+Pj0odCk7ay09KHQpO31cbiAgICAgICAgICB0aGlzLm1vZGUgPSBJQl9MRU5TOyAgICAgICAgICAgICAgICAgIC8vIGdldCBsZW5ndGggb2Ygc3RvcmVkIGJsb2NrXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4ZWRcbiAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBibD1uZXcgSW50MzJBcnJheSgxKTtcblx0ICAgICAgdmFyIGJkPW5ldyBJbnQzMkFycmF5KDEpO1xuICAgICAgICAgICAgICB2YXIgdGw9W107XG5cdCAgICAgIHZhciB0ZD1bXTtcblxuXHQgICAgICBpbmZsYXRlX3RyZWVzX2ZpeGVkKGJsLCBiZCwgdGwsIHRkLCB6KTtcbiAgICAgICAgICAgICAgdGhpcy5jb2Rlcy5pbml0KGJsWzBdLCBiZFswXSwgdGxbMF0sIDAsIHRkWzBdLCAwLCB6KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB7Yj4+Pj0oMyk7ay09KDMpO31cblxuICAgICAgICAgIHRoaXMubW9kZSA9IElCX0NPREVTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGR5bmFtaWNcblxuICAgICAgICAgIHtiPj4+PSgzKTtrLT0oMyk7fVxuXG4gICAgICAgICAgdGhpcy5tb2RlID0gSUJfVEFCTEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWxsZWdhbFxuXG4gICAgICAgICAge2I+Pj49KDMpO2stPSgzKTt9XG4gICAgICAgICAgdGhpcy5tb2RlID0gQkFEO1xuICAgICAgICAgIHoubXNnID0gXCJpbnZhbGlkIGJsb2NrIHR5cGVcIjtcbiAgICAgICAgICByID0gWl9EQVRBX0VSUk9SO1xuXG5cdCAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgdGhpcy53cml0ZT1xO1xuXHQgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0fVxuXHRicmVhaztcbiAgICAgIGNhc2UgSUJfTEVOUzpcblx0d2hpbGUoazwoMzIpKXtcblx0ICBpZihuIT0wKXtcblx0ICAgIHI9Wl9PSztcblx0ICB9XG5cdCAgZWxzZXtcblx0ICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICB6LmF2YWlsX2luPW47XG5cdCAgICB6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHRoaXMud3JpdGU9cTtcblx0ICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9O1xuXHQgIG4tLTtcblx0ICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXG5cdGlmICgoKCh+YikgPj4+IDE2KSAmIDB4ZmZmZikgIT0gKGIgJiAweGZmZmYpKXtcblx0ICB0aGlzLm1vZGUgPSBCQUQ7XG5cdCAgei5tc2cgPSBcImludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHNcIjtcblx0ICByID0gWl9EQVRBX0VSUk9SO1xuXG5cdCAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgdGhpcy53cml0ZT1xO1xuXHQgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0fVxuXHR0aGlzLmxlZnQgPSAoYiAmIDB4ZmZmZik7XG5cdGIgPSBrID0gMDsgICAgICAgICAgICAgICAgICAgICAgIC8vIGR1bXAgYml0c1xuXHR0aGlzLm1vZGUgPSBsZWZ0IT0wID8gSUJfU1RPUkVEIDogKHRoaXMubGFzdCE9MCA/IElCX0RSWSA6IElCX1RZUEUpO1xuXHRicmVhaztcbiAgICAgIGNhc2UgSUJfU1RPUkVEOlxuXHRpZiAobiA9PSAwKXtcblx0ICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICB3cml0ZT1xO1xuXHQgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0fVxuXG5cdGlmKG09PTApe1xuXHQgIGlmKHE9PWVuZCYmcmVhZCE9MCl7XG5cdCAgICBxPTA7IG09KHE8dGhpcy5yZWFkID8gdGhpcy5yZWFkLXEtMSA6IHRoaXMuZW5kLXEpO1xuXHQgIH1cblx0ICBpZihtPT0wKXtcblx0ICAgIHRoaXMud3JpdGU9cTsgXG5cdCAgICByPXRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgcT10aGlzLndyaXRlOyBtID0gKHEgPCB0aGlzLnJlYWQgPyB0aGlzLnJlYWQtcS0xIDogdGhpcy5lbmQtcSk7XG5cdCAgICBpZihxPT10aGlzLmVuZCAmJiB0aGlzLnJlYWQgIT0gMCl7XG5cdCAgICAgIHE9MDsgbSA9IChxIDwgdGhpcy5yZWFkID8gdGhpcy5yZWFkLXEtMSA6IHRoaXMuZW5kLXEpO1xuXHQgICAgfVxuXHQgICAgaWYobT09MCl7XG5cdCAgICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdHI9Wl9PSztcblxuXHR0ID0gdGhpcy5sZWZ0O1xuXHRpZih0Pm4pIHQgPSBuO1xuXHRpZih0Pm0pIHQgPSBtO1xuXHRhcnJheUNvcHkoei5uZXh0X2luLCBwLCB3aW5kb3csIHEsIHQpO1xuXHRwICs9IHQ7ICBuIC09IHQ7XG5cdHEgKz0gdDsgIG0gLT0gdDtcblx0aWYgKCh0aGlzLmxlZnQgLT0gdCkgIT0gMClcblx0ICBicmVhaztcblx0dGhpcy5tb2RlID0gKHRoaXMubGFzdCAhPSAwID8gSUJfRFJZIDogSUJfVFlQRSk7XG5cdGJyZWFrO1xuICAgICAgY2FzZSBJQl9UQUJMRTpcblxuXHR3aGlsZShrPCgxNCkpe1xuXHQgIGlmKG4hPTApe1xuXHQgICAgcj1aX09LO1xuXHQgIH1cblx0ICBlbHNle1xuXHQgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgIHouYXZhaWxfaW49bjtcblx0ICAgIHoudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgIH07XG5cdCAgbi0tO1xuXHQgIGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICBrKz04O1xuXHR9XG5cblx0dGhpcy50YWJsZSA9IHQgPSAoYiAmIDB4M2ZmZik7XG5cdGlmICgodCAmIDB4MWYpID4gMjkgfHwgKCh0ID4+IDUpICYgMHgxZikgPiAyOSlcblx0ICB7XG5cdCAgICB0aGlzLm1vZGUgPSBJQl9CQUQ7XG5cdCAgICB6Lm1zZyA9IFwidG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHNcIjtcblx0ICAgIHIgPSBaX0RBVEFfRVJST1I7XG5cblx0ICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICB0aGlzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfVxuXHR0ID0gMjU4ICsgKHQgJiAweDFmKSArICgodCA+PiA1KSAmIDB4MWYpO1xuXHRpZih0aGlzLmJsZW5zPT1udWxsIHx8IHRoaXMuYmxlbnMubGVuZ3RoPHQpe1xuXHQgICAgdGhpcy5ibGVucz1uZXcgSW50MzJBcnJheSh0KTtcblx0fVxuXHRlbHNle1xuXHQgIGZvcih2YXIgaT0wOyBpPHQ7IGkrKyl7XG4gICAgICAgICAgICAgIHRoaXMuYmxlbnNbaV09MDtcbiAgICAgICAgICB9XG5cdH1cblxuXHR7Yj4+Pj0oMTQpO2stPSgxNCk7fVxuXG5cdHRoaXMuaW5kZXggPSAwO1xuXHR0aGlzLm1vZGUgPSBJQl9CVFJFRTtcbiAgICAgIGNhc2UgSUJfQlRSRUU6XG5cdHdoaWxlICh0aGlzLmluZGV4IDwgNCArICh0aGlzLnRhYmxlID4+PiAxMCkpe1xuXHQgIHdoaWxlKGs8KDMpKXtcblx0ICAgIGlmKG4hPTApe1xuXHQgICAgICByPVpfT0s7XG5cdCAgICB9XG5cdCAgICBlbHNle1xuXHQgICAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgICB6LmF2YWlsX2luPW47XG5cdCAgICAgIHoudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgICB0aGlzLndyaXRlPXE7XG5cdCAgICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIH07XG5cdCAgICBuLS07XG5cdCAgICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgICBrKz04O1xuXHQgIH1cblxuXHQgIHRoaXMuYmxlbnNbSU5GQkxPQ0tTX0JPUkRFUlt0aGlzLmluZGV4KytdXSA9IGImNztcblxuXHQgIHtiPj4+PSgzKTtrLT0oMyk7fVxuXHR9XG5cblx0d2hpbGUodGhpcy5pbmRleCA8IDE5KXtcblx0ICB0aGlzLmJsZW5zW0lORkJMT0NLU19CT1JERVJbdGhpcy5pbmRleCsrXV0gPSAwO1xuXHR9XG5cblx0dGhpcy5iYlswXSA9IDc7XG5cdHQgPSB0aGlzLmluZnRyZWUuaW5mbGF0ZV90cmVlc19iaXRzKHRoaXMuYmxlbnMsIHRoaXMuYmIsIHRoaXMudGIsIHRoaXMuaHVmdHMsIHopO1xuXHRpZiAodCAhPSBaX09LKXtcblx0ICByID0gdDtcblx0ICBpZiAociA9PSBaX0RBVEFfRVJST1Ipe1xuXHQgICAgdGhpcy5ibGVucz1udWxsO1xuXHQgICAgdGhpcy5tb2RlID0gSUJfQkFEO1xuXHQgIH1cblxuXHQgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHdyaXRlPXE7XG5cdCAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHR9XG5cblx0dGhpcy5pbmRleCA9IDA7XG5cdHRoaXMubW9kZSA9IElCX0RUUkVFO1xuICAgICAgY2FzZSBJQl9EVFJFRTpcblx0d2hpbGUgKHRydWUpe1xuXHQgIHQgPSB0aGlzLnRhYmxlO1xuXHQgIGlmKCEodGhpcy5pbmRleCA8IDI1OCArICh0ICYgMHgxZikgKyAoKHQgPj4gNSkgJiAweDFmKSkpe1xuXHQgICAgYnJlYWs7XG5cdCAgfVxuXG5cdCAgdmFyIGg7IC8vaW50W11cblx0ICB2YXIgaSwgaiwgYztcblxuXHQgIHQgPSB0aGlzLmJiWzBdO1xuXG5cdCAgd2hpbGUoazwodCkpe1xuXHQgICAgaWYobiE9MCl7XG5cdCAgICAgIHI9Wl9PSztcblx0ICAgIH1cblx0ICAgIGVsc2V7XG5cdCAgICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICAgIHouYXZhaWxfaW49bjtcblx0ICAgICAgei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICAgIHRoaXMud3JpdGU9cTtcblx0ICAgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgfTtcblx0ICAgIG4tLTtcblx0ICAgIGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICAgIGsrPTg7XG5cdCAgfVxuXG4vL1x0ICBpZiAodGhpcy50YlswXT09LTEpe1xuLy8gICAgICAgICAgICBkbG9nKFwibnVsbC4uLlwiKTtcbi8vXHQgIH1cblxuXHQgIHQ9dGhpcy5odWZ0c1sodGhpcy50YlswXSsoYiAmIGluZmxhdGVfbWFza1t0XSkpKjMrMV07XG5cdCAgYz10aGlzLmh1ZnRzWyh0aGlzLnRiWzBdKyhiICYgaW5mbGF0ZV9tYXNrW3RdKSkqMysyXTtcblxuXHQgIGlmIChjIDwgMTYpe1xuXHQgICAgYj4+Pj0odCk7ay09KHQpO1xuXHQgICAgdGhpcy5ibGVuc1t0aGlzLmluZGV4KytdID0gYztcblx0ICB9XG5cdCAgZWxzZSB7IC8vIGMgPT0gMTYuLjE4XG5cdCAgICBpID0gYyA9PSAxOCA/IDcgOiBjIC0gMTQ7XG5cdCAgICBqID0gYyA9PSAxOCA/IDExIDogMztcblxuXHQgICAgd2hpbGUoazwodCtpKSl7XG5cdCAgICAgIGlmKG4hPTApe1xuXHRcdHI9Wl9PSztcblx0ICAgICAgfVxuXHQgICAgICBlbHNle1xuXHRcdHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdFx0ei5hdmFpbF9pbj1uO1xuXHRcdHoudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHRcdHRoaXMud3JpdGU9cTtcblx0XHRyZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICAgIH07XG5cdCAgICAgIG4tLTtcblx0ICAgICAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgICAgICBrKz04O1xuXHQgICAgfVxuXG5cdCAgICBiPj4+PSh0KTtrLT0odCk7XG5cblx0ICAgIGogKz0gKGIgJiBpbmZsYXRlX21hc2tbaV0pO1xuXG5cdCAgICBiPj4+PShpKTtrLT0oaSk7XG5cblx0ICAgIGkgPSB0aGlzLmluZGV4O1xuXHQgICAgdCA9IHRoaXMudGFibGU7XG5cdCAgICBpZiAoaSArIGogPiAyNTggKyAodCAmIDB4MWYpICsgKCh0ID4+IDUpICYgMHgxZikgfHxcblx0XHQoYyA9PSAxNiAmJiBpIDwgMSkpe1xuXHQgICAgICB0aGlzLmJsZW5zPW51bGw7XG5cdCAgICAgIHRoaXMubW9kZSA9IElCX0JBRDtcblx0ICAgICAgei5tc2cgPSBcImludmFsaWQgYml0IGxlbmd0aCByZXBlYXRcIjtcblx0ICAgICAgciA9IFpfREFUQV9FUlJPUjtcblxuXHQgICAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICAgIHRoaXMud3JpdGU9cTtcblx0ICAgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgfVxuXG5cdCAgICBjID0gYyA9PSAxNiA/IHRoaXMuYmxlbnNbaS0xXSA6IDA7XG5cdCAgICBkb3tcblx0ICAgICAgdGhpcy5ibGVuc1tpKytdID0gYztcblx0ICAgIH1cblx0ICAgIHdoaWxlICgtLWohPTApO1xuXHQgICAgdGhpcy5pbmRleCA9IGk7XG5cdCAgfVxuXHR9XG5cblx0dGhpcy50YlswXT0tMTtcblx0e1xuXHQgICAgdmFyIGJsPW5ldyBJbnQzMkFycmF5KDEpO1xuXHQgICAgdmFyIGJkPW5ldyBJbnQzMkFycmF5KDEpO1xuXHQgICAgdmFyIHRsPW5ldyBJbnQzMkFycmF5KDEpO1xuXHQgICAgdmFyIHRkPW5ldyBJbnQzMkFycmF5KDEpO1xuXHQgICAgYmxbMF0gPSA5OyAgICAgICAgIC8vIG11c3QgYmUgPD0gOSBmb3IgbG9va2FoZWFkIGFzc3VtcHRpb25zXG5cdCAgICBiZFswXSA9IDY7ICAgICAgICAgLy8gbXVzdCBiZSA8PSA5IGZvciBsb29rYWhlYWQgYXNzdW1wdGlvbnNcblxuXHQgICAgdCA9IHRoaXMudGFibGU7XG5cdCAgICB0ID0gdGhpcy5pbmZ0cmVlLmluZmxhdGVfdHJlZXNfZHluYW1pYygyNTcgKyAodCAmIDB4MWYpLCBcblx0XHRcdFx0XHQgICAgICAxICsgKCh0ID4+IDUpICYgMHgxZiksXG5cdFx0XHRcdFx0ICAgICAgdGhpcy5ibGVucywgYmwsIGJkLCB0bCwgdGQsIHRoaXMuaHVmdHMsIHopO1xuXG5cdCAgICBpZiAodCAhPSBaX09LKXtcblx0ICAgICAgICBpZiAodCA9PSBaX0RBVEFfRVJST1Ipe1xuXHQgICAgICAgICAgICB0aGlzLmJsZW5zPW51bGw7XG5cdCAgICAgICAgICAgIHRoaXMubW9kZSA9IEJBRDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgciA9IHQ7XG5cblx0ICAgICAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgICAgICB0aGlzLndyaXRlPXE7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5jb2Rlcy5pbml0KGJsWzBdLCBiZFswXSwgdGhpcy5odWZ0cywgdGxbMF0sIHRoaXMuaHVmdHMsIHRkWzBdLCB6KTtcblx0fVxuXHR0aGlzLm1vZGUgPSBJQl9DT0RFUztcbiAgICAgIGNhc2UgSUJfQ09ERVM6XG5cdHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9aztcblx0ei5hdmFpbF9pbj1uOyB6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0dGhpcy53cml0ZT1xO1xuXG5cdGlmICgociA9IHRoaXMuY29kZXMucHJvYyh0aGlzLCB6LCByKSkgIT0gWl9TVFJFQU1fRU5EKXtcblx0ICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xuXHR9XG5cdHIgPSBaX09LO1xuXHR0aGlzLmNvZGVzLmZyZWUoeik7XG5cblx0cD16Lm5leHRfaW5faW5kZXg7IG49ei5hdmFpbF9pbjtiPXRoaXMuYml0YjtrPXRoaXMuYml0aztcblx0cT10aGlzLndyaXRlO20gPSAocSA8IHRoaXMucmVhZCA/IHRoaXMucmVhZC1xLTEgOiB0aGlzLmVuZC1xKTtcblxuXHRpZiAodGhpcy5sYXN0PT0wKXtcblx0ICB0aGlzLm1vZGUgPSBJQl9UWVBFO1xuXHQgIGJyZWFrO1xuXHR9XG5cdHRoaXMubW9kZSA9IElCX0RSWTtcbiAgICAgIGNhc2UgSUJfRFJZOlxuXHR0aGlzLndyaXRlPXE7IFxuXHRyID0gdGhpcy5pbmZsYXRlX2ZsdXNoKHosIHIpOyBcblx0cT10aGlzLndyaXRlOyBtID0gKHEgPCB0aGlzLnJlYWQgPyB0aGlzLnJlYWQtcS0xIDogdGhpcy5lbmQtcSk7XG5cdGlmICh0aGlzLnJlYWQgIT0gdGhpcy53cml0ZSl7XG5cdCAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgdGhpcy53cml0ZT1xO1xuXHQgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeiwgcik7XG5cdH1cblx0dGhpcy5tb2RlID0gRE9ORTtcbiAgICAgIGNhc2UgSUJfRE9ORTpcblx0ciA9IFpfU1RSRUFNX0VORDtcblxuXHR0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHRoaXMud3JpdGU9cTtcblx0cmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcbiAgICAgIGNhc2UgSUJfQkFEOlxuXHRyID0gWl9EQVRBX0VSUk9SO1xuXG5cdHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0dGhpcy53cml0ZT1xO1xuXHRyZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xuXG4gICAgICBkZWZhdWx0OlxuXHRyID0gWl9TVFJFQU1fRVJST1I7XG5cblx0dGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHR0aGlzLndyaXRlPXE7XG5cdHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeiwgcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbkluZkJsb2Nrcy5wcm90b3R5cGUuZnJlZSA9IGZ1bmN0aW9uKHope1xuICAgIHRoaXMucmVzZXQoeiwgbnVsbCk7XG4gICAgdGhpcy53aW5kb3c9bnVsbDtcbiAgICB0aGlzLmh1ZnRzPW51bGw7XG59XG5cbkluZkJsb2Nrcy5wcm90b3R5cGUuc2V0X2RpY3Rpb25hcnkgPSBmdW5jdGlvbihkLCBzdGFydCwgbil7XG4gICAgYXJyYXlDb3B5KGQsIHN0YXJ0LCB3aW5kb3csIDAsIG4pO1xuICAgIHRoaXMucmVhZCA9IHRoaXMud3JpdGUgPSBuO1xufVxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiBpbmZsYXRlIGlzIGN1cnJlbnRseSBhdCB0aGUgZW5kIG9mIGEgYmxvY2sgZ2VuZXJhdGVkXG4gIC8vIGJ5IFpfU1lOQ19GTFVTSCBvciBaX0ZVTExfRkxVU0guIFxuSW5mQmxvY2tzLnByb3RvdHlwZS5zeW5jX3BvaW50ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5tb2RlID09IElCX0xFTlM7XG59XG5cbiAgLy8gY29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIHNsaWRpbmcgd2luZG93IHRvIHRoZSBvdXRwdXQgYXJlYVxuSW5mQmxvY2tzLnByb3RvdHlwZS5pbmZsYXRlX2ZsdXNoID0gZnVuY3Rpb24oeiwgcil7XG4gICAgdmFyIG47XG4gICAgdmFyIHA7XG4gICAgdmFyIHE7XG5cbiAgICAvLyBsb2NhbCBjb3BpZXMgb2Ygc291cmNlIGFuZCBkZXN0aW5hdGlvbiBwb2ludGVyc1xuICAgIHAgPSB6Lm5leHRfb3V0X2luZGV4O1xuICAgIHEgPSB0aGlzLnJlYWQ7XG5cbiAgICAvLyBjb21wdXRlIG51bWJlciBvZiBieXRlcyB0byBjb3B5IGFzIGZhciBhcyBlbmQgb2Ygd2luZG93XG4gICAgbiA9ICgocSA8PSB0aGlzLndyaXRlID8gdGhpcy53cml0ZSA6IHRoaXMuZW5kKSAtIHEpO1xuICAgIGlmIChuID4gei5hdmFpbF9vdXQpIG4gPSB6LmF2YWlsX291dDtcbiAgICBpZiAobiE9MCAmJiByID09IFpfQlVGX0VSUk9SKSByID0gWl9PSztcblxuICAgIC8vIHVwZGF0ZSBjb3VudGVyc1xuICAgIHouYXZhaWxfb3V0IC09IG47XG4gICAgei50b3RhbF9vdXQgKz0gbjtcblxuICAgIC8vIHVwZGF0ZSBjaGVjayBpbmZvcm1hdGlvblxuICAgIGlmKHRoaXMuY2hlY2tmbiAhPSBudWxsKVxuICAgICAgei5hZGxlcj10aGlzLmNoZWNrPXouX2FkbGVyLmFkbGVyMzIodGhpcy5jaGVjaywgdGhpcy53aW5kb3csIHEsIG4pO1xuXG4gICAgLy8gY29weSBhcyBmYXIgYXMgZW5kIG9mIHdpbmRvd1xuICAgIGFycmF5Q29weSh0aGlzLndpbmRvdywgcSwgei5uZXh0X291dCwgcCwgbik7XG4gICAgcCArPSBuO1xuICAgIHEgKz0gbjtcblxuICAgIC8vIHNlZSBpZiBtb3JlIHRvIGNvcHkgYXQgYmVnaW5uaW5nIG9mIHdpbmRvd1xuICAgIGlmIChxID09IHRoaXMuZW5kKXtcbiAgICAgIC8vIHdyYXAgcG9pbnRlcnNcbiAgICAgIHEgPSAwO1xuICAgICAgaWYgKHRoaXMud3JpdGUgPT0gdGhpcy5lbmQpXG4gICAgICAgIHRoaXMud3JpdGUgPSAwO1xuXG4gICAgICAvLyBjb21wdXRlIGJ5dGVzIHRvIGNvcHlcbiAgICAgIG4gPSB0aGlzLndyaXRlIC0gcTtcbiAgICAgIGlmIChuID4gei5hdmFpbF9vdXQpIG4gPSB6LmF2YWlsX291dDtcbiAgICAgIGlmIChuIT0wICYmIHIgPT0gWl9CVUZfRVJST1IpIHIgPSBaX09LO1xuXG4gICAgICAvLyB1cGRhdGUgY291bnRlcnNcbiAgICAgIHouYXZhaWxfb3V0IC09IG47XG4gICAgICB6LnRvdGFsX291dCArPSBuO1xuXG4gICAgICAvLyB1cGRhdGUgY2hlY2sgaW5mb3JtYXRpb25cbiAgICAgIGlmKHRoaXMuY2hlY2tmbiAhPSBudWxsKVxuXHR6LmFkbGVyPXRoaXMuY2hlY2s9ei5fYWRsZXIuYWRsZXIzMih0aGlzLmNoZWNrLCB0aGlzLndpbmRvdywgcSwgbik7XG5cbiAgICAgIC8vIGNvcHlcbiAgICAgIGFycmF5Q29weSh0aGlzLndpbmRvdywgcSwgei5uZXh0X291dCwgcCwgbik7XG4gICAgICBwICs9IG47XG4gICAgICBxICs9IG47XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHBvaW50ZXJzXG4gICAgei5uZXh0X291dF9pbmRleCA9IHA7XG4gICAgdGhpcy5yZWFkID0gcTtcblxuICAgIC8vIGRvbmVcbiAgICByZXR1cm4gcjtcbiAgfVxuXG4vL1xuLy8gSW5mQ29kZXMuamF2YVxuLy9cblxudmFyIElDX1NUQVJUPTA7ICAvLyB4OiBzZXQgdXAgZm9yIExFTlxudmFyIElDX0xFTj0xOyAgICAvLyBpOiBnZXQgbGVuZ3RoL2xpdGVyYWwvZW9iIG5leHRcbnZhciBJQ19MRU5FWFQ9MjsgLy8gaTogZ2V0dGluZyBsZW5ndGggZXh0cmEgKGhhdmUgYmFzZSlcbnZhciBJQ19ESVNUPTM7ICAgLy8gaTogZ2V0IGRpc3RhbmNlIG5leHRcbnZhciBJQ19ESVNURVhUPTQ7Ly8gaTogZ2V0dGluZyBkaXN0YW5jZSBleHRyYVxudmFyIElDX0NPUFk9NTsgICAvLyBvOiBjb3B5aW5nIGJ5dGVzIGluIHdpbmRvdywgd2FpdGluZyBmb3Igc3BhY2VcbnZhciBJQ19MSVQ9NjsgICAgLy8gbzogZ290IGxpdGVyYWwsIHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZVxudmFyIElDX1dBU0g9NzsgICAvLyBvOiBnb3QgZW9iLCBwb3NzaWJseSBzdGlsbCBvdXRwdXQgd2FpdGluZ1xudmFyIElDX0VORD04OyAgICAvLyB4OiBnb3QgZW9iIGFuZCBhbGwgZGF0YSBmbHVzaGVkXG52YXIgSUNfQkFEQ09ERT05Oy8vIHg6IGdvdCBlcnJvclxuXG5mdW5jdGlvbiBJbmZDb2RlcygpIHtcbn1cblxuSW5mQ29kZXMucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihibCwgYmQsIHRsLCB0bF9pbmRleCwgdGQsIHRkX2luZGV4LCB6KSB7XG4gICAgdGhpcy5tb2RlPUlDX1NUQVJUO1xuICAgIHRoaXMubGJpdHM9Ymw7XG4gICAgdGhpcy5kYml0cz1iZDtcbiAgICB0aGlzLmx0cmVlPXRsO1xuICAgIHRoaXMubHRyZWVfaW5kZXg9dGxfaW5kZXg7XG4gICAgdGhpcy5kdHJlZSA9IHRkO1xuICAgIHRoaXMuZHRyZWVfaW5kZXg9dGRfaW5kZXg7XG4gICAgdGhpcy50cmVlPW51bGw7XG59XG5cbkluZkNvZGVzLnByb3RvdHlwZS5wcm9jID0gZnVuY3Rpb24ocywgeiwgcil7IFxuICAgIHZhciBqOyAgICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IHN0b3JhZ2VcbiAgICB2YXIgdDsgICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBwb2ludGVyIChpbnRbXSlcbiAgICB2YXIgdGluZGV4OyAgICAgICAgIC8vIHRlbXBvcmFyeSBwb2ludGVyXG4gICAgdmFyIGU7ICAgICAgICAgICAgICAvLyBleHRyYSBiaXRzIG9yIG9wZXJhdGlvblxuICAgIHZhciBiPTA7ICAgICAgICAgICAgLy8gYml0IGJ1ZmZlclxuICAgIHZhciBrPTA7ICAgICAgICAgICAgLy8gYml0cyBpbiBiaXQgYnVmZmVyXG4gICAgdmFyIHA9MDsgICAgICAgICAgICAvLyBpbnB1dCBkYXRhIHBvaW50ZXJcbiAgICB2YXIgbjsgICAgICAgICAgICAgIC8vIGJ5dGVzIGF2YWlsYWJsZSB0aGVyZVxuICAgIHZhciBxOyAgICAgICAgICAgICAgLy8gb3V0cHV0IHdpbmRvdyB3cml0ZSBwb2ludGVyXG4gICAgdmFyIG07ICAgICAgICAgICAgICAvLyBieXRlcyB0byBlbmQgb2Ygd2luZG93IG9yIHJlYWQgcG9pbnRlclxuICAgIHZhciBmOyAgICAgICAgICAgICAgLy8gcG9pbnRlciB0byBjb3B5IHN0cmluZ3MgZnJvbVxuXG4gICAgLy8gY29weSBpbnB1dC9vdXRwdXQgaW5mb3JtYXRpb24gdG8gbG9jYWxzIChVUERBVEUgbWFjcm8gcmVzdG9yZXMpXG4gICAgcD16Lm5leHRfaW5faW5kZXg7bj16LmF2YWlsX2luO2I9cy5iaXRiO2s9cy5iaXRrO1xuICAgIHE9cy53cml0ZTttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTtcblxuICAgIC8vIHByb2Nlc3MgaW5wdXQgYW5kIG91dHB1dCBiYXNlZCBvbiBjdXJyZW50IHN0YXRlXG4gICAgd2hpbGUgKHRydWUpe1xuICAgICAgc3dpdGNoICh0aGlzLm1vZGUpe1xuXHQvLyB3YWl0aW5nIGZvciBcImk6XCI9aW5wdXQsIFwibzpcIj1vdXRwdXQsIFwieDpcIj1ub3RoaW5nXG4gICAgICBjYXNlIElDX1NUQVJUOiAgICAgICAgIC8vIHg6IHNldCB1cCBmb3IgTEVOXG5cdGlmIChtID49IDI1OCAmJiBuID49IDEwKXtcblxuXHQgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICBzLndyaXRlPXE7XG5cdCAgciA9IHRoaXMuaW5mbGF0ZV9mYXN0KHRoaXMubGJpdHMsIHRoaXMuZGJpdHMsIFxuXHRcdFx0ICAgdGhpcy5sdHJlZSwgdGhpcy5sdHJlZV9pbmRleCwgXG5cdFx0XHQgICB0aGlzLmR0cmVlLCB0aGlzLmR0cmVlX2luZGV4LFxuXHRcdFx0ICAgcywgeik7XG5cblx0ICBwPXoubmV4dF9pbl9pbmRleDtuPXouYXZhaWxfaW47Yj1zLmJpdGI7az1zLmJpdGs7XG5cdCAgcT1zLndyaXRlO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO1xuXG5cdCAgaWYgKHIgIT0gWl9PSyl7XG5cdCAgICB0aGlzLm1vZGUgPSByID09IFpfU1RSRUFNX0VORCA/IElDX1dBU0ggOiBJQ19CQURDT0RFO1xuXHQgICAgYnJlYWs7XG5cdCAgfVxuXHR9XG5cdHRoaXMubmVlZCA9IHRoaXMubGJpdHM7XG5cdHRoaXMudHJlZSA9IHRoaXMubHRyZWU7XG5cdHRoaXMudHJlZV9pbmRleD10aGlzLmx0cmVlX2luZGV4O1xuXG5cdHRoaXMubW9kZSA9IElDX0xFTjtcbiAgICAgIGNhc2UgSUNfTEVOOiAgICAgICAgICAgLy8gaTogZ2V0IGxlbmd0aC9saXRlcmFsL2VvYiBuZXh0XG5cdGogPSB0aGlzLm5lZWQ7XG5cblx0d2hpbGUoazwoaikpe1xuXHQgIGlmKG4hPTApcj1aX09LO1xuXHQgIGVsc2V7XG5cblx0ICAgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgcy53cml0ZT1xO1xuXHQgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgIH1cblx0ICBuLS07XG5cdCAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgIGsrPTg7XG5cdH1cblxuXHR0aW5kZXg9KHRoaXMudHJlZV9pbmRleCsoYiZpbmZsYXRlX21hc2tbal0pKSozO1xuXG5cdGI+Pj49KHRoaXMudHJlZVt0aW5kZXgrMV0pO1xuXHRrLT0odGhpcy50cmVlW3RpbmRleCsxXSk7XG5cblx0ZT10aGlzLnRyZWVbdGluZGV4XTtcblxuXHRpZihlID09IDApeyAgICAgICAgICAgICAgIC8vIGxpdGVyYWxcblx0ICB0aGlzLmxpdCA9IHRoaXMudHJlZVt0aW5kZXgrMl07XG5cdCAgdGhpcy5tb2RlID0gSUNfTElUO1xuXHQgIGJyZWFrO1xuXHR9XG5cdGlmKChlICYgMTYpIT0wICl7ICAgICAgICAgIC8vIGxlbmd0aFxuXHQgIHRoaXMuZ2V0ID0gZSAmIDE1O1xuXHQgIHRoaXMubGVuID0gdGhpcy50cmVlW3RpbmRleCsyXTtcblx0ICB0aGlzLm1vZGUgPSBJQ19MRU5FWFQ7XG5cdCAgYnJlYWs7XG5cdH1cblx0aWYgKChlICYgNjQpID09IDApeyAgICAgICAgLy8gbmV4dCB0YWJsZVxuXHQgIHRoaXMubmVlZCA9IGU7XG5cdCAgdGhpcy50cmVlX2luZGV4ID0gdGluZGV4LzMgKyB0aGlzLnRyZWVbdGluZGV4KzJdO1xuXHQgIGJyZWFrO1xuXHR9XG5cdGlmICgoZSAmIDMyKSE9MCl7ICAgICAgICAgICAgICAgLy8gZW5kIG9mIGJsb2NrXG5cdCAgdGhpcy5tb2RlID0gSUNfV0FTSDtcblx0ICBicmVhaztcblx0fVxuXHR0aGlzLm1vZGUgPSBJQ19CQURDT0RFOyAgICAgICAgLy8gaW52YWxpZCBjb2RlXG5cdHoubXNnID0gXCJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGVcIjtcblx0ciA9IFpfREFUQV9FUlJPUjtcblxuXHRzLmJpdGI9YjtzLmJpdGs9aztcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHRzLndyaXRlPXE7XG5cdHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblxuICAgICAgY2FzZSBJQ19MRU5FWFQ6ICAgICAgICAvLyBpOiBnZXR0aW5nIGxlbmd0aCBleHRyYSAoaGF2ZSBiYXNlKVxuXHRqID0gdGhpcy5nZXQ7XG5cblx0d2hpbGUoazwoaikpe1xuXHQgIGlmKG4hPTApcj1aX09LO1xuXHQgIGVsc2V7XG5cblx0ICAgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgcy53cml0ZT1xO1xuXHQgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgIH1cblx0ICBuLS07IGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICBrKz04O1xuXHR9XG5cblx0dGhpcy5sZW4gKz0gKGIgJiBpbmZsYXRlX21hc2tbal0pO1xuXG5cdGI+Pj1qO1xuXHRrLT1qO1xuXG5cdHRoaXMubmVlZCA9IHRoaXMuZGJpdHM7XG5cdHRoaXMudHJlZSA9IHRoaXMuZHRyZWU7XG5cdHRoaXMudHJlZV9pbmRleCA9IHRoaXMuZHRyZWVfaW5kZXg7XG5cdHRoaXMubW9kZSA9IElDX0RJU1Q7XG4gICAgICBjYXNlIElDX0RJU1Q6ICAgICAgICAgIC8vIGk6IGdldCBkaXN0YW5jZSBuZXh0XG5cdGogPSB0aGlzLm5lZWQ7XG5cblx0d2hpbGUoazwoaikpe1xuXHQgIGlmKG4hPTApcj1aX09LO1xuXHQgIGVsc2V7XG5cblx0ICAgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgcy53cml0ZT1xO1xuXHQgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgIH1cblx0ICBuLS07IGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICBrKz04O1xuXHR9XG5cblx0dGluZGV4PSh0aGlzLnRyZWVfaW5kZXgrKGIgJiBpbmZsYXRlX21hc2tbal0pKSozO1xuXG5cdGI+Pj10aGlzLnRyZWVbdGluZGV4KzFdO1xuXHRrLT10aGlzLnRyZWVbdGluZGV4KzFdO1xuXG5cdGUgPSAodGhpcy50cmVlW3RpbmRleF0pO1xuXHRpZigoZSAmIDE2KSE9MCl7ICAgICAgICAgICAgICAgLy8gZGlzdGFuY2Vcblx0ICB0aGlzLmdldCA9IGUgJiAxNTtcblx0ICB0aGlzLmRpc3QgPSB0aGlzLnRyZWVbdGluZGV4KzJdO1xuXHQgIHRoaXMubW9kZSA9IElDX0RJU1RFWFQ7XG5cdCAgYnJlYWs7XG5cdH1cblx0aWYgKChlICYgNjQpID09IDApeyAgICAgICAgLy8gbmV4dCB0YWJsZVxuXHQgIHRoaXMubmVlZCA9IGU7XG5cdCAgdGhpcy50cmVlX2luZGV4ID0gdGluZGV4LzMgKyB0aGlzLnRyZWVbdGluZGV4KzJdO1xuXHQgIGJyZWFrO1xuXHR9XG5cdHRoaXMubW9kZSA9IElDX0JBRENPREU7ICAgICAgICAvLyBpbnZhbGlkIGNvZGVcblx0ei5tc2cgPSBcImludmFsaWQgZGlzdGFuY2UgY29kZVwiO1xuXHRyID0gWl9EQVRBX0VSUk9SO1xuXG5cdHMuYml0Yj1iO3MuYml0az1rO1xuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHMud3JpdGU9cTtcblx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXG4gICAgICBjYXNlIElDX0RJU1RFWFQ6ICAgICAgIC8vIGk6IGdldHRpbmcgZGlzdGFuY2UgZXh0cmFcblx0aiA9IHRoaXMuZ2V0O1xuXG5cdHdoaWxlKGs8KGopKXtcblx0ICBpZihuIT0wKXI9Wl9PSztcblx0ICBlbHNle1xuXG5cdCAgICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHMud3JpdGU9cTtcblx0ICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9XG5cdCAgbi0tOyBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXG5cdHRoaXMuZGlzdCArPSAoYiAmIGluZmxhdGVfbWFza1tqXSk7XG5cblx0Yj4+PWo7XG5cdGstPWo7XG5cblx0dGhpcy5tb2RlID0gSUNfQ09QWTtcbiAgICAgIGNhc2UgSUNfQ09QWTogICAgICAgICAgLy8gbzogY29weWluZyBieXRlcyBpbiB3aW5kb3csIHdhaXRpbmcgZm9yIHNwYWNlXG4gICAgICAgIGYgPSBxIC0gdGhpcy5kaXN0O1xuICAgICAgICB3aGlsZShmIDwgMCl7ICAgICAvLyBtb2R1bG8gd2luZG93IHNpemUtXCJ3aGlsZVwiIGluc3RlYWRcbiAgICAgICAgICBmICs9IHMuZW5kOyAgICAgLy8gb2YgXCJpZlwiIGhhbmRsZXMgaW52YWxpZCBkaXN0YW5jZXNcblx0fVxuXHR3aGlsZSAodGhpcy5sZW4hPTApe1xuXG5cdCAgaWYobT09MCl7XG5cdCAgICBpZihxPT1zLmVuZCYmcy5yZWFkIT0wKXtxPTA7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7fVxuXHQgICAgaWYobT09MCl7XG5cdCAgICAgIHMud3JpdGU9cTsgcj1zLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgICAgcT1zLndyaXRlO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO1xuXG5cdCAgICAgIGlmKHE9PXMuZW5kJiZzLnJlYWQhPTApe3E9MDttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTt9XG5cblx0ICAgICAgaWYobT09MCl7XG5cdFx0cy5iaXRiPWI7cy5iaXRrPWs7XG5cdFx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHRcdHMud3JpdGU9cTtcblx0XHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICAgIH0gIFxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHMud2luZG93W3ErK109cy53aW5kb3dbZisrXTsgbS0tO1xuXG5cdCAgaWYgKGYgPT0gcy5lbmQpXG4gICAgICAgICAgICBmID0gMDtcblx0ICB0aGlzLmxlbi0tO1xuXHR9XG5cdHRoaXMubW9kZSA9IElDX1NUQVJUO1xuXHRicmVhaztcbiAgICAgIGNhc2UgSUNfTElUOiAgICAgICAgICAgLy8gbzogZ290IGxpdGVyYWwsIHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZVxuXHRpZihtPT0wKXtcblx0ICBpZihxPT1zLmVuZCYmcy5yZWFkIT0wKXtxPTA7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7fVxuXHQgIGlmKG09PTApe1xuXHQgICAgcy53cml0ZT1xOyByPXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgcT1zLndyaXRlO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO1xuXG5cdCAgICBpZihxPT1zLmVuZCYmcy5yZWFkIT0wKXtxPTA7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7fVxuXHQgICAgaWYobT09MCl7XG5cdCAgICAgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgICAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICAgIHMud3JpdGU9cTtcblx0ICAgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRyPVpfT0s7XG5cblx0cy53aW5kb3dbcSsrXT10aGlzLmxpdDsgbS0tO1xuXG5cdHRoaXMubW9kZSA9IElDX1NUQVJUO1xuXHRicmVhaztcbiAgICAgIGNhc2UgSUNfV0FTSDogICAgICAgICAgIC8vIG86IGdvdCBlb2IsIHBvc3NpYmx5IG1vcmUgb3V0cHV0XG5cdGlmIChrID4gNyl7ICAgICAgICAvLyByZXR1cm4gdW51c2VkIGJ5dGUsIGlmIGFueVxuXHQgIGsgLT0gODtcblx0ICBuKys7XG5cdCAgcC0tOyAgICAgICAgICAgICAvLyBjYW4gYWx3YXlzIHJldHVybiBvbmVcblx0fVxuXG5cdHMud3JpdGU9cTsgcj1zLmluZmxhdGVfZmx1c2goeixyKTtcblx0cT1zLndyaXRlO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO1xuXG5cdGlmIChzLnJlYWQgIT0gcy53cml0ZSl7XG5cdCAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHMud3JpdGU9cTtcblx0ICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdH1cblx0dGhpcy5tb2RlID0gSUNfRU5EO1xuICAgICAgY2FzZSBJQ19FTkQ6XG5cdHIgPSBaX1NUUkVBTV9FTkQ7XG5cdHMuYml0Yj1iO3MuYml0az1rO1xuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHMud3JpdGU9cTtcblx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXG4gICAgICBjYXNlIElDX0JBRENPREU6ICAgICAgIC8vIHg6IGdvdCBlcnJvclxuXG5cdHIgPSBaX0RBVEFfRVJST1I7XG5cblx0cy5iaXRiPWI7cy5iaXRrPWs7XG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0cy53cml0ZT1xO1xuXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cbiAgICAgIGRlZmF1bHQ6XG5cdHIgPSBaX1NUUkVBTV9FUlJPUjtcblxuXHRzLmJpdGI9YjtzLmJpdGs9aztcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHRzLndyaXRlPXE7XG5cdHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuSW5mQ29kZXMucHJvdG90eXBlLmZyZWUgPSBmdW5jdGlvbih6KXtcbiAgICAvLyAgWkZSRUUoeiwgYyk7XG59XG5cbiAgLy8gQ2FsbGVkIHdpdGggbnVtYmVyIG9mIGJ5dGVzIGxlZnQgdG8gd3JpdGUgaW4gd2luZG93IGF0IGxlYXN0IDI1OFxuICAvLyAodGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aCkgYW5kIG51bWJlciBvZiBpbnB1dCBieXRlcyBhdmFpbGFibGVcbiAgLy8gYXQgbGVhc3QgdGVuLiAgVGhlIHRlbiBieXRlcyBhcmUgc2l4IGJ5dGVzIGZvciB0aGUgbG9uZ2VzdCBsZW5ndGgvXG4gIC8vIGRpc3RhbmNlIHBhaXIgcGx1cyBmb3VyIGJ5dGVzIGZvciBvdmVybG9hZGluZyB0aGUgYml0IGJ1ZmZlci5cblxuSW5mQ29kZXMucHJvdG90eXBlLmluZmxhdGVfZmFzdCA9IGZ1bmN0aW9uKGJsLCBiZCwgdGwsIHRsX2luZGV4LCB0ZCwgdGRfaW5kZXgsIHMsIHopIHtcbiAgICB2YXIgdDsgICAgICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IHBvaW50ZXJcbiAgICB2YXIgICB0cDsgICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IHBvaW50ZXIgKGludFtdKVxuICAgIHZhciB0cF9pbmRleDsgICAgICAgICAvLyB0ZW1wb3JhcnkgcG9pbnRlclxuICAgIHZhciBlOyAgICAgICAgICAgICAgICAvLyBleHRyYSBiaXRzIG9yIG9wZXJhdGlvblxuICAgIHZhciBiOyAgICAgICAgICAgICAgICAvLyBiaXQgYnVmZmVyXG4gICAgdmFyIGs7ICAgICAgICAgICAgICAgIC8vIGJpdHMgaW4gYml0IGJ1ZmZlclxuICAgIHZhciBwOyAgICAgICAgICAgICAgICAvLyBpbnB1dCBkYXRhIHBvaW50ZXJcbiAgICB2YXIgbjsgICAgICAgICAgICAgICAgLy8gYnl0ZXMgYXZhaWxhYmxlIHRoZXJlXG4gICAgdmFyIHE7ICAgICAgICAgICAgICAgIC8vIG91dHB1dCB3aW5kb3cgd3JpdGUgcG9pbnRlclxuICAgIHZhciBtOyAgICAgICAgICAgICAgICAvLyBieXRlcyB0byBlbmQgb2Ygd2luZG93IG9yIHJlYWQgcG9pbnRlclxuICAgIHZhciBtbDsgICAgICAgICAgICAgICAvLyBtYXNrIGZvciBsaXRlcmFsL2xlbmd0aCB0cmVlXG4gICAgdmFyIG1kOyAgICAgICAgICAgICAgIC8vIG1hc2sgZm9yIGRpc3RhbmNlIHRyZWVcbiAgICB2YXIgYzsgICAgICAgICAgICAgICAgLy8gYnl0ZXMgdG8gY29weVxuICAgIHZhciBkOyAgICAgICAgICAgICAgICAvLyBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgZnJvbVxuICAgIHZhciByOyAgICAgICAgICAgICAgICAvLyBjb3B5IHNvdXJjZSBwb2ludGVyXG5cbiAgICB2YXIgdHBfaW5kZXhfdF8zOyAgICAgLy8gKHRwX2luZGV4K3QpKjNcblxuICAgIC8vIGxvYWQgaW5wdXQsIG91dHB1dCwgYml0IHZhbHVlc1xuICAgIHA9ei5uZXh0X2luX2luZGV4O249ei5hdmFpbF9pbjtiPXMuYml0YjtrPXMuYml0aztcbiAgICBxPXMud3JpdGU7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7XG5cbiAgICAvLyBpbml0aWFsaXplIG1hc2tzXG4gICAgbWwgPSBpbmZsYXRlX21hc2tbYmxdO1xuICAgIG1kID0gaW5mbGF0ZV9tYXNrW2JkXTtcblxuICAgIC8vIGRvIHVudGlsIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IHNwYWNlIGZvciBmYXN0IGxvb3BcbiAgICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3N1bWUgY2FsbGVkIHdpdGggbSA+PSAyNTggJiYgbiA+PSAxMFxuICAgICAgLy8gZ2V0IGxpdGVyYWwvbGVuZ3RoIGNvZGVcbiAgICAgIHdoaWxlKGs8KDIwKSl7ICAgICAgICAgICAgICAvLyBtYXggYml0cyBmb3IgbGl0ZXJhbC9sZW5ndGggY29kZVxuXHRuLS07XG5cdGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztrKz04O1xuICAgICAgfVxuXG4gICAgICB0PSBiJm1sO1xuICAgICAgdHA9dGw7IFxuICAgICAgdHBfaW5kZXg9dGxfaW5kZXg7XG4gICAgICB0cF9pbmRleF90XzM9KHRwX2luZGV4K3QpKjM7XG4gICAgICBpZiAoKGUgPSB0cFt0cF9pbmRleF90XzNdKSA9PSAwKXtcblx0Yj4+PSh0cFt0cF9pbmRleF90XzMrMV0pOyBrLT0odHBbdHBfaW5kZXhfdF8zKzFdKTtcblxuXHRzLndpbmRvd1txKytdID0gdHBbdHBfaW5kZXhfdF8zKzJdO1xuXHRtLS07XG5cdGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZG8ge1xuXG5cdGI+Pj0odHBbdHBfaW5kZXhfdF8zKzFdKTsgay09KHRwW3RwX2luZGV4X3RfMysxXSk7XG5cblx0aWYoKGUmMTYpIT0wKXtcblx0ICBlICY9IDE1O1xuXHQgIGMgPSB0cFt0cF9pbmRleF90XzMrMl0gKyAoYiAmIGluZmxhdGVfbWFza1tlXSk7XG5cblx0ICBiPj49ZTsgay09ZTtcblxuXHQgIC8vIGRlY29kZSBkaXN0YW5jZSBiYXNlIG9mIGJsb2NrIHRvIGNvcHlcblx0ICB3aGlsZShrPCgxNSkpeyAgICAgICAgICAgLy8gbWF4IGJpdHMgZm9yIGRpc3RhbmNlIGNvZGVcblx0ICAgIG4tLTtcblx0ICAgIGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztrKz04O1xuXHQgIH1cblxuXHQgIHQ9IGImbWQ7XG5cdCAgdHA9dGQ7XG5cdCAgdHBfaW5kZXg9dGRfaW5kZXg7XG4gICAgICAgICAgdHBfaW5kZXhfdF8zPSh0cF9pbmRleCt0KSozO1xuXHQgIGUgPSB0cFt0cF9pbmRleF90XzNdO1xuXG5cdCAgZG8ge1xuXG5cdCAgICBiPj49KHRwW3RwX2luZGV4X3RfMysxXSk7IGstPSh0cFt0cF9pbmRleF90XzMrMV0pO1xuXG5cdCAgICBpZigoZSYxNikhPTApe1xuXHQgICAgICAvLyBnZXQgZXh0cmEgYml0cyB0byBhZGQgdG8gZGlzdGFuY2UgYmFzZVxuXHQgICAgICBlICY9IDE1O1xuXHQgICAgICB3aGlsZShrPChlKSl7ICAgICAgICAgLy8gZ2V0IGV4dHJhIGJpdHMgKHVwIHRvIDEzKVxuXHRcdG4tLTtcblx0XHRifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7ays9ODtcblx0ICAgICAgfVxuXG5cdCAgICAgIGQgPSB0cFt0cF9pbmRleF90XzMrMl0gKyAoYiZpbmZsYXRlX21hc2tbZV0pO1xuXG5cdCAgICAgIGI+Pj0oZSk7IGstPShlKTtcblxuXHQgICAgICAvLyBkbyB0aGUgY29weVxuXHQgICAgICBtIC09IGM7XG5cdCAgICAgIGlmIChxID49IGQpeyAgICAgICAgICAgICAgICAvLyBvZmZzZXQgYmVmb3JlIGRlc3Rcblx0XHQvLyAganVzdCBjb3B5XG5cdFx0cj1xLWQ7XG5cdFx0aWYocS1yPjAgJiYgMj4ocS1yKSl7ICAgICAgICAgICBcblx0XHQgIHMud2luZG93W3ErK109cy53aW5kb3dbcisrXTsgLy8gbWluaW11bSBjb3VudCBpcyB0aHJlZSxcblx0XHQgIHMud2luZG93W3ErK109cy53aW5kb3dbcisrXTsgLy8gc28gdW5yb2xsIGxvb3AgYSBsaXR0bGVcblx0XHQgIGMtPTI7XG5cdFx0fVxuXHRcdGVsc2V7XG5cdFx0ICBzLndpbmRvd1txKytdPXMud2luZG93W3IrK107IC8vIG1pbmltdW0gY291bnQgaXMgdGhyZWUsXG5cdFx0ICBzLndpbmRvd1txKytdPXMud2luZG93W3IrK107IC8vIHNvIHVucm9sbCBsb29wIGEgbGl0dGxlXG5cdFx0ICBjLT0yO1xuXHRcdH1cblx0ICAgICAgfVxuXHQgICAgICBlbHNleyAgICAgICAgICAgICAgICAgIC8vIGVsc2Ugb2Zmc2V0IGFmdGVyIGRlc3RpbmF0aW9uXG4gICAgICAgICAgICAgICAgcj1xLWQ7XG4gICAgICAgICAgICAgICAgZG97XG4gICAgICAgICAgICAgICAgICByKz1zLmVuZDsgICAgICAgICAgLy8gZm9yY2UgcG9pbnRlciBpbiB3aW5kb3dcbiAgICAgICAgICAgICAgICB9d2hpbGUocjwwKTsgICAgICAgICAvLyBjb3ZlcnMgaW52YWxpZCBkaXN0YW5jZXNcblx0XHRlPXMuZW5kLXI7XG5cdFx0aWYoYz5lKXsgICAgICAgICAgICAgLy8gaWYgc291cmNlIGNyb3NzZXMsXG5cdFx0ICBjLT1lOyAgICAgICAgICAgICAgLy8gd3JhcHBlZCBjb3B5XG5cdFx0ICBpZihxLXI+MCAmJiBlPihxLXIpKXsgICAgICAgICAgIFxuXHRcdCAgICBkb3tzLndpbmRvd1txKytdID0gcy53aW5kb3dbcisrXTt9XG5cdFx0ICAgIHdoaWxlKC0tZSE9MCk7XG5cdFx0ICB9XG5cdFx0ICBlbHNle1xuXHRcdCAgICBhcnJheUNvcHkocy53aW5kb3csIHIsIHMud2luZG93LCBxLCBlKTtcblx0XHQgICAgcSs9ZTsgcis9ZTsgZT0wO1xuXHRcdCAgfVxuXHRcdCAgciA9IDA7ICAgICAgICAgICAgICAgICAgLy8gY29weSByZXN0IGZyb20gc3RhcnQgb2Ygd2luZG93XG5cdFx0fVxuXG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBjb3B5IGFsbCBvciB3aGF0J3MgbGVmdFxuICAgICAgICAgICAgICBkb3tzLndpbmRvd1txKytdID0gcy53aW5kb3dbcisrXTt9XG5cdFx0d2hpbGUoLS1jIT0wKTtcblx0ICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmKChlJjY0KT09MCl7XG5cdCAgICAgIHQrPXRwW3RwX2luZGV4X3RfMysyXTtcblx0ICAgICAgdCs9KGImaW5mbGF0ZV9tYXNrW2VdKTtcblx0ICAgICAgdHBfaW5kZXhfdF8zPSh0cF9pbmRleCt0KSozO1xuXHQgICAgICBlPXRwW3RwX2luZGV4X3RfM107XG5cdCAgICB9XG5cdCAgICBlbHNle1xuXHQgICAgICB6Lm1zZyA9IFwiaW52YWxpZCBkaXN0YW5jZSBjb2RlXCI7XG5cblx0ICAgICAgYz16LmF2YWlsX2luLW47Yz0oaz4+Myk8Yz9rPj4zOmM7bis9YztwLT1jO2stPWM8PDM7XG5cblx0ICAgICAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgICAgcy53cml0ZT1xO1xuXG5cdCAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHdoaWxlKHRydWUpO1xuXHQgIGJyZWFrO1xuXHR9XG5cblx0aWYoKGUmNjQpPT0wKXtcblx0ICB0Kz10cFt0cF9pbmRleF90XzMrMl07XG5cdCAgdCs9KGImaW5mbGF0ZV9tYXNrW2VdKTtcblx0ICB0cF9pbmRleF90XzM9KHRwX2luZGV4K3QpKjM7XG5cdCAgaWYoKGU9dHBbdHBfaW5kZXhfdF8zXSk9PTApe1xuXG5cdCAgICBiPj49KHRwW3RwX2luZGV4X3RfMysxXSk7IGstPSh0cFt0cF9pbmRleF90XzMrMV0pO1xuXG5cdCAgICBzLndpbmRvd1txKytdPXRwW3RwX2luZGV4X3RfMysyXTtcblx0ICAgIG0tLTtcblx0ICAgIGJyZWFrO1xuXHQgIH1cblx0fVxuXHRlbHNlIGlmKChlJjMyKSE9MCl7XG5cblx0ICBjPXouYXZhaWxfaW4tbjtjPShrPj4zKTxjP2s+PjM6YztuKz1jO3AtPWM7ay09Yzw8MztcbiBcblx0ICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgcy53cml0ZT1xO1xuXG5cdCAgcmV0dXJuIFpfU1RSRUFNX0VORDtcblx0fVxuXHRlbHNle1xuXHQgIHoubXNnPVwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlXCI7XG5cblx0ICBjPXouYXZhaWxfaW4tbjtjPShrPj4zKTxjP2s+PjM6YztuKz1jO3AtPWM7ay09Yzw8MztcblxuXHQgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICBzLndyaXRlPXE7XG5cblx0ICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuXHR9XG4gICAgICB9IFxuICAgICAgd2hpbGUodHJ1ZSk7XG4gICAgfSBcbiAgICB3aGlsZShtPj0yNTggJiYgbj49IDEwKTtcblxuICAgIC8vIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0LS1yZXN0b3JlIHBvaW50ZXJzIGFuZCByZXR1cm5cbiAgICBjPXouYXZhaWxfaW4tbjtjPShrPj4zKTxjP2s+PjM6YztuKz1jO3AtPWM7ay09Yzw8MztcblxuICAgIHMuYml0Yj1iO3MuYml0az1rO1xuICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcbiAgICBzLndyaXRlPXE7XG5cbiAgICByZXR1cm4gWl9PSztcbn1cblxuLy9cbi8vIEluZlRyZWUuamF2YVxuLy9cblxuZnVuY3Rpb24gSW5mVHJlZSgpIHtcbn1cblxuSW5mVHJlZS5wcm90b3R5cGUuaHVmdF9idWlsZCA9IGZ1bmN0aW9uKGIsIGJpbmRleCwgbiwgcywgZCwgZSwgdCwgbSwgaHAsIGhuLCB2KSB7XG5cbiAgICAvLyBHaXZlbiBhIGxpc3Qgb2YgY29kZSBsZW5ndGhzIGFuZCBhIG1heGltdW0gdGFibGUgc2l6ZSwgbWFrZSBhIHNldCBvZlxuICAgIC8vIHRhYmxlcyB0byBkZWNvZGUgdGhhdCBzZXQgb2YgY29kZXMuICBSZXR1cm4gWl9PSyBvbiBzdWNjZXNzLCBaX0JVRl9FUlJPUlxuICAgIC8vIGlmIHRoZSBnaXZlbiBjb2RlIHNldCBpcyBpbmNvbXBsZXRlICh0aGUgdGFibGVzIGFyZSBzdGlsbCBidWlsdCBpbiB0aGlzXG4gICAgLy8gY2FzZSksIFpfREFUQV9FUlJPUiBpZiB0aGUgaW5wdXQgaXMgaW52YWxpZCAoYW4gb3Zlci1zdWJzY3JpYmVkIHNldCBvZlxuICAgIC8vIGxlbmd0aHMpLCBvciBaX01FTV9FUlJPUiBpZiBub3QgZW5vdWdoIG1lbW9yeS5cblxuICAgIHZhciBhOyAgICAgICAgICAgICAgICAgICAgICAgLy8gY291bnRlciBmb3IgY29kZXMgb2YgbGVuZ3RoIGtcbiAgICB2YXIgZjsgICAgICAgICAgICAgICAgICAgICAgIC8vIGkgcmVwZWF0cyBpbiB0YWJsZSBldmVyeSBmIGVudHJpZXNcbiAgICB2YXIgZzsgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heGltdW0gY29kZSBsZW5ndGhcbiAgICB2YXIgaDsgICAgICAgICAgICAgICAgICAgICAgIC8vIHRhYmxlIGxldmVsXG4gICAgdmFyIGk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3VudGVyLCBjdXJyZW50IGNvZGVcbiAgICB2YXIgajsgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvdW50ZXJcbiAgICB2YXIgazsgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bWJlciBvZiBiaXRzIGluIGN1cnJlbnQgY29kZVxuICAgIHZhciBsOyAgICAgICAgICAgICAgICAgICAgICAgLy8gYml0cyBwZXIgdGFibGUgKHJldHVybmVkIGluIG0pXG4gICAgdmFyIG1hc2s7ICAgICAgICAgICAgICAgICAgICAvLyAoMSA8PCB3KSAtIDEsIHRvIGF2b2lkIGNjIC1PIGJ1ZyBvbiBIUFxuICAgIHZhciBwOyAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRlciBpbnRvIGNbXSwgYltdLCBvciB2W11cbiAgICB2YXIgcTsgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cyB0byBjdXJyZW50IHRhYmxlXG4gICAgdmFyIHc7ICAgICAgICAgICAgICAgICAgICAgICAvLyBiaXRzIGJlZm9yZSB0aGlzIHRhYmxlID09IChsICogaClcbiAgICB2YXIgeHA7ICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50ZXIgaW50byB4XG4gICAgdmFyIHk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXIgb2YgZHVtbXkgY29kZXMgYWRkZWRcbiAgICB2YXIgejsgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bWJlciBvZiBlbnRyaWVzIGluIGN1cnJlbnQgdGFibGVcblxuICAgIC8vIEdlbmVyYXRlIGNvdW50cyBmb3IgZWFjaCBiaXQgbGVuZ3RoXG5cbiAgICBwID0gMDsgaSA9IG47XG4gICAgZG8ge1xuICAgICAgdGhpcy5jW2JbYmluZGV4K3BdXSsrOyBwKys7IGktLTsgICAvLyBhc3N1bWUgYWxsIGVudHJpZXMgPD0gQk1BWFxuICAgIH13aGlsZShpIT0wKTtcblxuICAgIGlmKHRoaXMuY1swXSA9PSBuKXsgICAgICAgICAgICAgICAgLy8gbnVsbCBpbnB1dC0tYWxsIHplcm8gbGVuZ3RoIGNvZGVzXG4gICAgICB0WzBdID0gLTE7XG4gICAgICBtWzBdID0gMDtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8vIEZpbmQgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGgsIGJvdW5kICptIGJ5IHRob3NlXG4gICAgbCA9IG1bMF07XG4gICAgZm9yIChqID0gMTsgaiA8PSBCTUFYOyBqKyspXG4gICAgICBpZih0aGlzLmNbal0hPTApIGJyZWFrO1xuICAgIGsgPSBqOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pbmltdW0gY29kZSBsZW5ndGhcbiAgICBpZihsIDwgail7XG4gICAgICBsID0gajtcbiAgICB9XG4gICAgZm9yIChpID0gQk1BWDsgaSE9MDsgaS0tKXtcbiAgICAgIGlmKHRoaXMuY1tpXSE9MCkgYnJlYWs7XG4gICAgfVxuICAgIGcgPSBpOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heGltdW0gY29kZSBsZW5ndGhcbiAgICBpZihsID4gaSl7XG4gICAgICBsID0gaTtcbiAgICB9XG4gICAgbVswXSA9IGw7XG5cbiAgICAvLyBBZGp1c3QgbGFzdCBsZW5ndGggY291bnQgdG8gZmlsbCBvdXQgY29kZXMsIGlmIG5lZWRlZFxuICAgIGZvciAoeSA9IDEgPDwgajsgaiA8IGk7IGorKywgeSA8PD0gMSl7XG4gICAgICBpZiAoKHkgLT0gdGhpcy5jW2pdKSA8IDApe1xuICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKHkgLT0gdGhpcy5jW2ldKSA8IDApe1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG4gICAgdGhpcy5jW2ldICs9IHk7XG5cbiAgICAvLyBHZW5lcmF0ZSBzdGFydGluZyBvZmZzZXRzIGludG8gdGhlIHZhbHVlIHRhYmxlIGZvciBlYWNoIGxlbmd0aFxuICAgIHRoaXMueFsxXSA9IGogPSAwO1xuICAgIHAgPSAxOyAgeHAgPSAyO1xuICAgIHdoaWxlICgtLWkhPTApIHsgICAgICAgICAgICAgICAgIC8vIG5vdGUgdGhhdCBpID09IGcgZnJvbSBhYm92ZVxuICAgICAgdGhpcy54W3hwXSA9IChqICs9IHRoaXMuY1twXSk7XG4gICAgICB4cCsrO1xuICAgICAgcCsrO1xuICAgIH1cblxuICAgIC8vIE1ha2UgYSB0YWJsZSBvZiB2YWx1ZXMgaW4gb3JkZXIgb2YgYml0IGxlbmd0aHNcbiAgICBpID0gMDsgcCA9IDA7XG4gICAgZG8ge1xuICAgICAgaWYgKChqID0gYltiaW5kZXgrcF0pICE9IDApe1xuICAgICAgICB0aGlzLnZbdGhpcy54W2pdKytdID0gaTtcbiAgICAgIH1cbiAgICAgIHArKztcbiAgICB9XG4gICAgd2hpbGUgKCsraSA8IG4pO1xuICAgIG4gPSB0aGlzLnhbZ107ICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IG4gdG8gbGVuZ3RoIG9mIHZcblxuICAgIC8vIEdlbmVyYXRlIHRoZSBIdWZmbWFuIGNvZGVzIGFuZCBmb3IgZWFjaCwgbWFrZSB0aGUgdGFibGUgZW50cmllc1xuICAgIHRoaXMueFswXSA9IGkgPSAwOyAgICAgICAgICAgICAgICAgLy8gZmlyc3QgSHVmZm1hbiBjb2RlIGlzIHplcm9cbiAgICBwID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAvLyBncmFiIHZhbHVlcyBpbiBiaXQgb3JkZXJcbiAgICBoID0gLTE7ICAgICAgICAgICAgICAgICAgICAgICAvLyBubyB0YWJsZXMgeWV0LS1sZXZlbCAtMVxuICAgIHcgPSAtbDsgICAgICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgZGVjb2RlZCA9PSAobCAqIGgpXG4gICAgdGhpcy51WzBdID0gMDsgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHRvIGtlZXAgY29tcGlsZXJzIGhhcHB5XG4gICAgcSA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGl0dG9cbiAgICB6ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXR0b1xuXG4gICAgLy8gZ28gdGhyb3VnaCB0aGUgYml0IGxlbmd0aHMgKGsgYWxyZWFkeSBpcyBiaXRzIGluIHNob3J0ZXN0IGNvZGUpXG4gICAgZm9yICg7IGsgPD0gZzsgaysrKXtcbiAgICAgIGEgPSB0aGlzLmNba107XG4gICAgICB3aGlsZSAoYS0tIT0wKXtcblx0Ly8gaGVyZSBpIGlzIHRoZSBIdWZmbWFuIGNvZGUgb2YgbGVuZ3RoIGsgYml0cyBmb3IgdmFsdWUgKnBcblx0Ly8gbWFrZSB0YWJsZXMgdXAgdG8gcmVxdWlyZWQgbGV2ZWxcbiAgICAgICAgd2hpbGUgKGsgPiB3ICsgbCl7XG4gICAgICAgICAgaCsrO1xuICAgICAgICAgIHcgKz0gbDsgICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIHRhYmxlIGFsd2F5cyBsIGJpdHNcblx0ICAvLyBjb21wdXRlIG1pbmltdW0gc2l6ZSB0YWJsZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbCBiaXRzXG4gICAgICAgICAgeiA9IGcgLSB3O1xuICAgICAgICAgIHogPSAoeiA+IGwpID8gbCA6IHo7ICAgICAgICAvLyB0YWJsZSBzaXplIHVwcGVyIGxpbWl0XG4gICAgICAgICAgaWYoKGY9MTw8KGo9ay13KSk+YSsxKXsgICAgIC8vIHRyeSBhIGstdyBiaXQgdGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG9vIGZldyBjb2RlcyBmb3Igay13IGJpdCB0YWJsZVxuICAgICAgICAgICAgZiAtPSBhICsgMTsgICAgICAgICAgICAgICAvLyBkZWR1Y3QgY29kZXMgZnJvbSBwYXR0ZXJucyBsZWZ0XG4gICAgICAgICAgICB4cCA9IGs7XG4gICAgICAgICAgICBpZihqIDwgeil7XG4gICAgICAgICAgICAgIHdoaWxlICgrK2ogPCB6KXsgICAgICAgIC8vIHRyeSBzbWFsbGVyIHRhYmxlcyB1cCB0byB6IGJpdHNcbiAgICAgICAgICAgICAgICBpZigoZiA8PD0gMSkgPD0gdGhpcy5jWysreHBdKVxuICAgICAgICAgICAgICAgICAgYnJlYWs7ICAgICAgICAgICAgICAvLyBlbm91Z2ggY29kZXMgdG8gdXNlIHVwIGogYml0c1xuICAgICAgICAgICAgICAgIGYgLT0gdGhpcy5jW3hwXTsgICAgICAgICAgIC8vIGVsc2UgZGVkdWN0IGNvZGVzIGZyb20gcGF0dGVybnNcbiAgICAgICAgICAgICAgfVxuXHQgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB6ID0gMSA8PCBqOyAgICAgICAgICAgICAgICAgLy8gdGFibGUgZW50cmllcyBmb3Igai1iaXQgdGFibGVcblxuXHQgIC8vIGFsbG9jYXRlIG5ldyB0YWJsZVxuICAgICAgICAgIGlmICh0aGlzLmhuWzBdICsgeiA+IE1BTlkpeyAgICAgICAvLyAobm90ZTogZG9lc24ndCBtYXR0ZXIgZm9yIGZpeGVkKVxuICAgICAgICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjsgICAgICAgLy8gb3ZlcmZsb3cgb2YgTUFOWVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnVbaF0gPSBxID0gLypocCsqLyB0aGlzLmhuWzBdOyAgIC8vIERFQlVHXG4gICAgICAgICAgdGhpcy5oblswXSArPSB6O1xuIFxuXHQgIC8vIGNvbm5lY3QgdG8gbGFzdCB0YWJsZSwgaWYgdGhlcmUgaXMgb25lXG5cdCAgaWYoaCE9MCl7XG4gICAgICAgICAgICB0aGlzLnhbaF09aTsgICAgICAgICAgIC8vIHNhdmUgcGF0dGVybiBmb3IgYmFja2luZyB1cFxuICAgICAgICAgICAgdGhpcy5yWzBdPWo7ICAgICAvLyBiaXRzIGluIHRoaXMgdGFibGVcbiAgICAgICAgICAgIHRoaXMuclsxXT1sOyAgICAgLy8gYml0cyB0byBkdW1wIGJlZm9yZSB0aGlzIHRhYmxlXG4gICAgICAgICAgICBqPWk+Pj4odyAtIGwpO1xuICAgICAgICAgICAgdGhpcy5yWzJdID0gKHEgLSB0aGlzLnVbaC0xXSAtIGopOyAgICAgICAgICAgICAgIC8vIG9mZnNldCB0byB0aGlzIHRhYmxlXG4gICAgICAgICAgICBhcnJheUNvcHkodGhpcy5yLCAwLCBocCwgKHRoaXMudVtoLTFdK2opKjMsIDMpOyAvLyBjb25uZWN0IHRvIGxhc3QgdGFibGVcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHRbMF0gPSBxOyAgICAgICAgICAgICAgIC8vIGZpcnN0IHRhYmxlIGlzIHJldHVybmVkIHJlc3VsdFxuXHQgIH1cbiAgICAgICAgfVxuXG5cdC8vIHNldCB1cCB0YWJsZSBlbnRyeSBpbiByXG4gICAgICAgIHRoaXMuclsxXSA9IChrIC0gdyk7XG4gICAgICAgIGlmIChwID49IG4pe1xuICAgICAgICAgIHRoaXMuclswXSA9IDEyOCArIDY0OyAgICAgIC8vIG91dCBvZiB2YWx1ZXMtLWludmFsaWQgY29kZVxuXHR9XG4gICAgICAgIGVsc2UgaWYgKHZbcF0gPCBzKXtcbiAgICAgICAgICB0aGlzLnJbMF0gPSAodGhpcy52W3BdIDwgMjU2ID8gMCA6IDMyICsgNjQpOyAgLy8gMjU2IGlzIGVuZC1vZi1ibG9ja1xuICAgICAgICAgIHRoaXMuclsyXSA9IHRoaXMudltwKytdOyAgICAgICAgICAvLyBzaW1wbGUgY29kZSBpcyBqdXN0IHRoZSB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgdGhpcy5yWzBdPShlW3RoaXMudltwXS1zXSsxNis2NCk7IC8vIG5vbi1zaW1wbGUtLWxvb2sgdXAgaW4gbGlzdHNcbiAgICAgICAgICB0aGlzLnJbMl09ZFt0aGlzLnZbcCsrXSAtIHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsbCBjb2RlLWxpa2UgZW50cmllcyB3aXRoIHJcbiAgICAgICAgZj0xPDwoay13KTtcbiAgICAgICAgZm9yIChqPWk+Pj53O2o8ejtqKz1mKXtcbiAgICAgICAgICBhcnJheUNvcHkodGhpcy5yLCAwLCBocCwgKHEraikqMywgMyk7XG5cdH1cblxuXHQvLyBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBrLWJpdCBjb2RlIGlcbiAgICAgICAgZm9yIChqID0gMSA8PCAoayAtIDEpOyAoaSAmIGopIT0wOyBqID4+Pj0gMSl7XG4gICAgICAgICAgaSBePSBqO1xuXHR9XG4gICAgICAgIGkgXj0gajtcblxuXHQvLyBiYWNrdXAgb3ZlciBmaW5pc2hlZCB0YWJsZXNcbiAgICAgICAgbWFzayA9ICgxIDw8IHcpIC0gMTsgICAgICAvLyBuZWVkZWQgb24gSFAsIGNjIC1PIGJ1Z1xuICAgICAgICB3aGlsZSAoKGkgJiBtYXNrKSAhPSB0aGlzLnhbaF0pe1xuICAgICAgICAgIGgtLTsgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IG5lZWQgdG8gdXBkYXRlIHFcbiAgICAgICAgICB3IC09IGw7XG4gICAgICAgICAgbWFzayA9ICgxIDw8IHcpIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm4gWl9CVUZfRVJST1IgaWYgd2Ugd2VyZSBnaXZlbiBhbiBpbmNvbXBsZXRlIHRhYmxlXG4gICAgcmV0dXJuIHkgIT0gMCAmJiBnICE9IDEgPyBaX0JVRl9FUlJPUiA6IFpfT0s7XG59XG5cbkluZlRyZWUucHJvdG90eXBlLmluZmxhdGVfdHJlZXNfYml0cyA9IGZ1bmN0aW9uKGMsIGJiLCB0YiwgaHAsIHopIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHRoaXMuaW5pdFdvcmtBcmVhKDE5KTtcbiAgICB0aGlzLmhuWzBdPTA7XG4gICAgcmVzdWx0ID0gdGhpcy5odWZ0X2J1aWxkKGMsIDAsIDE5LCAxOSwgbnVsbCwgbnVsbCwgdGIsIGJiLCBocCwgdGhpcy5obiwgdGhpcy52KTtcblxuICAgIGlmKHJlc3VsdCA9PSBaX0RBVEFfRVJST1Ipe1xuICAgICAgei5tc2cgPSBcIm92ZXJzdWJzY3JpYmVkIGR5bmFtaWMgYml0IGxlbmd0aHMgdHJlZVwiO1xuICAgIH1cbiAgICBlbHNlIGlmKHJlc3VsdCA9PSBaX0JVRl9FUlJPUiB8fCBiYlswXSA9PSAwKXtcbiAgICAgIHoubXNnID0gXCJpbmNvbXBsZXRlIGR5bmFtaWMgYml0IGxlbmd0aHMgdHJlZVwiO1xuICAgICAgcmVzdWx0ID0gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5JbmZUcmVlLnByb3RvdHlwZS5pbmZsYXRlX3RyZWVzX2R5bmFtaWMgPSBmdW5jdGlvbihubCwgbmQsIGMsIGJsLCBiZCwgdGwsIHRkLCBocCwgeikge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICAvLyBidWlsZCBsaXRlcmFsL2xlbmd0aCB0cmVlXG4gICAgdGhpcy5pbml0V29ya0FyZWEoMjg4KTtcbiAgICB0aGlzLmhuWzBdPTA7XG4gICAgcmVzdWx0ID0gdGhpcy5odWZ0X2J1aWxkKGMsIDAsIG5sLCAyNTcsIGNwbGVucywgY3BsZXh0LCB0bCwgYmwsIGhwLCB0aGlzLmhuLCB0aGlzLnYpO1xuICAgIGlmIChyZXN1bHQgIT0gWl9PSyB8fCBibFswXSA9PSAwKXtcbiAgICAgIGlmKHJlc3VsdCA9PSBaX0RBVEFfRVJST1Ipe1xuICAgICAgICB6Lm1zZyA9IFwib3ZlcnN1YnNjcmliZWQgbGl0ZXJhbC9sZW5ndGggdHJlZVwiO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocmVzdWx0ICE9IFpfTUVNX0VSUk9SKXtcbiAgICAgICAgei5tc2cgPSBcImluY29tcGxldGUgbGl0ZXJhbC9sZW5ndGggdHJlZVwiO1xuICAgICAgICByZXN1bHQgPSBaX0RBVEFfRVJST1I7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIGJ1aWxkIGRpc3RhbmNlIHRyZWVcbiAgICB0aGlzLmluaXRXb3JrQXJlYSgyODgpO1xuICAgIHJlc3VsdCA9IHRoaXMuaHVmdF9idWlsZChjLCBubCwgbmQsIDAsIGNwZGlzdCwgY3BkZXh0LCB0ZCwgYmQsIGhwLCB0aGlzLmhuLCB0aGlzLnYpO1xuXG4gICAgaWYgKHJlc3VsdCAhPSBaX09LIHx8IChiZFswXSA9PSAwICYmIG5sID4gMjU3KSl7XG4gICAgICBpZiAocmVzdWx0ID09IFpfREFUQV9FUlJPUil7XG4gICAgICAgIHoubXNnID0gXCJvdmVyc3Vic2NyaWJlZCBkaXN0YW5jZSB0cmVlXCI7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChyZXN1bHQgPT0gWl9CVUZfRVJST1IpIHtcbiAgICAgICAgei5tc2cgPSBcImluY29tcGxldGUgZGlzdGFuY2UgdHJlZVwiO1xuICAgICAgICByZXN1bHQgPSBaX0RBVEFfRVJST1I7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChyZXN1bHQgIT0gWl9NRU1fRVJST1Ipe1xuICAgICAgICB6Lm1zZyA9IFwiZW1wdHkgZGlzdGFuY2UgdHJlZSB3aXRoIGxlbmd0aHNcIjtcbiAgICAgICAgcmVzdWx0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gWl9PSztcbn1cbi8qXG4gIHN0YXRpYyBpbnQgaW5mbGF0ZV90cmVlc19maXhlZChpbnRbXSBibCwgIC8vbGl0ZXJhbCBkZXNpcmVkL2FjdHVhbCBiaXQgZGVwdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludFtdIGJkLCAgLy9kaXN0YW5jZSBkZXNpcmVkL2FjdHVhbCBiaXQgZGVwdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludFtdW10gdGwsLy9saXRlcmFsL2xlbmd0aCB0cmVlIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50W11bXSB0ZCwvL2Rpc3RhbmNlIHRyZWUgcmVzdWx0IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWlN0cmVhbSB6ICAvL2ZvciBtZW1vcnkgYWxsb2NhdGlvblxuXHRcdFx0XHQgKXtcblxuKi9cblxuZnVuY3Rpb24gaW5mbGF0ZV90cmVlc19maXhlZChibCwgYmQsIHRsLCB0ZCwgeikge1xuICAgIGJsWzBdPWZpeGVkX2JsO1xuICAgIGJkWzBdPWZpeGVkX2JkO1xuICAgIHRsWzBdPWZpeGVkX3RsO1xuICAgIHRkWzBdPWZpeGVkX3RkO1xuICAgIHJldHVybiBaX09LO1xufVxuXG5JbmZUcmVlLnByb3RvdHlwZS5pbml0V29ya0FyZWEgPSBmdW5jdGlvbih2c2l6ZSl7XG4gICAgaWYodGhpcy5obj09bnVsbCl7XG4gICAgICAgIHRoaXMuaG49bmV3IEludDMyQXJyYXkoMSk7XG4gICAgICAgIHRoaXMudj1uZXcgSW50MzJBcnJheSh2c2l6ZSk7XG4gICAgICAgIHRoaXMuYz1uZXcgSW50MzJBcnJheShCTUFYKzEpO1xuICAgICAgICB0aGlzLnI9bmV3IEludDMyQXJyYXkoMyk7XG4gICAgICAgIHRoaXMudT1uZXcgSW50MzJBcnJheShCTUFYKTtcbiAgICAgICAgdGhpcy54PW5ldyBJbnQzMkFycmF5KEJNQVgrMSk7XG4gICAgfVxuICAgIGlmKHRoaXMudi5sZW5ndGg8dnNpemUpeyBcbiAgICAgICAgdGhpcy52PW5ldyBJbnQzMkFycmF5KHZzaXplKTsgXG4gICAgfVxuICAgIGZvcih2YXIgaT0wOyBpPHZzaXplOyBpKyspe3RoaXMudltpXT0wO31cbiAgICBmb3IodmFyIGk9MDsgaTxCTUFYKzE7IGkrKyl7dGhpcy5jW2ldPTA7fVxuICAgIGZvcih2YXIgaT0wOyBpPDM7IGkrKyl7dGhpcy5yW2ldPTA7fVxuLy8gIGZvcihpbnQgaT0wOyBpPEJNQVg7IGkrKyl7dVtpXT0wO31cbiAgICBhcnJheUNvcHkodGhpcy5jLCAwLCB0aGlzLnUsIDAsIEJNQVgpO1xuLy8gIGZvcihpbnQgaT0wOyBpPEJNQVgrMTsgaSsrKXt4W2ldPTA7fVxuICAgIGFycmF5Q29weSh0aGlzLmMsIDAsIHRoaXMueCwgMCwgQk1BWCsxKTtcbn1cblxudmFyIHRlc3RBcnJheSA9IG5ldyBVaW50OEFycmF5KDEpO1xudmFyIGhhc1N1YmFycmF5ID0gKHR5cGVvZiB0ZXN0QXJyYXkuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicpO1xudmFyIGhhc1NsaWNlID0gZmFsc2U7IC8qICh0eXBlb2YgdGVzdEFycmF5LnNsaWNlID09PSAnZnVuY3Rpb24nKTsgKi8gLy8gQ2hyb21lIHNsaWNlIHBlcmZvcm1hbmNlIGlzIHNvIGRpcmUgdGhhdCB3ZSdyZSBjdXJyZW50bHkgbm90IHVzaW5nIGl0Li4uXG5cbmZ1bmN0aW9uIGFycmF5Q29weShzcmMsIHNyY09mZnNldCwgZGVzdCwgZGVzdE9mZnNldCwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfSBcbiAgICBpZiAoIXNyYykge1xuICAgICAgICB0aHJvdyBcIlVuZGVmIHNyY1wiO1xuICAgIH0gZWxzZSBpZiAoIWRlc3QpIHtcbiAgICAgICAgdGhyb3cgXCJVbmRlZiBkZXN0XCI7XG4gICAgfVxuXG4gICAgaWYgKHNyY09mZnNldCA9PSAwICYmIGNvdW50ID09IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgYXJyYXlDb3B5X2Zhc3Qoc3JjLCBkZXN0LCBkZXN0T2Zmc2V0KTtcbiAgICB9IGVsc2UgaWYgKGhhc1N1YmFycmF5KSB7XG4gICAgICAgIGFycmF5Q29weV9mYXN0KHNyYy5zdWJhcnJheShzcmNPZmZzZXQsIHNyY09mZnNldCArIGNvdW50KSwgZGVzdCwgZGVzdE9mZnNldCk7IFxuICAgIH0gZWxzZSBpZiAoc3JjLkJZVEVTX1BFUl9FTEVNRU5UID09IDEgJiYgY291bnQgPiAxMDApIHtcbiAgICAgICAgYXJyYXlDb3B5X2Zhc3QobmV3IFVpbnQ4QXJyYXkoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQgKyBzcmNPZmZzZXQsIGNvdW50KSwgZGVzdCwgZGVzdE9mZnNldCk7XG4gICAgfSBlbHNlIHsgXG4gICAgICAgIGFycmF5Q29weV9zbG93KHNyYywgc3JjT2Zmc2V0LCBkZXN0LCBkZXN0T2Zmc2V0LCBjb3VudCk7XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGFycmF5Q29weV9zbG93KHNyYywgc3JjT2Zmc2V0LCBkZXN0LCBkZXN0T2Zmc2V0LCBjb3VudCkge1xuXG4gICAgLy8gZGxvZygnX3Nsb3cgY2FsbDogc3JjT2Zmc2V0PScgKyBzcmNPZmZzZXQgKyAnOyBkZXN0T2Zmc2V0PScgKyBkZXN0T2Zmc2V0ICsgJzsgY291bnQ9JyArIGNvdW50KTtcblxuICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgaV0gPSBzcmNbc3JjT2Zmc2V0ICsgaV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcnJheUNvcHlfZmFzdChzcmMsIGRlc3QsIGRlc3RPZmZzZXQpIHtcbiAgICBkZXN0LnNldChzcmMsIGRlc3RPZmZzZXQpO1xufVxuXG5cbiAgLy8gbGFyZ2VzdCBwcmltZSBzbWFsbGVyIHRoYW4gNjU1MzZcbnZhciBBRExFUl9CQVNFPTY1NTIxOyBcbiAgLy8gTk1BWCBpcyB0aGUgbGFyZ2VzdCBuIHN1Y2ggdGhhdCAyNTVuKG4rMSkvMiArIChuKzEpKEJBU0UtMSkgPD0gMl4zMi0xXG52YXIgQURMRVJfTk1BWD01NTUyO1xuXG5mdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCAvKiBieXRlW10gKi8gYnVmLCAgaW5kZXgsIGxlbil7XG4gICAgaWYoYnVmID09IG51bGwpeyByZXR1cm4gMTsgfVxuXG4gICAgdmFyIHMxPWFkbGVyJjB4ZmZmZjtcbiAgICB2YXIgczI9KGFkbGVyPj4xNikmMHhmZmZmO1xuICAgIHZhciBrO1xuXG4gICAgd2hpbGUobGVuID4gMCkge1xuICAgICAgaz1sZW48QURMRVJfTk1BWD9sZW46QURMRVJfTk1BWDtcbiAgICAgIGxlbi09aztcbiAgICAgIHdoaWxlKGs+PTE2KXtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIGstPTE2O1xuICAgICAgfVxuICAgICAgaWYoayE9MCl7XG4gICAgICAgIGRve1xuICAgICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKC0tayE9MCk7XG4gICAgICB9XG4gICAgICBzMSU9QURMRVJfQkFTRTtcbiAgICAgIHMyJT1BRExFUl9CQVNFO1xuICAgIH1cbiAgICByZXR1cm4gKHMyPDwxNil8czE7XG59XG5cblxuXG5mdW5jdGlvbiBqc3psaWJfaW5mbGF0ZV9idWZmZXIoYnVmZmVyLCBzdGFydCwgbGVuZ3RoLCBhZnRlclVuY09mZnNldCkge1xuICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIsIHN0YXJ0LCBsZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciB6ID0gbmV3IFpTdHJlYW0oKTtcbiAgICB6LmluZmxhdGVJbml0KERFRl9XQklUUywgdHJ1ZSk7XG4gICAgei5uZXh0X2luID0gYnVmZmVyO1xuICAgIHoubmV4dF9pbl9pbmRleCA9IDA7XG4gICAgei5hdmFpbF9pbiA9IGJ1ZmZlci5sZW5ndGg7XG5cbiAgICB2YXIgb0Jsb2NrTGlzdCA9IFtdO1xuICAgIHZhciB0b3RhbFNpemUgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBvYnVmID0gbmV3IFVpbnQ4QXJyYXkoMzIwMDApO1xuICAgICAgICB6Lm5leHRfb3V0ID0gb2J1ZjtcbiAgICAgICAgei5uZXh0X291dF9pbmRleCA9IDA7XG4gICAgICAgIHouYXZhaWxfb3V0ID0gb2J1Zi5sZW5ndGg7XG4gICAgICAgIHZhciBzdGF0dXMgPSB6LmluZmxhdGUoWl9OT19GTFVTSCk7XG4gICAgICAgIGlmIChzdGF0dXMgIT0gWl9PSyAmJiBzdGF0dXMgIT0gWl9TVFJFQU1fRU5EKSB7XG4gICAgICAgICAgICB0aHJvdyB6Lm1zZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoei5hdmFpbF9vdXQgIT0gMCkge1xuICAgICAgICAgICAgdmFyIG5ld29iID0gbmV3IFVpbnQ4QXJyYXkob2J1Zi5sZW5ndGggLSB6LmF2YWlsX291dCk7XG4gICAgICAgICAgICBhcnJheUNvcHkob2J1ZiwgMCwgbmV3b2IsIDAsIChvYnVmLmxlbmd0aCAtIHouYXZhaWxfb3V0KSk7XG4gICAgICAgICAgICBvYnVmID0gbmV3b2I7XG4gICAgICAgIH1cbiAgICAgICAgb0Jsb2NrTGlzdC5wdXNoKG9idWYpO1xuICAgICAgICB0b3RhbFNpemUgKz0gb2J1Zi5sZW5ndGg7XG4gICAgICAgIGlmIChzdGF0dXMgPT0gWl9TVFJFQU1fRU5EKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhZnRlclVuY09mZnNldCkge1xuICAgICAgICBhZnRlclVuY09mZnNldFswXSA9IChzdGFydCB8fCAwKSArIHoubmV4dF9pbl9pbmRleDtcbiAgICB9XG5cbiAgICBpZiAob0Jsb2NrTGlzdC5sZW5ndGggPT0gMSkge1xuICAgICAgICByZXR1cm4gb0Jsb2NrTGlzdFswXS5idWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KHRvdGFsU2l6ZSk7XG4gICAgICAgIHZhciBjdXJzb3IgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9CbG9ja0xpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBiID0gb0Jsb2NrTGlzdFtpXTtcbiAgICAgICAgICAgIGFycmF5Q29weShiLCAwLCBvdXQsIGN1cnNvciwgYi5sZW5ndGgpO1xuICAgICAgICAgICAgY3Vyc29yICs9IGIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQuYnVmZmVyO1xuICAgIH1cbn1cblxuZXhwb3J0IHtqc3psaWJfaW5mbGF0ZV9idWZmZXIsYXJyYXlDb3B5fSJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFtSUE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdklBO0FBeUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2Q0E7QUF5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdFlBO0FBd1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJRQTtBQXVRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/vendor/inflate.js\n");

/***/ }),

/***/ "./src/vendor/zlib_and_gzip.min.js":
/*!*****************************************!*\
  !*** ./src/vendor/zlib_and_gzip.min.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function() {'use strict';function q(b){throw b;}var t=void 0,u=!0,aa=this;function A(b,a){var c=b.split(\".\"),d=aa;!(c[0]in d)&&d.execScript&&d.execScript(\"var \"+c[0]);for(var f;c.length&&(f=c.shift());)!c.length&&a!==t?d[f]=a:d=d[f]?d[f]:d[f]={}};var B=\"undefined\"!==typeof Uint8Array&&\"undefined\"!==typeof Uint16Array&&\"undefined\"!==typeof Uint32Array;function F(b,a){this.index=\"number\"===typeof a?a:0;this.m=0;this.buffer=b instanceof(B?Uint8Array:Array)?b:new (B?Uint8Array:Array)(32768);2*this.buffer.length<=this.index&&q(Error(\"invalid index\"));this.buffer.length<=this.index&&this.f()}F.prototype.f=function(){var b=this.buffer,a,c=b.length,d=new (B?Uint8Array:Array)(c<<1);if(B)d.set(b);else for(a=0;a<c;++a)d[a]=b[a];return this.buffer=d};\nF.prototype.d=function(b,a,c){var d=this.buffer,f=this.index,e=this.m,g=d[f],k;c&&1<a&&(b=8<a?(H[b&255]<<24|H[b>>>8&255]<<16|H[b>>>16&255]<<8|H[b>>>24&255])>>32-a:H[b]>>8-a);if(8>a+e)g=g<<a|b,e+=a;else for(k=0;k<a;++k)g=g<<1|b>>a-k-1&1,8===++e&&(e=0,d[f++]=H[g],g=0,f===d.length&&(d=this.f()));d[f]=g;this.buffer=d;this.m=e;this.index=f};F.prototype.finish=function(){var b=this.buffer,a=this.index,c;0<this.m&&(b[a]<<=8-this.m,b[a]=H[b[a]],a++);B?c=b.subarray(0,a):(b.length=a,c=b);return c};\nvar ba=new (B?Uint8Array:Array)(256),ca;for(ca=0;256>ca;++ca){for(var K=ca,da=K,ea=7,K=K>>>1;K;K>>>=1)da<<=1,da|=K&1,--ea;ba[ca]=(da<<ea&255)>>>0}var H=ba;function ja(b,a,c){var d,f=\"number\"===typeof a?a:a=0,e=\"number\"===typeof c?c:b.length;d=-1;for(f=e&7;f--;++a)d=d>>>8^O[(d^b[a])&255];for(f=e>>3;f--;a+=8)d=d>>>8^O[(d^b[a])&255],d=d>>>8^O[(d^b[a+1])&255],d=d>>>8^O[(d^b[a+2])&255],d=d>>>8^O[(d^b[a+3])&255],d=d>>>8^O[(d^b[a+4])&255],d=d>>>8^O[(d^b[a+5])&255],d=d>>>8^O[(d^b[a+6])&255],d=d>>>8^O[(d^b[a+7])&255];return(d^4294967295)>>>0}\nvar ka=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,\n2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,\n2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,\n2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,\n3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,\n936918E3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],O=B?new Uint32Array(ka):ka;function P(){}P.prototype.getName=function(){return this.name};P.prototype.getData=function(){return this.data};P.prototype.X=function(){return this.Y};A(\"Zlib.GunzipMember\",P);A(\"Zlib.GunzipMember.prototype.getName\",P.prototype.getName);A(\"Zlib.GunzipMember.prototype.getData\",P.prototype.getData);A(\"Zlib.GunzipMember.prototype.getMtime\",P.prototype.X);function la(b){this.buffer=new (B?Uint16Array:Array)(2*b);this.length=0}la.prototype.getParent=function(b){return 2*((b-2)/4|0)};la.prototype.push=function(b,a){var c,d,f=this.buffer,e;c=this.length;f[this.length++]=a;for(f[this.length++]=b;0<c;)if(d=this.getParent(c),f[c]>f[d])e=f[c],f[c]=f[d],f[d]=e,e=f[c+1],f[c+1]=f[d+1],f[d+1]=e,c=d;else break;return this.length};\nla.prototype.pop=function(){var b,a,c=this.buffer,d,f,e;a=c[0];b=c[1];this.length-=2;c[0]=c[this.length];c[1]=c[this.length+1];for(e=0;;){f=2*e+2;if(f>=this.length)break;f+2<this.length&&c[f+2]>c[f]&&(f+=2);if(c[f]>c[e])d=c[e],c[e]=c[f],c[f]=d,d=c[e+1],c[e+1]=c[f+1],c[f+1]=d;else break;e=f}return{index:b,value:a,length:this.length}};function ma(b){var a=b.length,c=0,d=Number.POSITIVE_INFINITY,f,e,g,k,h,l,s,n,m;for(n=0;n<a;++n)b[n]>c&&(c=b[n]),b[n]<d&&(d=b[n]);f=1<<c;e=new (B?Uint32Array:Array)(f);g=1;k=0;for(h=2;g<=c;){for(n=0;n<a;++n)if(b[n]===g){l=0;s=k;for(m=0;m<g;++m)l=l<<1|s&1,s>>=1;for(m=l;m<f;m+=h)e[m]=g<<16|n;++k}++g;k<<=1;h<<=1}return[e,c,d]};function na(b,a){this.k=qa;this.I=0;this.input=B&&b instanceof Array?new Uint8Array(b):b;this.b=0;a&&(a.lazy&&(this.I=a.lazy),\"number\"===typeof a.compressionType&&(this.k=a.compressionType),a.outputBuffer&&(this.a=B&&a.outputBuffer instanceof Array?new Uint8Array(a.outputBuffer):a.outputBuffer),\"number\"===typeof a.outputIndex&&(this.b=a.outputIndex));this.a||(this.a=new (B?Uint8Array:Array)(32768))}var qa=2,ra={NONE:0,v:1,o:qa,aa:3},sa=[],S;\nfor(S=0;288>S;S++)switch(u){case 143>=S:sa.push([S+48,8]);break;case 255>=S:sa.push([S-144+400,9]);break;case 279>=S:sa.push([S-256+0,7]);break;case 287>=S:sa.push([S-280+192,8]);break;default:q(\"invalid literal: \"+S)}\nna.prototype.g=function(){var b,a,c,d,f=this.input;switch(this.k){case 0:c=0;for(d=f.length;c<d;){a=B?f.subarray(c,c+65535):f.slice(c,c+65535);c+=a.length;var e=a,g=c===d,k=t,h=t,l=t,s=t,n=t,m=this.a,p=this.b;if(B){for(m=new Uint8Array(this.a.buffer);m.length<=p+e.length+5;)m=new Uint8Array(m.length<<1);m.set(this.a)}k=g?1:0;m[p++]=k|0;h=e.length;l=~h+65536&65535;m[p++]=h&255;m[p++]=h>>>8&255;m[p++]=l&255;m[p++]=l>>>8&255;if(B)m.set(e,p),p+=e.length,m=m.subarray(0,p);else{s=0;for(n=e.length;s<n;++s)m[p++]=\ne[s];m.length=p}this.b=p;this.a=m}break;case 1:var r=new F(B?new Uint8Array(this.a.buffer):this.a,this.b);r.d(1,1,u);r.d(1,2,u);var v=ta(this,f),x,Q,y;x=0;for(Q=v.length;x<Q;x++)if(y=v[x],F.prototype.d.apply(r,sa[y]),256<y)r.d(v[++x],v[++x],u),r.d(v[++x],5),r.d(v[++x],v[++x],u);else if(256===y)break;this.a=r.finish();this.b=this.a.length;break;case qa:var E=new F(B?new Uint8Array(this.a.buffer):this.a,this.b),Ja,R,X,Y,Z,pb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],fa,Ka,ga,La,oa,wa=Array(19),\nMa,$,pa,C,Na;Ja=qa;E.d(1,1,u);E.d(Ja,2,u);R=ta(this,f);fa=ua(this.V,15);Ka=va(fa);ga=ua(this.U,7);La=va(ga);for(X=286;257<X&&0===fa[X-1];X--);for(Y=30;1<Y&&0===ga[Y-1];Y--);var Oa=X,Pa=Y,J=new (B?Uint32Array:Array)(Oa+Pa),w,L,z,ha,I=new (B?Uint32Array:Array)(316),G,D,M=new (B?Uint8Array:Array)(19);for(w=L=0;w<Oa;w++)J[L++]=fa[w];for(w=0;w<Pa;w++)J[L++]=ga[w];if(!B){w=0;for(ha=M.length;w<ha;++w)M[w]=0}w=G=0;for(ha=J.length;w<ha;w+=L){for(L=1;w+L<ha&&J[w+L]===J[w];++L);z=L;if(0===J[w])if(3>z)for(;0<\nz--;)I[G++]=0,M[0]++;else for(;0<z;)D=138>z?z:138,D>z-3&&D<z&&(D=z-3),10>=D?(I[G++]=17,I[G++]=D-3,M[17]++):(I[G++]=18,I[G++]=D-11,M[18]++),z-=D;else if(I[G++]=J[w],M[J[w]]++,z--,3>z)for(;0<z--;)I[G++]=J[w],M[J[w]]++;else for(;0<z;)D=6>z?z:6,D>z-3&&D<z&&(D=z-3),I[G++]=16,I[G++]=D-3,M[16]++,z-=D}b=B?I.subarray(0,G):I.slice(0,G);oa=ua(M,7);for(C=0;19>C;C++)wa[C]=oa[pb[C]];for(Z=19;4<Z&&0===wa[Z-1];Z--);Ma=va(oa);E.d(X-257,5,u);E.d(Y-1,5,u);E.d(Z-4,4,u);for(C=0;C<Z;C++)E.d(wa[C],3,u);C=0;for(Na=b.length;C<\nNa;C++)if($=b[C],E.d(Ma[$],oa[$],u),16<=$){C++;switch($){case 16:pa=2;break;case 17:pa=3;break;case 18:pa=7;break;default:q(\"invalid code: \"+$)}E.d(b[C],pa,u)}var Qa=[Ka,fa],Ra=[La,ga],N,Sa,ia,za,Ta,Ua,Va,Wa;Ta=Qa[0];Ua=Qa[1];Va=Ra[0];Wa=Ra[1];N=0;for(Sa=R.length;N<Sa;++N)if(ia=R[N],E.d(Ta[ia],Ua[ia],u),256<ia)E.d(R[++N],R[++N],u),za=R[++N],E.d(Va[za],Wa[za],u),E.d(R[++N],R[++N],u);else if(256===ia)break;this.a=E.finish();this.b=this.a.length;break;default:q(\"invalid compression type\")}return this.a};\nfunction xa(b,a){this.length=b;this.P=a}\nvar ya=function(){function b(a){switch(u){case 3===a:return[257,a-3,0];case 4===a:return[258,a-4,0];case 5===a:return[259,a-5,0];case 6===a:return[260,a-6,0];case 7===a:return[261,a-7,0];case 8===a:return[262,a-8,0];case 9===a:return[263,a-9,0];case 10===a:return[264,a-10,0];case 12>=a:return[265,a-11,1];case 14>=a:return[266,a-13,1];case 16>=a:return[267,a-15,1];case 18>=a:return[268,a-17,1];case 22>=a:return[269,a-19,2];case 26>=a:return[270,a-23,2];case 30>=a:return[271,a-27,2];case 34>=a:return[272,\na-31,2];case 42>=a:return[273,a-35,3];case 50>=a:return[274,a-43,3];case 58>=a:return[275,a-51,3];case 66>=a:return[276,a-59,3];case 82>=a:return[277,a-67,4];case 98>=a:return[278,a-83,4];case 114>=a:return[279,a-99,4];case 130>=a:return[280,a-115,4];case 162>=a:return[281,a-131,5];case 194>=a:return[282,a-163,5];case 226>=a:return[283,a-195,5];case 257>=a:return[284,a-227,5];case 258===a:return[285,a-258,0];default:q(\"invalid length: \"+a)}}var a=[],c,d;for(c=3;258>=c;c++)d=b(c),a[c]=d[2]<<24|d[1]<<\n16|d[0];return a}(),Aa=B?new Uint32Array(ya):ya;\nfunction ta(b,a){function c(a,c){var b=a.P,d=[],e=0,f;f=Aa[a.length];d[e++]=f&65535;d[e++]=f>>16&255;d[e++]=f>>24;var g;switch(u){case 1===b:g=[0,b-1,0];break;case 2===b:g=[1,b-2,0];break;case 3===b:g=[2,b-3,0];break;case 4===b:g=[3,b-4,0];break;case 6>=b:g=[4,b-5,1];break;case 8>=b:g=[5,b-7,1];break;case 12>=b:g=[6,b-9,2];break;case 16>=b:g=[7,b-13,2];break;case 24>=b:g=[8,b-17,3];break;case 32>=b:g=[9,b-25,3];break;case 48>=b:g=[10,b-33,4];break;case 64>=b:g=[11,b-49,4];break;case 96>=b:g=[12,b-\n65,5];break;case 128>=b:g=[13,b-97,5];break;case 192>=b:g=[14,b-129,6];break;case 256>=b:g=[15,b-193,6];break;case 384>=b:g=[16,b-257,7];break;case 512>=b:g=[17,b-385,7];break;case 768>=b:g=[18,b-513,8];break;case 1024>=b:g=[19,b-769,8];break;case 1536>=b:g=[20,b-1025,9];break;case 2048>=b:g=[21,b-1537,9];break;case 3072>=b:g=[22,b-2049,10];break;case 4096>=b:g=[23,b-3073,10];break;case 6144>=b:g=[24,b-4097,11];break;case 8192>=b:g=[25,b-6145,11];break;case 12288>=b:g=[26,b-8193,12];break;case 16384>=\nb:g=[27,b-12289,12];break;case 24576>=b:g=[28,b-16385,13];break;case 32768>=b:g=[29,b-24577,13];break;default:q(\"invalid distance\")}f=g;d[e++]=f[0];d[e++]=f[1];d[e++]=f[2];var h,k;h=0;for(k=d.length;h<k;++h)m[p++]=d[h];v[d[0]]++;x[d[3]]++;r=a.length+c-1;n=null}var d,f,e,g,k,h={},l,s,n,m=B?new Uint16Array(2*a.length):[],p=0,r=0,v=new (B?Uint32Array:Array)(286),x=new (B?Uint32Array:Array)(30),Q=b.I,y;if(!B){for(e=0;285>=e;)v[e++]=0;for(e=0;29>=e;)x[e++]=0}v[256]=1;d=0;for(f=a.length;d<f;++d){e=k=0;\nfor(g=3;e<g&&d+e!==f;++e)k=k<<8|a[d+e];h[k]===t&&(h[k]=[]);l=h[k];if(!(0<r--)){for(;0<l.length&&32768<d-l[0];)l.shift();if(d+3>=f){n&&c(n,-1);e=0;for(g=f-d;e<g;++e)y=a[d+e],m[p++]=y,++v[y];break}0<l.length?(s=Ba(a,d,l),n?n.length<s.length?(y=a[d-1],m[p++]=y,++v[y],c(s,0)):c(n,-1):s.length<Q?n=s:c(s,0)):n?c(n,-1):(y=a[d],m[p++]=y,++v[y])}l.push(d)}m[p++]=256;v[256]++;b.V=v;b.U=x;return B?m.subarray(0,p):m}\nfunction Ba(b,a,c){var d,f,e=0,g,k,h,l,s=b.length;k=0;l=c.length;a:for(;k<l;k++){d=c[l-k-1];g=3;if(3<e){for(h=e;3<h;h--)if(b[d+h-1]!==b[a+h-1])continue a;g=e}for(;258>g&&a+g<s&&b[d+g]===b[a+g];)++g;g>e&&(f=d,e=g);if(258===g)break}return new xa(e,a-f)}\nfunction ua(b,a){var c=b.length,d=new la(572),f=new (B?Uint8Array:Array)(c),e,g,k,h,l;if(!B)for(h=0;h<c;h++)f[h]=0;for(h=0;h<c;++h)0<b[h]&&d.push(h,b[h]);e=Array(d.length/2);g=new (B?Uint32Array:Array)(d.length/2);if(1===e.length)return f[d.pop().index]=1,f;h=0;for(l=d.length/2;h<l;++h)e[h]=d.pop(),g[h]=e[h].value;k=Ca(g,g.length,a);h=0;for(l=e.length;h<l;++h)f[e[h].index]=k[h];return f}\nfunction Ca(b,a,c){function d(b){var c=h[b][l[b]];c===a?(d(b+1),d(b+1)):--g[c];++l[b]}var f=new (B?Uint16Array:Array)(c),e=new (B?Uint8Array:Array)(c),g=new (B?Uint8Array:Array)(a),k=Array(c),h=Array(c),l=Array(c),s=(1<<c)-a,n=1<<c-1,m,p,r,v,x;f[c-1]=a;for(p=0;p<c;++p)s<n?e[p]=0:(e[p]=1,s-=n),s<<=1,f[c-2-p]=(f[c-1-p]/2|0)+a;f[0]=e[0];k[0]=Array(f[0]);h[0]=Array(f[0]);for(p=1;p<c;++p)f[p]>2*f[p-1]+e[p]&&(f[p]=2*f[p-1]+e[p]),k[p]=Array(f[p]),h[p]=Array(f[p]);for(m=0;m<a;++m)g[m]=c;for(r=0;r<f[c-1];++r)k[c-\n1][r]=b[r],h[c-1][r]=r;for(m=0;m<c;++m)l[m]=0;1===e[c-1]&&(--g[0],++l[c-1]);for(p=c-2;0<=p;--p){v=m=0;x=l[p+1];for(r=0;r<f[p];r++)v=k[p+1][x]+k[p+1][x+1],v>b[m]?(k[p][r]=v,h[p][r]=a,x+=2):(k[p][r]=b[m],h[p][r]=m,++m);l[p]=0;1===e[p]&&d(p)}return g}\nfunction va(b){var a=new (B?Uint16Array:Array)(b.length),c=[],d=[],f=0,e,g,k,h;e=0;for(g=b.length;e<g;e++)c[b[e]]=(c[b[e]]|0)+1;e=1;for(g=16;e<=g;e++)d[e]=f,f+=c[e]|0,f<<=1;e=0;for(g=b.length;e<g;e++){f=d[b[e]];d[b[e]]+=1;k=a[e]=0;for(h=b[e];k<h;k++)a[e]=a[e]<<1|f&1,f>>>=1}return a};function Da(b,a){this.input=b;this.b=this.c=0;this.i={};a&&(a.flags&&(this.i=a.flags),\"string\"===typeof a.filename&&(this.filename=a.filename),\"string\"===typeof a.comment&&(this.A=a.comment),a.deflateOptions&&(this.l=a.deflateOptions));this.l||(this.l={})}\nDa.prototype.g=function(){var b,a,c,d,f,e,g,k,h=new (B?Uint8Array:Array)(32768),l=0,s=this.input,n=this.c,m=this.filename,p=this.A;h[l++]=31;h[l++]=139;h[l++]=8;b=0;this.i.fname&&(b|=Ea);this.i.fcomment&&(b|=Fa);this.i.fhcrc&&(b|=Ga);h[l++]=b;a=(Date.now?Date.now():+new Date)/1E3|0;h[l++]=a&255;h[l++]=a>>>8&255;h[l++]=a>>>16&255;h[l++]=a>>>24&255;h[l++]=0;h[l++]=Ha;if(this.i.fname!==t){g=0;for(k=m.length;g<k;++g)e=m.charCodeAt(g),255<e&&(h[l++]=e>>>8&255),h[l++]=e&255;h[l++]=0}if(this.i.comment){g=\n0;for(k=p.length;g<k;++g)e=p.charCodeAt(g),255<e&&(h[l++]=e>>>8&255),h[l++]=e&255;h[l++]=0}this.i.fhcrc&&(c=ja(h,0,l)&65535,h[l++]=c&255,h[l++]=c>>>8&255);this.l.outputBuffer=h;this.l.outputIndex=l;f=new na(s,this.l);h=f.g();l=f.b;B&&(l+8>h.buffer.byteLength?(this.a=new Uint8Array(l+8),this.a.set(new Uint8Array(h.buffer)),h=this.a):h=new Uint8Array(h.buffer));d=ja(s,t,t);h[l++]=d&255;h[l++]=d>>>8&255;h[l++]=d>>>16&255;h[l++]=d>>>24&255;k=s.length;h[l++]=k&255;h[l++]=k>>>8&255;h[l++]=k>>>16&255;h[l++]=\nk>>>24&255;this.c=n;B&&l<h.length&&(this.a=h=h.subarray(0,l));return h};var Ha=255,Ga=2,Ea=8,Fa=16;A(\"Zlib.Gzip\",Da);A(\"Zlib.Gzip.prototype.compress\",Da.prototype.g);function T(b,a){this.p=[];this.q=32768;this.e=this.j=this.c=this.u=0;this.input=B?new Uint8Array(b):b;this.w=!1;this.r=Ia;this.L=!1;if(a||!(a={}))a.index&&(this.c=a.index),a.bufferSize&&(this.q=a.bufferSize),a.bufferType&&(this.r=a.bufferType),a.resize&&(this.L=a.resize);switch(this.r){case Xa:this.b=32768;this.a=new (B?Uint8Array:Array)(32768+this.q+258);break;case Ia:this.b=0;this.a=new (B?Uint8Array:Array)(this.q);this.f=this.T;this.B=this.Q;this.s=this.S;break;default:q(Error(\"invalid inflate mode\"))}}\nvar Xa=0,Ia=1,Ya={N:Xa,M:Ia};\nT.prototype.h=function(){for(;!this.w;){var b=U(this,3);b&1&&(this.w=u);b>>>=1;switch(b){case 0:var a=this.input,c=this.c,d=this.a,f=this.b,e=t,g=t,k=t,h=d.length,l=t;this.e=this.j=0;e=a[c++];e===t&&q(Error(\"invalid uncompressed block header: LEN (first byte)\"));g=e;e=a[c++];e===t&&q(Error(\"invalid uncompressed block header: LEN (second byte)\"));g|=e<<8;e=a[c++];e===t&&q(Error(\"invalid uncompressed block header: NLEN (first byte)\"));k=e;e=a[c++];e===t&&q(Error(\"invalid uncompressed block header: NLEN (second byte)\"));k|=\ne<<8;g===~k&&q(Error(\"invalid uncompressed block header: length verify\"));c+g>a.length&&q(Error(\"input buffer is broken\"));switch(this.r){case Xa:for(;f+g>d.length;){l=h-f;g-=l;if(B)d.set(a.subarray(c,c+l),f),f+=l,c+=l;else for(;l--;)d[f++]=a[c++];this.b=f;d=this.f();f=this.b}break;case Ia:for(;f+g>d.length;)d=this.f({F:2});break;default:q(Error(\"invalid inflate mode\"))}if(B)d.set(a.subarray(c,c+g),f),f+=g,c+=g;else for(;g--;)d[f++]=a[c++];this.c=c;this.b=f;this.a=d;break;case 1:this.s(Za,$a);break;\ncase 2:ab(this);break;default:q(Error(\"unknown BTYPE: \"+b))}}return this.B()};\nvar bb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],cb=B?new Uint16Array(bb):bb,db=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],eb=B?new Uint16Array(db):db,fb=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],gb=B?new Uint8Array(fb):fb,hb=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],ib=B?new Uint16Array(hb):hb,jb=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,\n10,11,11,12,12,13,13],kb=B?new Uint8Array(jb):jb,lb=new (B?Uint8Array:Array)(288),V,mb;V=0;for(mb=lb.length;V<mb;++V)lb[V]=143>=V?8:255>=V?9:279>=V?7:8;var Za=ma(lb),nb=new (B?Uint8Array:Array)(30),ob,qb;ob=0;for(qb=nb.length;ob<qb;++ob)nb[ob]=5;var $a=ma(nb);function U(b,a){for(var c=b.j,d=b.e,f=b.input,e=b.c,g;d<a;)g=f[e++],g===t&&q(Error(\"input buffer is broken\")),c|=g<<d,d+=8;g=c&(1<<a)-1;b.j=c>>>a;b.e=d-a;b.c=e;return g}\nfunction rb(b,a){for(var c=b.j,d=b.e,f=b.input,e=b.c,g=a[0],k=a[1],h,l,s;d<k;){h=f[e++];if(h===t)break;c|=h<<d;d+=8}l=g[c&(1<<k)-1];s=l>>>16;b.j=c>>s;b.e=d-s;b.c=e;return l&65535}\nfunction ab(b){function a(a,b,c){var d,e,f,g;for(g=0;g<a;)switch(d=rb(this,b),d){case 16:for(f=3+U(this,2);f--;)c[g++]=e;break;case 17:for(f=3+U(this,3);f--;)c[g++]=0;e=0;break;case 18:for(f=11+U(this,7);f--;)c[g++]=0;e=0;break;default:e=c[g++]=d}return c}var c=U(b,5)+257,d=U(b,5)+1,f=U(b,4)+4,e=new (B?Uint8Array:Array)(cb.length),g,k,h,l;for(l=0;l<f;++l)e[cb[l]]=U(b,3);g=ma(e);k=new (B?Uint8Array:Array)(c);h=new (B?Uint8Array:Array)(d);b.s(ma(a.call(b,c,g,k)),ma(a.call(b,d,g,h)))}\nT.prototype.s=function(b,a){var c=this.a,d=this.b;this.C=b;for(var f=c.length-258,e,g,k,h;256!==(e=rb(this,b));)if(256>e)d>=f&&(this.b=d,c=this.f(),d=this.b),c[d++]=e;else{g=e-257;h=eb[g];0<gb[g]&&(h+=U(this,gb[g]));e=rb(this,a);k=ib[e];0<kb[e]&&(k+=U(this,kb[e]));d>=f&&(this.b=d,c=this.f(),d=this.b);for(;h--;)c[d]=c[d++-k]}for(;8<=this.e;)this.e-=8,this.c--;this.b=d};\nT.prototype.S=function(b,a){var c=this.a,d=this.b;this.C=b;for(var f=c.length,e,g,k,h;256!==(e=rb(this,b));)if(256>e)d>=f&&(c=this.f(),f=c.length),c[d++]=e;else{g=e-257;h=eb[g];0<gb[g]&&(h+=U(this,gb[g]));e=rb(this,a);k=ib[e];0<kb[e]&&(k+=U(this,kb[e]));d+h>f&&(c=this.f(),f=c.length);for(;h--;)c[d]=c[d++-k]}for(;8<=this.e;)this.e-=8,this.c--;this.b=d};\nT.prototype.f=function(){var b=new (B?Uint8Array:Array)(this.b-32768),a=this.b-32768,c,d,f=this.a;if(B)b.set(f.subarray(32768,b.length));else{c=0;for(d=b.length;c<d;++c)b[c]=f[c+32768]}this.p.push(b);this.u+=b.length;if(B)f.set(f.subarray(a,a+32768));else for(c=0;32768>c;++c)f[c]=f[a+c];this.b=32768;return f};\nT.prototype.T=function(b){var a,c=this.input.length/this.c+1|0,d,f,e,g=this.input,k=this.a;b&&(\"number\"===typeof b.F&&(c=b.F),\"number\"===typeof b.O&&(c+=b.O));2>c?(d=(g.length-this.c)/this.C[2],e=258*(d/2)|0,f=e<k.length?k.length+e:k.length<<1):f=k.length*c;B?(a=new Uint8Array(f),a.set(k)):a=k;return this.a=a};\nT.prototype.B=function(){var b=0,a=this.a,c=this.p,d,f=new (B?Uint8Array:Array)(this.u+(this.b-32768)),e,g,k,h;if(0===c.length)return B?this.a.subarray(32768,this.b):this.a.slice(32768,this.b);e=0;for(g=c.length;e<g;++e){d=c[e];k=0;for(h=d.length;k<h;++k)f[b++]=d[k]}e=32768;for(g=this.b;e<g;++e)f[b++]=a[e];this.p=[];return this.buffer=f};\nT.prototype.Q=function(){var b,a=this.b;B?this.L?(b=new Uint8Array(a),b.set(this.a.subarray(0,a))):b=this.a.subarray(0,a):(this.a.length>a&&(this.a.length=a),b=this.a);return this.buffer=b};function sb(b){this.input=b;this.c=0;this.t=[];this.D=!1}sb.prototype.W=function(){this.D||this.h();return this.t.slice()};\nsb.prototype.h=function(){for(var b=this.input.length;this.c<b;){var a=new P,c=t,d=t,f=t,e=t,g=t,k=t,h=t,l=t,s=t,n=this.input,m=this.c;a.G=n[m++];a.H=n[m++];(31!==a.G||139!==a.H)&&q(Error(\"invalid file signature:\"+a.G+\",\"+a.H));a.z=n[m++];switch(a.z){case 8:break;default:q(Error(\"unknown compression method: \"+a.z))}a.n=n[m++];l=n[m++]|n[m++]<<8|n[m++]<<16|n[m++]<<24;a.Y=new Date(1E3*l);a.ea=n[m++];a.da=n[m++];0<(a.n&4)&&(a.$=n[m++]|n[m++]<<8,m+=a.$);if(0<(a.n&Ea)){h=[];for(k=0;0<(g=n[m++]);)h[k++]=\nString.fromCharCode(g);a.name=h.join(\"\")}if(0<(a.n&Fa)){h=[];for(k=0;0<(g=n[m++]);)h[k++]=String.fromCharCode(g);a.A=h.join(\"\")}0<(a.n&Ga)&&(a.R=ja(n,0,m)&65535,a.R!==(n[m++]|n[m++]<<8)&&q(Error(\"invalid header crc16\")));c=n[n.length-4]|n[n.length-3]<<8|n[n.length-2]<<16|n[n.length-1]<<24;n.length-m-4-4<512*c&&(e=c);d=new T(n,{index:m,bufferSize:e});a.data=f=d.h();m=d.c;a.ba=s=(n[m++]|n[m++]<<8|n[m++]<<16|n[m++]<<24)>>>0;ja(f,t,t)!==s&&q(Error(\"invalid CRC-32 checksum: 0x\"+ja(f,t,t).toString(16)+\n\" / 0x\"+s.toString(16)));a.ca=c=(n[m++]|n[m++]<<8|n[m++]<<16|n[m++]<<24)>>>0;(f.length&4294967295)!==c&&q(Error(\"invalid input size: \"+(f.length&4294967295)+\" / \"+c));this.t.push(a);this.c=m}this.D=u;var p=this.t,r,v,x=0,Q=0,y;r=0;for(v=p.length;r<v;++r)Q+=p[r].data.length;if(B){y=new Uint8Array(Q);for(r=0;r<v;++r)y.set(p[r].data,x),x+=p[r].data.length}else{y=[];for(r=0;r<v;++r)y[r]=p[r].data;y=Array.prototype.concat.apply([],y)}return y};A(\"Zlib.Gunzip\",sb);A(\"Zlib.Gunzip.prototype.decompress\",sb.prototype.h);A(\"Zlib.Gunzip.prototype.getMembers\",sb.prototype.W);function tb(b){if(\"string\"===typeof b){var a=b.split(\"\"),c,d;c=0;for(d=a.length;c<d;c++)a[c]=(a[c].charCodeAt(0)&255)>>>0;b=a}for(var f=1,e=0,g=b.length,k,h=0;0<g;){k=1024<g?1024:g;g-=k;do f+=b[h++],e+=f;while(--k);f%=65521;e%=65521}return(e<<16|f)>>>0};function ub(b,a){var c,d;this.input=b;this.c=0;if(a||!(a={}))a.index&&(this.c=a.index),a.verify&&(this.Z=a.verify);c=b[this.c++];d=b[this.c++];switch(c&15){case vb:this.method=vb;break;default:q(Error(\"unsupported compression method\"))}0!==((c<<8)+d)%31&&q(Error(\"invalid fcheck flag:\"+((c<<8)+d)%31));d&32&&q(Error(\"fdict flag is not supported\"));this.K=new T(b,{index:this.c,bufferSize:a.bufferSize,bufferType:a.bufferType,resize:a.resize})}\nub.prototype.h=function(){var b=this.input,a,c;a=this.K.h();this.c=this.K.c;this.Z&&(c=(b[this.c++]<<24|b[this.c++]<<16|b[this.c++]<<8|b[this.c++])>>>0,c!==tb(a)&&q(Error(\"invalid adler-32 checksum\")));return a};var vb=8;function wb(b,a){this.input=b;this.a=new (B?Uint8Array:Array)(32768);this.k=W.o;var c={},d;if((a||!(a={}))&&\"number\"===typeof a.compressionType)this.k=a.compressionType;for(d in a)c[d]=a[d];c.outputBuffer=this.a;this.J=new na(this.input,c)}var W=ra;\nwb.prototype.g=function(){var b,a,c,d,f,e,g,k=0;g=this.a;b=vb;switch(b){case vb:a=Math.LOG2E*Math.log(32768)-8;break;default:q(Error(\"invalid compression method\"))}c=a<<4|b;g[k++]=c;switch(b){case vb:switch(this.k){case W.NONE:f=0;break;case W.v:f=1;break;case W.o:f=2;break;default:q(Error(\"unsupported compression type\"))}break;default:q(Error(\"invalid compression method\"))}d=f<<6|0;g[k++]=d|31-(256*c+d)%31;e=tb(this.input);this.J.b=k;g=this.J.g();k=g.length;B&&(g=new Uint8Array(g.buffer),g.length<=\nk+4&&(this.a=new Uint8Array(g.length+4),this.a.set(g),g=this.a),g=g.subarray(0,k+4));g[k++]=e>>24&255;g[k++]=e>>16&255;g[k++]=e>>8&255;g[k++]=e&255;return g};function xb(b,a){var c,d,f,e;if(Object.keys)c=Object.keys(a);else for(d in c=[],f=0,a)c[f++]=d;f=0;for(e=c.length;f<e;++f)d=c[f],A(b+\".\"+d,a[d])};A(\"Zlib.Inflate\",ub);A(\"Zlib.Inflate.prototype.decompress\",ub.prototype.h);xb(\"Zlib.Inflate.BufferType\",{ADAPTIVE:Ya.M,BLOCK:Ya.N});A(\"Zlib.Deflate\",wb);A(\"Zlib.Deflate.compress\",function(b,a){return(new wb(b,a)).g()});A(\"Zlib.Deflate.prototype.compress\",wb.prototype.g);xb(\"Zlib.Deflate.CompressionType\",{NONE:W.NONE,FIXED:W.v,DYNAMIC:W.o});}).call(this); //@ sourceMappingURL=zlib_and_gzip.min.js.map\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmVuZG9yL3psaWJfYW5kX2d6aXAubWluLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3ZlbmRvci96bGliX2FuZF9nemlwLm1pbi5qcz81NmRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSB6bGliLmpzIDIwMTIgLSBpbWF5YSBbIGh0dHBzOi8vZ2l0aHViLmNvbS9pbWF5YS96bGliLmpzIF0gVGhlIE1JVCBMaWNlbnNlICovKGZ1bmN0aW9uKCkgeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBxKGIpe3Rocm93IGI7fXZhciB0PXZvaWQgMCx1PSEwLGFhPXRoaXM7ZnVuY3Rpb24gQShiLGEpe3ZhciBjPWIuc3BsaXQoXCIuXCIpLGQ9YWE7IShjWzBdaW4gZCkmJmQuZXhlY1NjcmlwdCYmZC5leGVjU2NyaXB0KFwidmFyIFwiK2NbMF0pO2Zvcih2YXIgZjtjLmxlbmd0aCYmKGY9Yy5zaGlmdCgpKTspIWMubGVuZ3RoJiZhIT09dD9kW2ZdPWE6ZD1kW2ZdP2RbZl06ZFtmXT17fX07dmFyIEI9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBVaW50OEFycmF5JiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIFVpbnQxNkFycmF5JiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIFVpbnQzMkFycmF5O2Z1bmN0aW9uIEYoYixhKXt0aGlzLmluZGV4PVwibnVtYmVyXCI9PT10eXBlb2YgYT9hOjA7dGhpcy5tPTA7dGhpcy5idWZmZXI9YiBpbnN0YW5jZW9mKEI/VWludDhBcnJheTpBcnJheSk/YjpuZXcgKEI/VWludDhBcnJheTpBcnJheSkoMzI3NjgpOzIqdGhpcy5idWZmZXIubGVuZ3RoPD10aGlzLmluZGV4JiZxKEVycm9yKFwiaW52YWxpZCBpbmRleFwiKSk7dGhpcy5idWZmZXIubGVuZ3RoPD10aGlzLmluZGV4JiZ0aGlzLmYoKX1GLnByb3RvdHlwZS5mPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5idWZmZXIsYSxjPWIubGVuZ3RoLGQ9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKGM8PDEpO2lmKEIpZC5zZXQoYik7ZWxzZSBmb3IoYT0wO2E8YzsrK2EpZFthXT1iW2FdO3JldHVybiB0aGlzLmJ1ZmZlcj1kfTtcbkYucHJvdG90eXBlLmQ9ZnVuY3Rpb24oYixhLGMpe3ZhciBkPXRoaXMuYnVmZmVyLGY9dGhpcy5pbmRleCxlPXRoaXMubSxnPWRbZl0saztjJiYxPGEmJihiPTg8YT8oSFtiJjI1NV08PDI0fEhbYj4+PjgmMjU1XTw8MTZ8SFtiPj4+MTYmMjU1XTw8OHxIW2I+Pj4yNCYyNTVdKT4+MzItYTpIW2JdPj44LWEpO2lmKDg+YStlKWc9Zzw8YXxiLGUrPWE7ZWxzZSBmb3Ioaz0wO2s8YTsrK2spZz1nPDwxfGI+PmEtay0xJjEsOD09PSsrZSYmKGU9MCxkW2YrK109SFtnXSxnPTAsZj09PWQubGVuZ3RoJiYoZD10aGlzLmYoKSkpO2RbZl09Zzt0aGlzLmJ1ZmZlcj1kO3RoaXMubT1lO3RoaXMuaW5kZXg9Zn07Ri5wcm90b3R5cGUuZmluaXNoPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5idWZmZXIsYT10aGlzLmluZGV4LGM7MDx0aGlzLm0mJihiW2FdPDw9OC10aGlzLm0sYlthXT1IW2JbYV1dLGErKyk7Qj9jPWIuc3ViYXJyYXkoMCxhKTooYi5sZW5ndGg9YSxjPWIpO3JldHVybiBjfTtcbnZhciBiYT1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMjU2KSxjYTtmb3IoY2E9MDsyNTY+Y2E7KytjYSl7Zm9yKHZhciBLPWNhLGRhPUssZWE9NyxLPUs+Pj4xO0s7Sz4+Pj0xKWRhPDw9MSxkYXw9SyYxLC0tZWE7YmFbY2FdPShkYTw8ZWEmMjU1KT4+PjB9dmFyIEg9YmE7ZnVuY3Rpb24gamEoYixhLGMpe3ZhciBkLGY9XCJudW1iZXJcIj09PXR5cGVvZiBhP2E6YT0wLGU9XCJudW1iZXJcIj09PXR5cGVvZiBjP2M6Yi5sZW5ndGg7ZD0tMTtmb3IoZj1lJjc7Zi0tOysrYSlkPWQ+Pj44Xk9bKGReYlthXSkmMjU1XTtmb3IoZj1lPj4zO2YtLTthKz04KWQ9ZD4+PjheT1soZF5iW2FdKSYyNTVdLGQ9ZD4+PjheT1soZF5iW2ErMV0pJjI1NV0sZD1kPj4+OF5PWyhkXmJbYSsyXSkmMjU1XSxkPWQ+Pj44Xk9bKGReYlthKzNdKSYyNTVdLGQ9ZD4+PjheT1soZF5iW2ErNF0pJjI1NV0sZD1kPj4+OF5PWyhkXmJbYSs1XSkmMjU1XSxkPWQ+Pj44Xk9bKGReYlthKzZdKSYyNTVdLGQ9ZD4+PjheT1soZF5iW2ErN10pJjI1NV07cmV0dXJuKGReNDI5NDk2NzI5NSk+Pj4wfVxudmFyIGthPVswLDE5OTY5NTk4OTQsMzk5MzkxOTc4OCwyNTY3NTI0Nzk0LDEyNDYzNDEzNywxODg2MDU3NjE1LDM5MTU2MjE2ODUsMjY1NzM5MjAzNSwyNDkyNjgyNzQsMjA0NDUwODMyNCwzNzcyMTE1MjMwLDI1NDcxNzc4NjQsMTYyOTQxOTk1LDIxMjU1NjEwMjEsMzg4NzYwNzA0NywyNDI4NDQ0MDQ5LDQ5ODUzNjU0OCwxNzg5OTI3NjY2LDQwODkwMTY2NDgsMjIyNzA2MTIxNCw0NTA1NDg4NjEsMTg0MzI1ODYwMyw0MTA3NTgwNzUzLDIyMTE2Nzc2MzksMzI1ODgzOTkwLDE2ODQ3NzcxNTIsNDI1MTEyMjA0MiwyMzIxOTI2NjM2LDMzNTYzMzQ4NywxNjYxMzY1NDY1LDQxOTUzMDI3NTUsMjM2NjExNTMxNyw5OTcwNzMwOTYsMTI4MTk1Mzg4NiwzNTc5ODU1MzMyLDI3MjQ2ODgyNDIsMTAwNjg4ODE0NSwxMjU4NjA3Njg3LDM1MjQxMDE2MjksMjc2ODk0MjQ0Myw5MDEwOTc3MjIsMTExOTAwMDY4NCwzNjg2NTE3MjA2LDI4OTgwNjU3MjgsODUzMDQ0NDUxLDExNzIyNjYxMDEsMzcwNTAxNTc1OSxcbjI4ODI2MTY2NjUsNjUxNzY3OTgwLDEzNzM1MDM1NDYsMzM2OTU1NDMwNCwzMjE4MTA0NTk4LDU2NTUwNzI1MywxNDU0NjIxNzMxLDM0ODUxMTE3MDUsMzA5OTQzNjMwMyw2NzEyNjY5NzQsMTU5NDE5ODAyNCwzMzIyNzMwOTMwLDI5NzAzNDc4MTIsNzk1ODM1NTI3LDE0ODMyMzAyMjUsMzI0NDM2NzI3NSwzMDYwMTQ5NTY1LDE5OTQxNDYxOTIsMzExNTg1MzQsMjU2MzkwNzc3Miw0MDIzNzE3OTMwLDE5MDc0NTk0NjUsMTEyNjM3MjE1LDI2ODAxNTMyNTMsMzkwNDQyNzA1OSwyMDEzNzc2MjkwLDI1MTcyMjAzNiwyNTE3MjE1Mzc0LDM3NzU4MzAwNDAsMjEzNzY1Njc2MywxNDEzNzY4MTMsMjQzOTI3NzcxOSwzODY1MjcxMjk3LDE4MDIxOTU0NDQsNDc2ODY0ODY2LDIyMzgwMDEzNjgsNDA2NjUwODg3OCwxODEyMzcwOTI1LDQ1MzA5MjczMSwyMTgxNjI1MDI1LDQxMTE0NTEyMjMsMTcwNjA4ODkwMiwzMTQwNDI3MDQsMjM0NDUzMjIwMiw0MjQwMDE3NTMyLDE2NTg2NTgyNzEsMzY2NjE5OTc3LFxuMjM2MjY3MDMyMyw0MjI0OTk0NDA1LDEzMDM1MzU5NjAsOTg0OTYxNDg2LDI3NDcwMDcwOTIsMzU2OTAzNzUzOCwxMjU2MTcwODE3LDEwMzc2MDQzMTEsMjc2NTIxMDczMywzNTU0MDc5OTk1LDExMzEwMTQ1MDYsODc5Njc5OTk2LDI5MDkyNDM0NjIsMzY2Mzc3MTg1NiwxMTQxMTI0NDY3LDg1NTg0MjI3NywyODUyODAxNjMxLDM3MDg2NDg2NDksMTM0MjUzMzk0OCw2NTQ0NTkzMDYsMzE4ODM5NjA0OCwzMzczMDE1MTc0LDE0NjY0Nzk5MDksNTQ0MTc5NjM1LDMxMTA1MjM5MTMsMzQ2MjUyMjAxNSwxNTkxNjcxMDU0LDcwMjEzODc3NiwyOTY2NDYwNDUwLDMzNTI3OTk0MTIsMTUwNDkxODgwNyw3ODM1NTE4NzMsMzA4MjY0MDQ0MywzMjMzNDQyOTg5LDM5ODgyOTIzODQsMjU5NjI1NDY0Niw2MjMxNzA2OCwxOTU3ODEwODQyLDM5Mzk4NDU5NDUsMjY0NzgxNjExMSw4MTQ3MDk5NywxOTQzODAzNTIzLDM4MTQ5MTg5MzAsMjQ4OTU5NjgwNCwyMjUyNzQ0MzAsMjA1Mzc5MDM3NiwzODI2MTc1NzU1LFxuMjQ2NjkwNjAxMywxNjc4MTY3NDMsMjA5NzY1MTM3Nyw0MDI3NTUyNTgwLDIyNjU0OTAzODYsNTAzNDQ0MDcyLDE3NjIwNTA4MTQsNDE1MDQxNzI0NSwyMTU0MTI5MzU1LDQyNjUyMjIyNSwxODUyNTA3ODc5LDQyNzUzMTM1MjYsMjMxMjMxNzkyMCwyODI3NTM2MjYsMTc0MjU1NTg1Miw0MTg5NzA4MTQzLDIzOTQ4Nzc5NDUsMzk3OTE3NzYzLDE2MjIxODM2MzcsMzYwNDM5MDg4OCwyNzE0ODY2NTU4LDk1MzcyOTczMiwxMzQwMDc2NjI2LDM1MTg3MTk5ODUsMjc5NzM2MDk5OSwxMDY4ODI4MzgxLDEyMTk2Mzg4NTksMzYyNDc0MTg1MCwyOTM2Njc1MTQ4LDkwNjE4NTQ2MiwxMDkwODEyNTEyLDM3NDc2NzIwMDMsMjgyNTM3OTY2OSw4MjkzMjkxMzUsMTE4MTMzNTE2MSwzNDEyMTc3ODA0LDMxNjA4MzQ4NDIsNjI4MDg1NDA4LDEzODI2MDUzNjYsMzQyMzM2OTEwOSwzMTM4MDc4NDY3LDU3MDU2MjIzMywxNDI2NDAwODE1LDMzMTczMTY1NDIsMjk5ODczMzYwOCw3MzMyMzk5NTQsMTU1NTI2MTk1NixcbjMyNjg5MzU1OTEsMzA1MDM2MDYyNSw3NTI0NTk0MDMsMTU0MTMyMDIyMSwyNjA3MDcxOTIwLDM5NjU5NzMwMzAsMTk2OTkyMjk3Miw0MDczNTQ5OCwyNjE3ODM3MjI1LDM5NDM1NzcxNTEsMTkxMzA4Nzg3Nyw4MzkwODM3MSwyNTEyMzQxNjM0LDM4MDM3NDA2OTIsMjA3NTIwODYyMiwyMTMyNjExMTIsMjQ2MzI3MjYwMywzODU1OTkwMjg1LDIwOTQ4NTQwNzEsMTk4OTU4ODgxLDIyNjIwMjkwMTIsNDA1NzI2MDYxMCwxNzU5MzU5OTkyLDUzNDQxNDE5MCwyMTc2NzE4NTQxLDQxMzkzMjkxMTUsMTg3MzgzNjAwMSw0MTQ2NjQ1NjcsMjI4MjI0ODkzNCw0Mjc5MjAwMzY4LDE3MTE2ODQ1NTQsMjg1MjgxMTE2LDI0MDU4MDE3MjcsNDE2NzIxNjc0NSwxNjM0NDY3Nzk1LDM3NjIyOTcwMSwyNjg1MDY3ODk2LDM2MDgwMDc0MDYsMTMwODkxODYxMiw5NTY1NDM5MzgsMjgwODU1NTEwNSwzNDk1OTU4MjYzLDEyMzE2MzYzMDEsMTA0NzQyNzAzNSwyOTMyOTU5ODE4LDM2NTQ3MDM4MzYsMTA4ODM1OTI3MCxcbjkzNjkxOEUzLDI4NDc3MTQ4OTksMzczNjgzNzgyOSwxMjAyOTAwODYzLDgxNzIzMzg5NywzMTgzMzQyMTA4LDM0MDEyMzcxMzAsMTQwNDI3NzU1Miw2MTU4MTgxNTAsMzEzNDIwNzQ5MywzNDUzNDIxMjAzLDE0MjM4NTc0NDksNjAxNDUwNDMxLDMwMDk4Mzc2MTQsMzI5NDcxMDQ1NiwxNTY3MTAzNzQ2LDcxMTkyODcyNCwzMDIwNjY4NDcxLDMyNzIzODAwNjUsMTUxMDMzNDIzNSw3NTUxNjcxMTddLE89Qj9uZXcgVWludDMyQXJyYXkoa2EpOmthO2Z1bmN0aW9uIFAoKXt9UC5wcm90b3R5cGUuZ2V0TmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5hbWV9O1AucHJvdG90eXBlLmdldERhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfTtQLnByb3RvdHlwZS5YPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuWX07QShcIlpsaWIuR3VuemlwTWVtYmVyXCIsUCk7QShcIlpsaWIuR3VuemlwTWVtYmVyLnByb3RvdHlwZS5nZXROYW1lXCIsUC5wcm90b3R5cGUuZ2V0TmFtZSk7QShcIlpsaWIuR3VuemlwTWVtYmVyLnByb3RvdHlwZS5nZXREYXRhXCIsUC5wcm90b3R5cGUuZ2V0RGF0YSk7QShcIlpsaWIuR3VuemlwTWVtYmVyLnByb3RvdHlwZS5nZXRNdGltZVwiLFAucHJvdG90eXBlLlgpO2Z1bmN0aW9uIGxhKGIpe3RoaXMuYnVmZmVyPW5ldyAoQj9VaW50MTZBcnJheTpBcnJheSkoMipiKTt0aGlzLmxlbmd0aD0wfWxhLnByb3RvdHlwZS5nZXRQYXJlbnQ9ZnVuY3Rpb24oYil7cmV0dXJuIDIqKChiLTIpLzR8MCl9O2xhLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGIsYSl7dmFyIGMsZCxmPXRoaXMuYnVmZmVyLGU7Yz10aGlzLmxlbmd0aDtmW3RoaXMubGVuZ3RoKytdPWE7Zm9yKGZbdGhpcy5sZW5ndGgrK109YjswPGM7KWlmKGQ9dGhpcy5nZXRQYXJlbnQoYyksZltjXT5mW2RdKWU9ZltjXSxmW2NdPWZbZF0sZltkXT1lLGU9ZltjKzFdLGZbYysxXT1mW2QrMV0sZltkKzFdPWUsYz1kO2Vsc2UgYnJlYWs7cmV0dXJuIHRoaXMubGVuZ3RofTtcbmxhLnByb3RvdHlwZS5wb3A9ZnVuY3Rpb24oKXt2YXIgYixhLGM9dGhpcy5idWZmZXIsZCxmLGU7YT1jWzBdO2I9Y1sxXTt0aGlzLmxlbmd0aC09MjtjWzBdPWNbdGhpcy5sZW5ndGhdO2NbMV09Y1t0aGlzLmxlbmd0aCsxXTtmb3IoZT0wOzspe2Y9MiplKzI7aWYoZj49dGhpcy5sZW5ndGgpYnJlYWs7ZisyPHRoaXMubGVuZ3RoJiZjW2YrMl0+Y1tmXSYmKGYrPTIpO2lmKGNbZl0+Y1tlXSlkPWNbZV0sY1tlXT1jW2ZdLGNbZl09ZCxkPWNbZSsxXSxjW2UrMV09Y1tmKzFdLGNbZisxXT1kO2Vsc2UgYnJlYWs7ZT1mfXJldHVybntpbmRleDpiLHZhbHVlOmEsbGVuZ3RoOnRoaXMubGVuZ3RofX07ZnVuY3Rpb24gbWEoYil7dmFyIGE9Yi5sZW5ndGgsYz0wLGQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLGYsZSxnLGssaCxsLHMsbixtO2ZvcihuPTA7bjxhOysrbiliW25dPmMmJihjPWJbbl0pLGJbbl08ZCYmKGQ9YltuXSk7Zj0xPDxjO2U9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KShmKTtnPTE7az0wO2ZvcihoPTI7Zzw9Yzspe2ZvcihuPTA7bjxhOysrbilpZihiW25dPT09Zyl7bD0wO3M9aztmb3IobT0wO208ZzsrK20pbD1sPDwxfHMmMSxzPj49MTtmb3IobT1sO208ZjttKz1oKWVbbV09Zzw8MTZ8bjsrK2t9KytnO2s8PD0xO2g8PD0xfXJldHVybltlLGMsZF19O2Z1bmN0aW9uIG5hKGIsYSl7dGhpcy5rPXFhO3RoaXMuST0wO3RoaXMuaW5wdXQ9QiYmYiBpbnN0YW5jZW9mIEFycmF5P25ldyBVaW50OEFycmF5KGIpOmI7dGhpcy5iPTA7YSYmKGEubGF6eSYmKHRoaXMuST1hLmxhenkpLFwibnVtYmVyXCI9PT10eXBlb2YgYS5jb21wcmVzc2lvblR5cGUmJih0aGlzLms9YS5jb21wcmVzc2lvblR5cGUpLGEub3V0cHV0QnVmZmVyJiYodGhpcy5hPUImJmEub3V0cHV0QnVmZmVyIGluc3RhbmNlb2YgQXJyYXk/bmV3IFVpbnQ4QXJyYXkoYS5vdXRwdXRCdWZmZXIpOmEub3V0cHV0QnVmZmVyKSxcIm51bWJlclwiPT09dHlwZW9mIGEub3V0cHV0SW5kZXgmJih0aGlzLmI9YS5vdXRwdXRJbmRleCkpO3RoaXMuYXx8KHRoaXMuYT1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMzI3NjgpKX12YXIgcWE9MixyYT17Tk9ORTowLHY6MSxvOnFhLGFhOjN9LHNhPVtdLFM7XG5mb3IoUz0wOzI4OD5TO1MrKylzd2l0Y2godSl7Y2FzZSAxNDM+PVM6c2EucHVzaChbUys0OCw4XSk7YnJlYWs7Y2FzZSAyNTU+PVM6c2EucHVzaChbUy0xNDQrNDAwLDldKTticmVhaztjYXNlIDI3OT49UzpzYS5wdXNoKFtTLTI1NiswLDddKTticmVhaztjYXNlIDI4Nz49UzpzYS5wdXNoKFtTLTI4MCsxOTIsOF0pO2JyZWFrO2RlZmF1bHQ6cShcImludmFsaWQgbGl0ZXJhbDogXCIrUyl9XG5uYS5wcm90b3R5cGUuZz1mdW5jdGlvbigpe3ZhciBiLGEsYyxkLGY9dGhpcy5pbnB1dDtzd2l0Y2godGhpcy5rKXtjYXNlIDA6Yz0wO2ZvcihkPWYubGVuZ3RoO2M8ZDspe2E9Qj9mLnN1YmFycmF5KGMsYys2NTUzNSk6Zi5zbGljZShjLGMrNjU1MzUpO2MrPWEubGVuZ3RoO3ZhciBlPWEsZz1jPT09ZCxrPXQsaD10LGw9dCxzPXQsbj10LG09dGhpcy5hLHA9dGhpcy5iO2lmKEIpe2ZvcihtPW5ldyBVaW50OEFycmF5KHRoaXMuYS5idWZmZXIpO20ubGVuZ3RoPD1wK2UubGVuZ3RoKzU7KW09bmV3IFVpbnQ4QXJyYXkobS5sZW5ndGg8PDEpO20uc2V0KHRoaXMuYSl9az1nPzE6MDttW3ArK109a3wwO2g9ZS5sZW5ndGg7bD1+aCs2NTUzNiY2NTUzNTttW3ArK109aCYyNTU7bVtwKytdPWg+Pj44JjI1NTttW3ArK109bCYyNTU7bVtwKytdPWw+Pj44JjI1NTtpZihCKW0uc2V0KGUscCkscCs9ZS5sZW5ndGgsbT1tLnN1YmFycmF5KDAscCk7ZWxzZXtzPTA7Zm9yKG49ZS5sZW5ndGg7czxuOysrcyltW3ArK109XG5lW3NdO20ubGVuZ3RoPXB9dGhpcy5iPXA7dGhpcy5hPW19YnJlYWs7Y2FzZSAxOnZhciByPW5ldyBGKEI/bmV3IFVpbnQ4QXJyYXkodGhpcy5hLmJ1ZmZlcik6dGhpcy5hLHRoaXMuYik7ci5kKDEsMSx1KTtyLmQoMSwyLHUpO3ZhciB2PXRhKHRoaXMsZikseCxRLHk7eD0wO2ZvcihRPXYubGVuZ3RoO3g8UTt4KyspaWYoeT12W3hdLEYucHJvdG90eXBlLmQuYXBwbHkocixzYVt5XSksMjU2PHkpci5kKHZbKyt4XSx2WysreF0sdSksci5kKHZbKyt4XSw1KSxyLmQodlsrK3hdLHZbKyt4XSx1KTtlbHNlIGlmKDI1Nj09PXkpYnJlYWs7dGhpcy5hPXIuZmluaXNoKCk7dGhpcy5iPXRoaXMuYS5sZW5ndGg7YnJlYWs7Y2FzZSBxYTp2YXIgRT1uZXcgRihCP25ldyBVaW50OEFycmF5KHRoaXMuYS5idWZmZXIpOnRoaXMuYSx0aGlzLmIpLEphLFIsWCxZLFoscGI9WzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdLGZhLEthLGdhLExhLG9hLHdhPUFycmF5KDE5KSxcbk1hLCQscGEsQyxOYTtKYT1xYTtFLmQoMSwxLHUpO0UuZChKYSwyLHUpO1I9dGEodGhpcyxmKTtmYT11YSh0aGlzLlYsMTUpO0thPXZhKGZhKTtnYT11YSh0aGlzLlUsNyk7TGE9dmEoZ2EpO2ZvcihYPTI4NjsyNTc8WCYmMD09PWZhW1gtMV07WC0tKTtmb3IoWT0zMDsxPFkmJjA9PT1nYVtZLTFdO1ktLSk7dmFyIE9hPVgsUGE9WSxKPW5ldyAoQj9VaW50MzJBcnJheTpBcnJheSkoT2ErUGEpLHcsTCx6LGhhLEk9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KSgzMTYpLEcsRCxNPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KSgxOSk7Zm9yKHc9TD0wO3c8T2E7dysrKUpbTCsrXT1mYVt3XTtmb3Iodz0wO3c8UGE7dysrKUpbTCsrXT1nYVt3XTtpZighQil7dz0wO2ZvcihoYT1NLmxlbmd0aDt3PGhhOysrdylNW3ddPTB9dz1HPTA7Zm9yKGhhPUoubGVuZ3RoO3c8aGE7dys9TCl7Zm9yKEw9MTt3K0w8aGEmJkpbdytMXT09PUpbd107KytMKTt6PUw7aWYoMD09PUpbd10paWYoMz56KWZvcig7MDxcbnotLTspSVtHKytdPTAsTVswXSsrO2Vsc2UgZm9yKDswPHo7KUQ9MTM4Pno/ejoxMzgsRD56LTMmJkQ8eiYmKEQ9ei0zKSwxMD49RD8oSVtHKytdPTE3LElbRysrXT1ELTMsTVsxN10rKyk6KElbRysrXT0xOCxJW0crK109RC0xMSxNWzE4XSsrKSx6LT1EO2Vsc2UgaWYoSVtHKytdPUpbd10sTVtKW3ddXSsrLHotLSwzPnopZm9yKDswPHotLTspSVtHKytdPUpbd10sTVtKW3ddXSsrO2Vsc2UgZm9yKDswPHo7KUQ9Nj56P3o6NixEPnotMyYmRDx6JiYoRD16LTMpLElbRysrXT0xNixJW0crK109RC0zLE1bMTZdKyssei09RH1iPUI/SS5zdWJhcnJheSgwLEcpOkkuc2xpY2UoMCxHKTtvYT11YShNLDcpO2ZvcihDPTA7MTk+QztDKyspd2FbQ109b2FbcGJbQ11dO2ZvcihaPTE5OzQ8WiYmMD09PXdhW1otMV07Wi0tKTtNYT12YShvYSk7RS5kKFgtMjU3LDUsdSk7RS5kKFktMSw1LHUpO0UuZChaLTQsNCx1KTtmb3IoQz0wO0M8WjtDKyspRS5kKHdhW0NdLDMsdSk7Qz0wO2ZvcihOYT1iLmxlbmd0aDtDPFxuTmE7QysrKWlmKCQ9YltDXSxFLmQoTWFbJF0sb2FbJF0sdSksMTY8PSQpe0MrKztzd2l0Y2goJCl7Y2FzZSAxNjpwYT0yO2JyZWFrO2Nhc2UgMTc6cGE9MzticmVhaztjYXNlIDE4OnBhPTc7YnJlYWs7ZGVmYXVsdDpxKFwiaW52YWxpZCBjb2RlOiBcIiskKX1FLmQoYltDXSxwYSx1KX12YXIgUWE9W0thLGZhXSxSYT1bTGEsZ2FdLE4sU2EsaWEsemEsVGEsVWEsVmEsV2E7VGE9UWFbMF07VWE9UWFbMV07VmE9UmFbMF07V2E9UmFbMV07Tj0wO2ZvcihTYT1SLmxlbmd0aDtOPFNhOysrTilpZihpYT1SW05dLEUuZChUYVtpYV0sVWFbaWFdLHUpLDI1NjxpYSlFLmQoUlsrK05dLFJbKytOXSx1KSx6YT1SWysrTl0sRS5kKFZhW3phXSxXYVt6YV0sdSksRS5kKFJbKytOXSxSWysrTl0sdSk7ZWxzZSBpZigyNTY9PT1pYSlicmVhazt0aGlzLmE9RS5maW5pc2goKTt0aGlzLmI9dGhpcy5hLmxlbmd0aDticmVhaztkZWZhdWx0OnEoXCJpbnZhbGlkIGNvbXByZXNzaW9uIHR5cGVcIil9cmV0dXJuIHRoaXMuYX07XG5mdW5jdGlvbiB4YShiLGEpe3RoaXMubGVuZ3RoPWI7dGhpcy5QPWF9XG52YXIgeWE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEpe3N3aXRjaCh1KXtjYXNlIDM9PT1hOnJldHVyblsyNTcsYS0zLDBdO2Nhc2UgND09PWE6cmV0dXJuWzI1OCxhLTQsMF07Y2FzZSA1PT09YTpyZXR1cm5bMjU5LGEtNSwwXTtjYXNlIDY9PT1hOnJldHVyblsyNjAsYS02LDBdO2Nhc2UgNz09PWE6cmV0dXJuWzI2MSxhLTcsMF07Y2FzZSA4PT09YTpyZXR1cm5bMjYyLGEtOCwwXTtjYXNlIDk9PT1hOnJldHVyblsyNjMsYS05LDBdO2Nhc2UgMTA9PT1hOnJldHVyblsyNjQsYS0xMCwwXTtjYXNlIDEyPj1hOnJldHVyblsyNjUsYS0xMSwxXTtjYXNlIDE0Pj1hOnJldHVyblsyNjYsYS0xMywxXTtjYXNlIDE2Pj1hOnJldHVyblsyNjcsYS0xNSwxXTtjYXNlIDE4Pj1hOnJldHVyblsyNjgsYS0xNywxXTtjYXNlIDIyPj1hOnJldHVyblsyNjksYS0xOSwyXTtjYXNlIDI2Pj1hOnJldHVyblsyNzAsYS0yMywyXTtjYXNlIDMwPj1hOnJldHVyblsyNzEsYS0yNywyXTtjYXNlIDM0Pj1hOnJldHVyblsyNzIsXG5hLTMxLDJdO2Nhc2UgNDI+PWE6cmV0dXJuWzI3MyxhLTM1LDNdO2Nhc2UgNTA+PWE6cmV0dXJuWzI3NCxhLTQzLDNdO2Nhc2UgNTg+PWE6cmV0dXJuWzI3NSxhLTUxLDNdO2Nhc2UgNjY+PWE6cmV0dXJuWzI3NixhLTU5LDNdO2Nhc2UgODI+PWE6cmV0dXJuWzI3NyxhLTY3LDRdO2Nhc2UgOTg+PWE6cmV0dXJuWzI3OCxhLTgzLDRdO2Nhc2UgMTE0Pj1hOnJldHVyblsyNzksYS05OSw0XTtjYXNlIDEzMD49YTpyZXR1cm5bMjgwLGEtMTE1LDRdO2Nhc2UgMTYyPj1hOnJldHVyblsyODEsYS0xMzEsNV07Y2FzZSAxOTQ+PWE6cmV0dXJuWzI4MixhLTE2Myw1XTtjYXNlIDIyNj49YTpyZXR1cm5bMjgzLGEtMTk1LDVdO2Nhc2UgMjU3Pj1hOnJldHVyblsyODQsYS0yMjcsNV07Y2FzZSAyNTg9PT1hOnJldHVyblsyODUsYS0yNTgsMF07ZGVmYXVsdDpxKFwiaW52YWxpZCBsZW5ndGg6IFwiK2EpfX12YXIgYT1bXSxjLGQ7Zm9yKGM9MzsyNTg+PWM7YysrKWQ9YihjKSxhW2NdPWRbMl08PDI0fGRbMV08PFxuMTZ8ZFswXTtyZXR1cm4gYX0oKSxBYT1CP25ldyBVaW50MzJBcnJheSh5YSk6eWE7XG5mdW5jdGlvbiB0YShiLGEpe2Z1bmN0aW9uIGMoYSxjKXt2YXIgYj1hLlAsZD1bXSxlPTAsZjtmPUFhW2EubGVuZ3RoXTtkW2UrK109ZiY2NTUzNTtkW2UrK109Zj4+MTYmMjU1O2RbZSsrXT1mPj4yNDt2YXIgZztzd2l0Y2godSl7Y2FzZSAxPT09YjpnPVswLGItMSwwXTticmVhaztjYXNlIDI9PT1iOmc9WzEsYi0yLDBdO2JyZWFrO2Nhc2UgMz09PWI6Zz1bMixiLTMsMF07YnJlYWs7Y2FzZSA0PT09YjpnPVszLGItNCwwXTticmVhaztjYXNlIDY+PWI6Zz1bNCxiLTUsMV07YnJlYWs7Y2FzZSA4Pj1iOmc9WzUsYi03LDFdO2JyZWFrO2Nhc2UgMTI+PWI6Zz1bNixiLTksMl07YnJlYWs7Y2FzZSAxNj49YjpnPVs3LGItMTMsMl07YnJlYWs7Y2FzZSAyND49YjpnPVs4LGItMTcsM107YnJlYWs7Y2FzZSAzMj49YjpnPVs5LGItMjUsM107YnJlYWs7Y2FzZSA0OD49YjpnPVsxMCxiLTMzLDRdO2JyZWFrO2Nhc2UgNjQ+PWI6Zz1bMTEsYi00OSw0XTticmVhaztjYXNlIDk2Pj1iOmc9WzEyLGItXG42NSw1XTticmVhaztjYXNlIDEyOD49YjpnPVsxMyxiLTk3LDVdO2JyZWFrO2Nhc2UgMTkyPj1iOmc9WzE0LGItMTI5LDZdO2JyZWFrO2Nhc2UgMjU2Pj1iOmc9WzE1LGItMTkzLDZdO2JyZWFrO2Nhc2UgMzg0Pj1iOmc9WzE2LGItMjU3LDddO2JyZWFrO2Nhc2UgNTEyPj1iOmc9WzE3LGItMzg1LDddO2JyZWFrO2Nhc2UgNzY4Pj1iOmc9WzE4LGItNTEzLDhdO2JyZWFrO2Nhc2UgMTAyND49YjpnPVsxOSxiLTc2OSw4XTticmVhaztjYXNlIDE1MzY+PWI6Zz1bMjAsYi0xMDI1LDldO2JyZWFrO2Nhc2UgMjA0OD49YjpnPVsyMSxiLTE1MzcsOV07YnJlYWs7Y2FzZSAzMDcyPj1iOmc9WzIyLGItMjA0OSwxMF07YnJlYWs7Y2FzZSA0MDk2Pj1iOmc9WzIzLGItMzA3MywxMF07YnJlYWs7Y2FzZSA2MTQ0Pj1iOmc9WzI0LGItNDA5NywxMV07YnJlYWs7Y2FzZSA4MTkyPj1iOmc9WzI1LGItNjE0NSwxMV07YnJlYWs7Y2FzZSAxMjI4OD49YjpnPVsyNixiLTgxOTMsMTJdO2JyZWFrO2Nhc2UgMTYzODQ+PVxuYjpnPVsyNyxiLTEyMjg5LDEyXTticmVhaztjYXNlIDI0NTc2Pj1iOmc9WzI4LGItMTYzODUsMTNdO2JyZWFrO2Nhc2UgMzI3Njg+PWI6Zz1bMjksYi0yNDU3NywxM107YnJlYWs7ZGVmYXVsdDpxKFwiaW52YWxpZCBkaXN0YW5jZVwiKX1mPWc7ZFtlKytdPWZbMF07ZFtlKytdPWZbMV07ZFtlKytdPWZbMl07dmFyIGgsaztoPTA7Zm9yKGs9ZC5sZW5ndGg7aDxrOysraCltW3ArK109ZFtoXTt2W2RbMF1dKys7eFtkWzNdXSsrO3I9YS5sZW5ndGgrYy0xO249bnVsbH12YXIgZCxmLGUsZyxrLGg9e30sbCxzLG4sbT1CP25ldyBVaW50MTZBcnJheSgyKmEubGVuZ3RoKTpbXSxwPTAscj0wLHY9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KSgyODYpLHg9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KSgzMCksUT1iLkkseTtpZighQil7Zm9yKGU9MDsyODU+PWU7KXZbZSsrXT0wO2ZvcihlPTA7Mjk+PWU7KXhbZSsrXT0wfXZbMjU2XT0xO2Q9MDtmb3IoZj1hLmxlbmd0aDtkPGY7KytkKXtlPWs9MDtcbmZvcihnPTM7ZTxnJiZkK2UhPT1mOysrZSlrPWs8PDh8YVtkK2VdO2hba109PT10JiYoaFtrXT1bXSk7bD1oW2tdO2lmKCEoMDxyLS0pKXtmb3IoOzA8bC5sZW5ndGgmJjMyNzY4PGQtbFswXTspbC5zaGlmdCgpO2lmKGQrMz49Zil7biYmYyhuLC0xKTtlPTA7Zm9yKGc9Zi1kO2U8ZzsrK2UpeT1hW2QrZV0sbVtwKytdPXksKyt2W3ldO2JyZWFrfTA8bC5sZW5ndGg/KHM9QmEoYSxkLGwpLG4/bi5sZW5ndGg8cy5sZW5ndGg/KHk9YVtkLTFdLG1bcCsrXT15LCsrdlt5XSxjKHMsMCkpOmMobiwtMSk6cy5sZW5ndGg8UT9uPXM6YyhzLDApKTpuP2MobiwtMSk6KHk9YVtkXSxtW3ArK109eSwrK3ZbeV0pfWwucHVzaChkKX1tW3ArK109MjU2O3ZbMjU2XSsrO2IuVj12O2IuVT14O3JldHVybiBCP20uc3ViYXJyYXkoMCxwKTptfVxuZnVuY3Rpb24gQmEoYixhLGMpe3ZhciBkLGYsZT0wLGcsayxoLGwscz1iLmxlbmd0aDtrPTA7bD1jLmxlbmd0aDthOmZvcig7azxsO2srKyl7ZD1jW2wtay0xXTtnPTM7aWYoMzxlKXtmb3IoaD1lOzM8aDtoLS0paWYoYltkK2gtMV0hPT1iW2EraC0xXSljb250aW51ZSBhO2c9ZX1mb3IoOzI1OD5nJiZhK2c8cyYmYltkK2ddPT09YlthK2ddOykrK2c7Zz5lJiYoZj1kLGU9Zyk7aWYoMjU4PT09ZylicmVha31yZXR1cm4gbmV3IHhhKGUsYS1mKX1cbmZ1bmN0aW9uIHVhKGIsYSl7dmFyIGM9Yi5sZW5ndGgsZD1uZXcgbGEoNTcyKSxmPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KShjKSxlLGcsayxoLGw7aWYoIUIpZm9yKGg9MDtoPGM7aCsrKWZbaF09MDtmb3IoaD0wO2g8YzsrK2gpMDxiW2hdJiZkLnB1c2goaCxiW2hdKTtlPUFycmF5KGQubGVuZ3RoLzIpO2c9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KShkLmxlbmd0aC8yKTtpZigxPT09ZS5sZW5ndGgpcmV0dXJuIGZbZC5wb3AoKS5pbmRleF09MSxmO2g9MDtmb3IobD1kLmxlbmd0aC8yO2g8bDsrK2gpZVtoXT1kLnBvcCgpLGdbaF09ZVtoXS52YWx1ZTtrPUNhKGcsZy5sZW5ndGgsYSk7aD0wO2ZvcihsPWUubGVuZ3RoO2g8bDsrK2gpZltlW2hdLmluZGV4XT1rW2hdO3JldHVybiBmfVxuZnVuY3Rpb24gQ2EoYixhLGMpe2Z1bmN0aW9uIGQoYil7dmFyIGM9aFtiXVtsW2JdXTtjPT09YT8oZChiKzEpLGQoYisxKSk6LS1nW2NdOysrbFtiXX12YXIgZj1uZXcgKEI/VWludDE2QXJyYXk6QXJyYXkpKGMpLGU9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKGMpLGc9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKGEpLGs9QXJyYXkoYyksaD1BcnJheShjKSxsPUFycmF5KGMpLHM9KDE8PGMpLWEsbj0xPDxjLTEsbSxwLHIsdix4O2ZbYy0xXT1hO2ZvcihwPTA7cDxjOysrcClzPG4/ZVtwXT0wOihlW3BdPTEscy09biksczw8PTEsZltjLTItcF09KGZbYy0xLXBdLzJ8MCkrYTtmWzBdPWVbMF07a1swXT1BcnJheShmWzBdKTtoWzBdPUFycmF5KGZbMF0pO2ZvcihwPTE7cDxjOysrcClmW3BdPjIqZltwLTFdK2VbcF0mJihmW3BdPTIqZltwLTFdK2VbcF0pLGtbcF09QXJyYXkoZltwXSksaFtwXT1BcnJheShmW3BdKTtmb3IobT0wO208YTsrK20pZ1ttXT1jO2ZvcihyPTA7cjxmW2MtMV07KytyKWtbYy1cbjFdW3JdPWJbcl0saFtjLTFdW3JdPXI7Zm9yKG09MDttPGM7KyttKWxbbV09MDsxPT09ZVtjLTFdJiYoLS1nWzBdLCsrbFtjLTFdKTtmb3IocD1jLTI7MDw9cDstLXApe3Y9bT0wO3g9bFtwKzFdO2ZvcihyPTA7cjxmW3BdO3IrKyl2PWtbcCsxXVt4XStrW3ArMV1beCsxXSx2PmJbbV0/KGtbcF1bcl09dixoW3BdW3JdPWEseCs9Mik6KGtbcF1bcl09YlttXSxoW3BdW3JdPW0sKyttKTtsW3BdPTA7MT09PWVbcF0mJmQocCl9cmV0dXJuIGd9XG5mdW5jdGlvbiB2YShiKXt2YXIgYT1uZXcgKEI/VWludDE2QXJyYXk6QXJyYXkpKGIubGVuZ3RoKSxjPVtdLGQ9W10sZj0wLGUsZyxrLGg7ZT0wO2ZvcihnPWIubGVuZ3RoO2U8ZztlKyspY1tiW2VdXT0oY1tiW2VdXXwwKSsxO2U9MTtmb3IoZz0xNjtlPD1nO2UrKylkW2VdPWYsZis9Y1tlXXwwLGY8PD0xO2U9MDtmb3IoZz1iLmxlbmd0aDtlPGc7ZSsrKXtmPWRbYltlXV07ZFtiW2VdXSs9MTtrPWFbZV09MDtmb3IoaD1iW2VdO2s8aDtrKyspYVtlXT1hW2VdPDwxfGYmMSxmPj4+PTF9cmV0dXJuIGF9O2Z1bmN0aW9uIERhKGIsYSl7dGhpcy5pbnB1dD1iO3RoaXMuYj10aGlzLmM9MDt0aGlzLmk9e307YSYmKGEuZmxhZ3MmJih0aGlzLmk9YS5mbGFncyksXCJzdHJpbmdcIj09PXR5cGVvZiBhLmZpbGVuYW1lJiYodGhpcy5maWxlbmFtZT1hLmZpbGVuYW1lKSxcInN0cmluZ1wiPT09dHlwZW9mIGEuY29tbWVudCYmKHRoaXMuQT1hLmNvbW1lbnQpLGEuZGVmbGF0ZU9wdGlvbnMmJih0aGlzLmw9YS5kZWZsYXRlT3B0aW9ucykpO3RoaXMubHx8KHRoaXMubD17fSl9XG5EYS5wcm90b3R5cGUuZz1mdW5jdGlvbigpe3ZhciBiLGEsYyxkLGYsZSxnLGssaD1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMzI3NjgpLGw9MCxzPXRoaXMuaW5wdXQsbj10aGlzLmMsbT10aGlzLmZpbGVuYW1lLHA9dGhpcy5BO2hbbCsrXT0zMTtoW2wrK109MTM5O2hbbCsrXT04O2I9MDt0aGlzLmkuZm5hbWUmJihifD1FYSk7dGhpcy5pLmZjb21tZW50JiYoYnw9RmEpO3RoaXMuaS5maGNyYyYmKGJ8PUdhKTtoW2wrK109YjthPShEYXRlLm5vdz9EYXRlLm5vdygpOituZXcgRGF0ZSkvMUUzfDA7aFtsKytdPWEmMjU1O2hbbCsrXT1hPj4+OCYyNTU7aFtsKytdPWE+Pj4xNiYyNTU7aFtsKytdPWE+Pj4yNCYyNTU7aFtsKytdPTA7aFtsKytdPUhhO2lmKHRoaXMuaS5mbmFtZSE9PXQpe2c9MDtmb3Ioaz1tLmxlbmd0aDtnPGs7KytnKWU9bS5jaGFyQ29kZUF0KGcpLDI1NTxlJiYoaFtsKytdPWU+Pj44JjI1NSksaFtsKytdPWUmMjU1O2hbbCsrXT0wfWlmKHRoaXMuaS5jb21tZW50KXtnPVxuMDtmb3Ioaz1wLmxlbmd0aDtnPGs7KytnKWU9cC5jaGFyQ29kZUF0KGcpLDI1NTxlJiYoaFtsKytdPWU+Pj44JjI1NSksaFtsKytdPWUmMjU1O2hbbCsrXT0wfXRoaXMuaS5maGNyYyYmKGM9amEoaCwwLGwpJjY1NTM1LGhbbCsrXT1jJjI1NSxoW2wrK109Yz4+PjgmMjU1KTt0aGlzLmwub3V0cHV0QnVmZmVyPWg7dGhpcy5sLm91dHB1dEluZGV4PWw7Zj1uZXcgbmEocyx0aGlzLmwpO2g9Zi5nKCk7bD1mLmI7QiYmKGwrOD5oLmJ1ZmZlci5ieXRlTGVuZ3RoPyh0aGlzLmE9bmV3IFVpbnQ4QXJyYXkobCs4KSx0aGlzLmEuc2V0KG5ldyBVaW50OEFycmF5KGguYnVmZmVyKSksaD10aGlzLmEpOmg9bmV3IFVpbnQ4QXJyYXkoaC5idWZmZXIpKTtkPWphKHMsdCx0KTtoW2wrK109ZCYyNTU7aFtsKytdPWQ+Pj44JjI1NTtoW2wrK109ZD4+PjE2JjI1NTtoW2wrK109ZD4+PjI0JjI1NTtrPXMubGVuZ3RoO2hbbCsrXT1rJjI1NTtoW2wrK109az4+PjgmMjU1O2hbbCsrXT1rPj4+MTYmMjU1O2hbbCsrXT1cbms+Pj4yNCYyNTU7dGhpcy5jPW47QiYmbDxoLmxlbmd0aCYmKHRoaXMuYT1oPWguc3ViYXJyYXkoMCxsKSk7cmV0dXJuIGh9O3ZhciBIYT0yNTUsR2E9MixFYT04LEZhPTE2O0EoXCJabGliLkd6aXBcIixEYSk7QShcIlpsaWIuR3ppcC5wcm90b3R5cGUuY29tcHJlc3NcIixEYS5wcm90b3R5cGUuZyk7ZnVuY3Rpb24gVChiLGEpe3RoaXMucD1bXTt0aGlzLnE9MzI3Njg7dGhpcy5lPXRoaXMuaj10aGlzLmM9dGhpcy51PTA7dGhpcy5pbnB1dD1CP25ldyBVaW50OEFycmF5KGIpOmI7dGhpcy53PSExO3RoaXMucj1JYTt0aGlzLkw9ITE7aWYoYXx8IShhPXt9KSlhLmluZGV4JiYodGhpcy5jPWEuaW5kZXgpLGEuYnVmZmVyU2l6ZSYmKHRoaXMucT1hLmJ1ZmZlclNpemUpLGEuYnVmZmVyVHlwZSYmKHRoaXMucj1hLmJ1ZmZlclR5cGUpLGEucmVzaXplJiYodGhpcy5MPWEucmVzaXplKTtzd2l0Y2godGhpcy5yKXtjYXNlIFhhOnRoaXMuYj0zMjc2ODt0aGlzLmE9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKDMyNzY4K3RoaXMucSsyNTgpO2JyZWFrO2Nhc2UgSWE6dGhpcy5iPTA7dGhpcy5hPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KSh0aGlzLnEpO3RoaXMuZj10aGlzLlQ7dGhpcy5CPXRoaXMuUTt0aGlzLnM9dGhpcy5TO2JyZWFrO2RlZmF1bHQ6cShFcnJvcihcImludmFsaWQgaW5mbGF0ZSBtb2RlXCIpKX19XG52YXIgWGE9MCxJYT0xLFlhPXtOOlhhLE06SWF9O1xuVC5wcm90b3R5cGUuaD1mdW5jdGlvbigpe2Zvcig7IXRoaXMudzspe3ZhciBiPVUodGhpcywzKTtiJjEmJih0aGlzLnc9dSk7Yj4+Pj0xO3N3aXRjaChiKXtjYXNlIDA6dmFyIGE9dGhpcy5pbnB1dCxjPXRoaXMuYyxkPXRoaXMuYSxmPXRoaXMuYixlPXQsZz10LGs9dCxoPWQubGVuZ3RoLGw9dDt0aGlzLmU9dGhpcy5qPTA7ZT1hW2MrK107ZT09PXQmJnEoRXJyb3IoXCJpbnZhbGlkIHVuY29tcHJlc3NlZCBibG9jayBoZWFkZXI6IExFTiAoZmlyc3QgYnl0ZSlcIikpO2c9ZTtlPWFbYysrXTtlPT09dCYmcShFcnJvcihcImludmFsaWQgdW5jb21wcmVzc2VkIGJsb2NrIGhlYWRlcjogTEVOIChzZWNvbmQgYnl0ZSlcIikpO2d8PWU8PDg7ZT1hW2MrK107ZT09PXQmJnEoRXJyb3IoXCJpbnZhbGlkIHVuY29tcHJlc3NlZCBibG9jayBoZWFkZXI6IE5MRU4gKGZpcnN0IGJ5dGUpXCIpKTtrPWU7ZT1hW2MrK107ZT09PXQmJnEoRXJyb3IoXCJpbnZhbGlkIHVuY29tcHJlc3NlZCBibG9jayBoZWFkZXI6IE5MRU4gKHNlY29uZCBieXRlKVwiKSk7a3w9XG5lPDw4O2c9PT1+ayYmcShFcnJvcihcImludmFsaWQgdW5jb21wcmVzc2VkIGJsb2NrIGhlYWRlcjogbGVuZ3RoIHZlcmlmeVwiKSk7YytnPmEubGVuZ3RoJiZxKEVycm9yKFwiaW5wdXQgYnVmZmVyIGlzIGJyb2tlblwiKSk7c3dpdGNoKHRoaXMucil7Y2FzZSBYYTpmb3IoO2YrZz5kLmxlbmd0aDspe2w9aC1mO2ctPWw7aWYoQilkLnNldChhLnN1YmFycmF5KGMsYytsKSxmKSxmKz1sLGMrPWw7ZWxzZSBmb3IoO2wtLTspZFtmKytdPWFbYysrXTt0aGlzLmI9ZjtkPXRoaXMuZigpO2Y9dGhpcy5ifWJyZWFrO2Nhc2UgSWE6Zm9yKDtmK2c+ZC5sZW5ndGg7KWQ9dGhpcy5mKHtGOjJ9KTticmVhaztkZWZhdWx0OnEoRXJyb3IoXCJpbnZhbGlkIGluZmxhdGUgbW9kZVwiKSl9aWYoQilkLnNldChhLnN1YmFycmF5KGMsYytnKSxmKSxmKz1nLGMrPWc7ZWxzZSBmb3IoO2ctLTspZFtmKytdPWFbYysrXTt0aGlzLmM9Yzt0aGlzLmI9Zjt0aGlzLmE9ZDticmVhaztjYXNlIDE6dGhpcy5zKFphLCRhKTticmVhaztcbmNhc2UgMjphYih0aGlzKTticmVhaztkZWZhdWx0OnEoRXJyb3IoXCJ1bmtub3duIEJUWVBFOiBcIitiKSl9fXJldHVybiB0aGlzLkIoKX07XG52YXIgYmI9WzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdLGNiPUI/bmV3IFVpbnQxNkFycmF5KGJiKTpiYixkYj1bMyw0LDUsNiw3LDgsOSwxMCwxMSwxMywxNSwxNywxOSwyMywyNywzMSwzNSw0Myw1MSw1OSw2Nyw4Myw5OSwxMTUsMTMxLDE2MywxOTUsMjI3LDI1OCwyNTgsMjU4XSxlYj1CP25ldyBVaW50MTZBcnJheShkYik6ZGIsZmI9WzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMCwwLDBdLGdiPUI/bmV3IFVpbnQ4QXJyYXkoZmIpOmZiLGhiPVsxLDIsMyw0LDUsNyw5LDEzLDE3LDI1LDMzLDQ5LDY1LDk3LDEyOSwxOTMsMjU3LDM4NSw1MTMsNzY5LDEwMjUsMTUzNywyMDQ5LDMwNzMsNDA5Nyw2MTQ1LDgxOTMsMTIyODksMTYzODUsMjQ1NzddLGliPUI/bmV3IFVpbnQxNkFycmF5KGhiKTpoYixqYj1bMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCxcbjEwLDExLDExLDEyLDEyLDEzLDEzXSxrYj1CP25ldyBVaW50OEFycmF5KGpiKTpqYixsYj1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMjg4KSxWLG1iO1Y9MDtmb3IobWI9bGIubGVuZ3RoO1Y8bWI7KytWKWxiW1ZdPTE0Mz49Vj84OjI1NT49Vj85OjI3OT49Vj83Ojg7dmFyIFphPW1hKGxiKSxuYj1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMzApLG9iLHFiO29iPTA7Zm9yKHFiPW5iLmxlbmd0aDtvYjxxYjsrK29iKW5iW29iXT01O3ZhciAkYT1tYShuYik7ZnVuY3Rpb24gVShiLGEpe2Zvcih2YXIgYz1iLmosZD1iLmUsZj1iLmlucHV0LGU9Yi5jLGc7ZDxhOylnPWZbZSsrXSxnPT09dCYmcShFcnJvcihcImlucHV0IGJ1ZmZlciBpcyBicm9rZW5cIikpLGN8PWc8PGQsZCs9ODtnPWMmKDE8PGEpLTE7Yi5qPWM+Pj5hO2IuZT1kLWE7Yi5jPWU7cmV0dXJuIGd9XG5mdW5jdGlvbiByYihiLGEpe2Zvcih2YXIgYz1iLmosZD1iLmUsZj1iLmlucHV0LGU9Yi5jLGc9YVswXSxrPWFbMV0saCxsLHM7ZDxrOyl7aD1mW2UrK107aWYoaD09PXQpYnJlYWs7Y3w9aDw8ZDtkKz04fWw9Z1tjJigxPDxrKS0xXTtzPWw+Pj4xNjtiLmo9Yz4+cztiLmU9ZC1zO2IuYz1lO3JldHVybiBsJjY1NTM1fVxuZnVuY3Rpb24gYWIoYil7ZnVuY3Rpb24gYShhLGIsYyl7dmFyIGQsZSxmLGc7Zm9yKGc9MDtnPGE7KXN3aXRjaChkPXJiKHRoaXMsYiksZCl7Y2FzZSAxNjpmb3IoZj0zK1UodGhpcywyKTtmLS07KWNbZysrXT1lO2JyZWFrO2Nhc2UgMTc6Zm9yKGY9MytVKHRoaXMsMyk7Zi0tOyljW2crK109MDtlPTA7YnJlYWs7Y2FzZSAxODpmb3IoZj0xMStVKHRoaXMsNyk7Zi0tOyljW2crK109MDtlPTA7YnJlYWs7ZGVmYXVsdDplPWNbZysrXT1kfXJldHVybiBjfXZhciBjPVUoYiw1KSsyNTcsZD1VKGIsNSkrMSxmPVUoYiw0KSs0LGU9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKGNiLmxlbmd0aCksZyxrLGgsbDtmb3IobD0wO2w8ZjsrK2wpZVtjYltsXV09VShiLDMpO2c9bWEoZSk7az1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoYyk7aD1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoZCk7Yi5zKG1hKGEuY2FsbChiLGMsZyxrKSksbWEoYS5jYWxsKGIsZCxnLGgpKSl9XG5ULnByb3RvdHlwZS5zPWZ1bmN0aW9uKGIsYSl7dmFyIGM9dGhpcy5hLGQ9dGhpcy5iO3RoaXMuQz1iO2Zvcih2YXIgZj1jLmxlbmd0aC0yNTgsZSxnLGssaDsyNTYhPT0oZT1yYih0aGlzLGIpKTspaWYoMjU2PmUpZD49ZiYmKHRoaXMuYj1kLGM9dGhpcy5mKCksZD10aGlzLmIpLGNbZCsrXT1lO2Vsc2V7Zz1lLTI1NztoPWViW2ddOzA8Z2JbZ10mJihoKz1VKHRoaXMsZ2JbZ10pKTtlPXJiKHRoaXMsYSk7az1pYltlXTswPGtiW2VdJiYoays9VSh0aGlzLGtiW2VdKSk7ZD49ZiYmKHRoaXMuYj1kLGM9dGhpcy5mKCksZD10aGlzLmIpO2Zvcig7aC0tOyljW2RdPWNbZCsrLWtdfWZvcig7ODw9dGhpcy5lOyl0aGlzLmUtPTgsdGhpcy5jLS07dGhpcy5iPWR9O1xuVC5wcm90b3R5cGUuUz1mdW5jdGlvbihiLGEpe3ZhciBjPXRoaXMuYSxkPXRoaXMuYjt0aGlzLkM9Yjtmb3IodmFyIGY9Yy5sZW5ndGgsZSxnLGssaDsyNTYhPT0oZT1yYih0aGlzLGIpKTspaWYoMjU2PmUpZD49ZiYmKGM9dGhpcy5mKCksZj1jLmxlbmd0aCksY1tkKytdPWU7ZWxzZXtnPWUtMjU3O2g9ZWJbZ107MDxnYltnXSYmKGgrPVUodGhpcyxnYltnXSkpO2U9cmIodGhpcyxhKTtrPWliW2VdOzA8a2JbZV0mJihrKz1VKHRoaXMsa2JbZV0pKTtkK2g+ZiYmKGM9dGhpcy5mKCksZj1jLmxlbmd0aCk7Zm9yKDtoLS07KWNbZF09Y1tkKysta119Zm9yKDs4PD10aGlzLmU7KXRoaXMuZS09OCx0aGlzLmMtLTt0aGlzLmI9ZH07XG5ULnByb3RvdHlwZS5mPWZ1bmN0aW9uKCl7dmFyIGI9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKHRoaXMuYi0zMjc2OCksYT10aGlzLmItMzI3NjgsYyxkLGY9dGhpcy5hO2lmKEIpYi5zZXQoZi5zdWJhcnJheSgzMjc2OCxiLmxlbmd0aCkpO2Vsc2V7Yz0wO2ZvcihkPWIubGVuZ3RoO2M8ZDsrK2MpYltjXT1mW2MrMzI3NjhdfXRoaXMucC5wdXNoKGIpO3RoaXMudSs9Yi5sZW5ndGg7aWYoQilmLnNldChmLnN1YmFycmF5KGEsYSszMjc2OCkpO2Vsc2UgZm9yKGM9MDszMjc2OD5jOysrYylmW2NdPWZbYStjXTt0aGlzLmI9MzI3Njg7cmV0dXJuIGZ9O1xuVC5wcm90b3R5cGUuVD1mdW5jdGlvbihiKXt2YXIgYSxjPXRoaXMuaW5wdXQubGVuZ3RoL3RoaXMuYysxfDAsZCxmLGUsZz10aGlzLmlucHV0LGs9dGhpcy5hO2ImJihcIm51bWJlclwiPT09dHlwZW9mIGIuRiYmKGM9Yi5GKSxcIm51bWJlclwiPT09dHlwZW9mIGIuTyYmKGMrPWIuTykpOzI+Yz8oZD0oZy5sZW5ndGgtdGhpcy5jKS90aGlzLkNbMl0sZT0yNTgqKGQvMil8MCxmPWU8ay5sZW5ndGg/ay5sZW5ndGgrZTprLmxlbmd0aDw8MSk6Zj1rLmxlbmd0aCpjO0I/KGE9bmV3IFVpbnQ4QXJyYXkoZiksYS5zZXQoaykpOmE9aztyZXR1cm4gdGhpcy5hPWF9O1xuVC5wcm90b3R5cGUuQj1mdW5jdGlvbigpe3ZhciBiPTAsYT10aGlzLmEsYz10aGlzLnAsZCxmPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KSh0aGlzLnUrKHRoaXMuYi0zMjc2OCkpLGUsZyxrLGg7aWYoMD09PWMubGVuZ3RoKXJldHVybiBCP3RoaXMuYS5zdWJhcnJheSgzMjc2OCx0aGlzLmIpOnRoaXMuYS5zbGljZSgzMjc2OCx0aGlzLmIpO2U9MDtmb3IoZz1jLmxlbmd0aDtlPGc7KytlKXtkPWNbZV07az0wO2ZvcihoPWQubGVuZ3RoO2s8aDsrK2spZltiKytdPWRba119ZT0zMjc2ODtmb3IoZz10aGlzLmI7ZTxnOysrZSlmW2IrK109YVtlXTt0aGlzLnA9W107cmV0dXJuIHRoaXMuYnVmZmVyPWZ9O1xuVC5wcm90b3R5cGUuUT1mdW5jdGlvbigpe3ZhciBiLGE9dGhpcy5iO0I/dGhpcy5MPyhiPW5ldyBVaW50OEFycmF5KGEpLGIuc2V0KHRoaXMuYS5zdWJhcnJheSgwLGEpKSk6Yj10aGlzLmEuc3ViYXJyYXkoMCxhKToodGhpcy5hLmxlbmd0aD5hJiYodGhpcy5hLmxlbmd0aD1hKSxiPXRoaXMuYSk7cmV0dXJuIHRoaXMuYnVmZmVyPWJ9O2Z1bmN0aW9uIHNiKGIpe3RoaXMuaW5wdXQ9Yjt0aGlzLmM9MDt0aGlzLnQ9W107dGhpcy5EPSExfXNiLnByb3RvdHlwZS5XPWZ1bmN0aW9uKCl7dGhpcy5EfHx0aGlzLmgoKTtyZXR1cm4gdGhpcy50LnNsaWNlKCl9O1xuc2IucHJvdG90eXBlLmg9ZnVuY3Rpb24oKXtmb3IodmFyIGI9dGhpcy5pbnB1dC5sZW5ndGg7dGhpcy5jPGI7KXt2YXIgYT1uZXcgUCxjPXQsZD10LGY9dCxlPXQsZz10LGs9dCxoPXQsbD10LHM9dCxuPXRoaXMuaW5wdXQsbT10aGlzLmM7YS5HPW5bbSsrXTthLkg9blttKytdOygzMSE9PWEuR3x8MTM5IT09YS5IKSYmcShFcnJvcihcImludmFsaWQgZmlsZSBzaWduYXR1cmU6XCIrYS5HK1wiLFwiK2EuSCkpO2Euej1uW20rK107c3dpdGNoKGEueil7Y2FzZSA4OmJyZWFrO2RlZmF1bHQ6cShFcnJvcihcInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kOiBcIithLnopKX1hLm49blttKytdO2w9blttKytdfG5bbSsrXTw8OHxuW20rK108PDE2fG5bbSsrXTw8MjQ7YS5ZPW5ldyBEYXRlKDFFMypsKTthLmVhPW5bbSsrXTthLmRhPW5bbSsrXTswPChhLm4mNCkmJihhLiQ9blttKytdfG5bbSsrXTw8OCxtKz1hLiQpO2lmKDA8KGEubiZFYSkpe2g9W107Zm9yKGs9MDswPChnPW5bbSsrXSk7KWhbaysrXT1cblN0cmluZy5mcm9tQ2hhckNvZGUoZyk7YS5uYW1lPWguam9pbihcIlwiKX1pZigwPChhLm4mRmEpKXtoPVtdO2ZvcihrPTA7MDwoZz1uW20rK10pOyloW2srK109U3RyaW5nLmZyb21DaGFyQ29kZShnKTthLkE9aC5qb2luKFwiXCIpfTA8KGEubiZHYSkmJihhLlI9amEobiwwLG0pJjY1NTM1LGEuUiE9PShuW20rK118blttKytdPDw4KSYmcShFcnJvcihcImludmFsaWQgaGVhZGVyIGNyYzE2XCIpKSk7Yz1uW24ubGVuZ3RoLTRdfG5bbi5sZW5ndGgtM108PDh8bltuLmxlbmd0aC0yXTw8MTZ8bltuLmxlbmd0aC0xXTw8MjQ7bi5sZW5ndGgtbS00LTQ8NTEyKmMmJihlPWMpO2Q9bmV3IFQobix7aW5kZXg6bSxidWZmZXJTaXplOmV9KTthLmRhdGE9Zj1kLmgoKTttPWQuYzthLmJhPXM9KG5bbSsrXXxuW20rK108PDh8blttKytdPDwxNnxuW20rK108PDI0KT4+PjA7amEoZix0LHQpIT09cyYmcShFcnJvcihcImludmFsaWQgQ1JDLTMyIGNoZWNrc3VtOiAweFwiK2phKGYsdCx0KS50b1N0cmluZygxNikrXG5cIiAvIDB4XCIrcy50b1N0cmluZygxNikpKTthLmNhPWM9KG5bbSsrXXxuW20rK108PDh8blttKytdPDwxNnxuW20rK108PDI0KT4+PjA7KGYubGVuZ3RoJjQyOTQ5NjcyOTUpIT09YyYmcShFcnJvcihcImludmFsaWQgaW5wdXQgc2l6ZTogXCIrKGYubGVuZ3RoJjQyOTQ5NjcyOTUpK1wiIC8gXCIrYykpO3RoaXMudC5wdXNoKGEpO3RoaXMuYz1tfXRoaXMuRD11O3ZhciBwPXRoaXMudCxyLHYseD0wLFE9MCx5O3I9MDtmb3Iodj1wLmxlbmd0aDtyPHY7KytyKVErPXBbcl0uZGF0YS5sZW5ndGg7aWYoQil7eT1uZXcgVWludDhBcnJheShRKTtmb3Iocj0wO3I8djsrK3IpeS5zZXQocFtyXS5kYXRhLHgpLHgrPXBbcl0uZGF0YS5sZW5ndGh9ZWxzZXt5PVtdO2ZvcihyPTA7cjx2Oysrcil5W3JdPXBbcl0uZGF0YTt5PUFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10seSl9cmV0dXJuIHl9O0EoXCJabGliLkd1bnppcFwiLHNiKTtBKFwiWmxpYi5HdW56aXAucHJvdG90eXBlLmRlY29tcHJlc3NcIixzYi5wcm90b3R5cGUuaCk7QShcIlpsaWIuR3VuemlwLnByb3RvdHlwZS5nZXRNZW1iZXJzXCIsc2IucHJvdG90eXBlLlcpO2Z1bmN0aW9uIHRiKGIpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYil7dmFyIGE9Yi5zcGxpdChcIlwiKSxjLGQ7Yz0wO2ZvcihkPWEubGVuZ3RoO2M8ZDtjKyspYVtjXT0oYVtjXS5jaGFyQ29kZUF0KDApJjI1NSk+Pj4wO2I9YX1mb3IodmFyIGY9MSxlPTAsZz1iLmxlbmd0aCxrLGg9MDswPGc7KXtrPTEwMjQ8Zz8xMDI0Omc7Zy09aztkbyBmKz1iW2grK10sZSs9Zjt3aGlsZSgtLWspO2YlPTY1NTIxO2UlPTY1NTIxfXJldHVybihlPDwxNnxmKT4+PjB9O2Z1bmN0aW9uIHViKGIsYSl7dmFyIGMsZDt0aGlzLmlucHV0PWI7dGhpcy5jPTA7aWYoYXx8IShhPXt9KSlhLmluZGV4JiYodGhpcy5jPWEuaW5kZXgpLGEudmVyaWZ5JiYodGhpcy5aPWEudmVyaWZ5KTtjPWJbdGhpcy5jKytdO2Q9Ylt0aGlzLmMrK107c3dpdGNoKGMmMTUpe2Nhc2UgdmI6dGhpcy5tZXRob2Q9dmI7YnJlYWs7ZGVmYXVsdDpxKEVycm9yKFwidW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gbWV0aG9kXCIpKX0wIT09KChjPDw4KStkKSUzMSYmcShFcnJvcihcImludmFsaWQgZmNoZWNrIGZsYWc6XCIrKChjPDw4KStkKSUzMSkpO2QmMzImJnEoRXJyb3IoXCJmZGljdCBmbGFnIGlzIG5vdCBzdXBwb3J0ZWRcIikpO3RoaXMuSz1uZXcgVChiLHtpbmRleDp0aGlzLmMsYnVmZmVyU2l6ZTphLmJ1ZmZlclNpemUsYnVmZmVyVHlwZTphLmJ1ZmZlclR5cGUscmVzaXplOmEucmVzaXplfSl9XG51Yi5wcm90b3R5cGUuaD1mdW5jdGlvbigpe3ZhciBiPXRoaXMuaW5wdXQsYSxjO2E9dGhpcy5LLmgoKTt0aGlzLmM9dGhpcy5LLmM7dGhpcy5aJiYoYz0oYlt0aGlzLmMrK108PDI0fGJbdGhpcy5jKytdPDwxNnxiW3RoaXMuYysrXTw8OHxiW3RoaXMuYysrXSk+Pj4wLGMhPT10YihhKSYmcShFcnJvcihcImludmFsaWQgYWRsZXItMzIgY2hlY2tzdW1cIikpKTtyZXR1cm4gYX07dmFyIHZiPTg7ZnVuY3Rpb24gd2IoYixhKXt0aGlzLmlucHV0PWI7dGhpcy5hPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KSgzMjc2OCk7dGhpcy5rPVcubzt2YXIgYz17fSxkO2lmKChhfHwhKGE9e30pKSYmXCJudW1iZXJcIj09PXR5cGVvZiBhLmNvbXByZXNzaW9uVHlwZSl0aGlzLms9YS5jb21wcmVzc2lvblR5cGU7Zm9yKGQgaW4gYSljW2RdPWFbZF07Yy5vdXRwdXRCdWZmZXI9dGhpcy5hO3RoaXMuSj1uZXcgbmEodGhpcy5pbnB1dCxjKX12YXIgVz1yYTtcbndiLnByb3RvdHlwZS5nPWZ1bmN0aW9uKCl7dmFyIGIsYSxjLGQsZixlLGcsaz0wO2c9dGhpcy5hO2I9dmI7c3dpdGNoKGIpe2Nhc2UgdmI6YT1NYXRoLkxPRzJFKk1hdGgubG9nKDMyNzY4KS04O2JyZWFrO2RlZmF1bHQ6cShFcnJvcihcImludmFsaWQgY29tcHJlc3Npb24gbWV0aG9kXCIpKX1jPWE8PDR8YjtnW2srK109Yztzd2l0Y2goYil7Y2FzZSB2Yjpzd2l0Y2godGhpcy5rKXtjYXNlIFcuTk9ORTpmPTA7YnJlYWs7Y2FzZSBXLnY6Zj0xO2JyZWFrO2Nhc2UgVy5vOmY9MjticmVhaztkZWZhdWx0OnEoRXJyb3IoXCJ1bnN1cHBvcnRlZCBjb21wcmVzc2lvbiB0eXBlXCIpKX1icmVhaztkZWZhdWx0OnEoRXJyb3IoXCJpbnZhbGlkIGNvbXByZXNzaW9uIG1ldGhvZFwiKSl9ZD1mPDw2fDA7Z1trKytdPWR8MzEtKDI1NipjK2QpJTMxO2U9dGIodGhpcy5pbnB1dCk7dGhpcy5KLmI9aztnPXRoaXMuSi5nKCk7az1nLmxlbmd0aDtCJiYoZz1uZXcgVWludDhBcnJheShnLmJ1ZmZlciksZy5sZW5ndGg8PVxuays0JiYodGhpcy5hPW5ldyBVaW50OEFycmF5KGcubGVuZ3RoKzQpLHRoaXMuYS5zZXQoZyksZz10aGlzLmEpLGc9Zy5zdWJhcnJheSgwLGsrNCkpO2dbaysrXT1lPj4yNCYyNTU7Z1trKytdPWU+PjE2JjI1NTtnW2srK109ZT4+OCYyNTU7Z1trKytdPWUmMjU1O3JldHVybiBnfTtmdW5jdGlvbiB4YihiLGEpe3ZhciBjLGQsZixlO2lmKE9iamVjdC5rZXlzKWM9T2JqZWN0LmtleXMoYSk7ZWxzZSBmb3IoZCBpbiBjPVtdLGY9MCxhKWNbZisrXT1kO2Y9MDtmb3IoZT1jLmxlbmd0aDtmPGU7KytmKWQ9Y1tmXSxBKGIrXCIuXCIrZCxhW2RdKX07QShcIlpsaWIuSW5mbGF0ZVwiLHViKTtBKFwiWmxpYi5JbmZsYXRlLnByb3RvdHlwZS5kZWNvbXByZXNzXCIsdWIucHJvdG90eXBlLmgpO3hiKFwiWmxpYi5JbmZsYXRlLkJ1ZmZlclR5cGVcIix7QURBUFRJVkU6WWEuTSxCTE9DSzpZYS5OfSk7QShcIlpsaWIuRGVmbGF0ZVwiLHdiKTtBKFwiWmxpYi5EZWZsYXRlLmNvbXByZXNzXCIsZnVuY3Rpb24oYixhKXtyZXR1cm4obmV3IHdiKGIsYSkpLmcoKX0pO0EoXCJabGliLkRlZmxhdGUucHJvdG90eXBlLmNvbXByZXNzXCIsd2IucHJvdG90eXBlLmcpO3hiKFwiWmxpYi5EZWZsYXRlLkNvbXByZXNzaW9uVHlwZVwiLHtOT05FOlcuTk9ORSxGSVhFRDpXLnYsRFlOQU1JQzpXLm99KTt9KS5jYWxsKHRoaXMpOyAvL0Agc291cmNlTWFwcGluZ1VSTD16bGliX2FuZF9nemlwLm1pbi5qcy5tYXBcblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/vendor/zlib_and_gzip.min.js\n");

/***/ }),

/***/ "./test.js":
/*!*****************!*\
  !*** ./test.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _image_gen = __webpack_require__(/*! ./src/node/image_gen.js */ \"./src/node/image_gen.js\");\n\nvar tracks = [{ type: \"ruler\" }, { url: \"https://s3.amazonaws.com/igv.broadinstitute.org/annotations/hg19/genes/refGene.hg19.bed.gz\" }, { url: \"http://userweb.molbiol.ox.ac.uk/public/lanceotron/hmocbVPzOROlaVRzBQJBtuDGS/100.bw\", color: \"red\" }];\nvar a = new _image_gen.MLVImageGen(tracks, {\n\tlocations: [[\"chr16\", 100000, 500000, \"c:\\\\dev\\\\MLVPanel\\\\test1.png\"], [\"chr16\", 500000, 1000000, \"c:\\\\dev\\\\MLVPanel\\\\test2.png\"], [\"chr16\", 1000000, 1500000, \"c:\\\\dev\\\\MLVPanel\\\\test3.png\"]]\n});\na.drawImages();\n\nvar b = new _image_gen.MLVImageGen(tracks, {\n\tlocations: [[\"chr16\", 100000, 500000, \"c:\\\\dev\\\\MLVPanel\\\\test4.png\"], [\"chr16\", 500000, 1000000, \"c:\\\\dev\\\\MLVPanel\\\\test5.png\"], [\"chr16\", 1000000, 1500000, \"c:\\\\dev\\\\MLVPanel\\\\test6.png\"]]\n});\nb.drawImages();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi90ZXN0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3Rlc3QuanM/OWUwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge01MVkltYWdlR2VufSBmcm9tIFwiLi9zcmMvbm9kZS9pbWFnZV9nZW4uanNcIjtcclxuXHJcblxyXG5sZXQgdHJhY2tzPSBbe3R5cGU6XCJydWxlclwifSx7dXJsOlwiaHR0cHM6Ly9zMy5hbWF6b25hd3MuY29tL2lndi5icm9hZGluc3RpdHV0ZS5vcmcvYW5ub3RhdGlvbnMvaGcxOS9nZW5lcy9yZWZHZW5lLmhnMTkuYmVkLmd6XCJ9LFxyXG57dXJsOlwiaHR0cDovL3VzZXJ3ZWIubW9sYmlvbC5veC5hYy51ay9wdWJsaWMvbGFuY2VvdHJvbi9obW9jYlZQek9ST2xhVlJ6QlFKQnR1REdTLzEwMC5id1wiLGNvbG9yOlwicmVkXCJ9XTtcclxubGV0IGEgPSBuZXcgTUxWSW1hZ2VHZW4odHJhY2tzLHtcclxuXHRsb2NhdGlvbnM6W1xyXG5cdFx0W1wiY2hyMTZcIiwxMDAwMDAsNTAwMDAwLFwiYzpcXFxcZGV2XFxcXE1MVlBhbmVsXFxcXHRlc3QxLnBuZ1wiXSxcclxuXHRcdFtcImNocjE2XCIsNTAwMDAwLDEwMDAwMDAsXCJjOlxcXFxkZXZcXFxcTUxWUGFuZWxcXFxcdGVzdDIucG5nXCJdLFxyXG5cdFx0W1wiY2hyMTZcIiwxMDAwMDAwLDE1MDAwMDAsXCJjOlxcXFxkZXZcXFxcTUxWUGFuZWxcXFxcdGVzdDMucG5nXCJdXHJcblx0XVxyXG59KTtcclxuYS5kcmF3SW1hZ2VzKCk7XHJcblxyXG5sZXQgYiA9IG5ldyBNTFZJbWFnZUdlbih0cmFja3Mse1xyXG5cdGxvY2F0aW9uczpbXHJcblx0XHRbXCJjaHIxNlwiLDEwMDAwMCw1MDAwMDAsXCJjOlxcXFxkZXZcXFxcTUxWUGFuZWxcXFxcdGVzdDQucG5nXCJdLFxyXG5cdFx0W1wiY2hyMTZcIiw1MDAwMDAsMTAwMDAwMCxcImM6XFxcXGRldlxcXFxNTFZQYW5lbFxcXFx0ZXN0NS5wbmdcIl0sXHJcblx0XHRbXCJjaHIxNlwiLDEwMDAwMDAsMTUwMDAwMCxcImM6XFxcXGRldlxcXFxNTFZQYW5lbFxcXFx0ZXN0Ni5wbmdcIl1cclxuXHRdXHJcbn0pO1xyXG5iLmRyYXdJbWFnZXMoKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFPQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./test.js\n");

/***/ }),

/***/ "canvas":
/*!*************************!*\
  !*** external "canvas" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"canvas\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FudmFzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiY2FudmFzXCI/ZDFlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjYW52YXNcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///canvas\n");

/***/ }),

/***/ "extend":
/*!*************************!*\
  !*** external "extend" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"extend\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0ZW5kLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZXh0ZW5kXCI/MGU3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJleHRlbmRcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///extend\n");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJmc1wiP2E0MGQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///fs\n");

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jquery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"jquery\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianF1ZXJ5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwianF1ZXJ5XCI/OGY4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJqcXVlcnlcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///jquery\n");

/***/ }),

/***/ "xhr2":
/*!***********************!*\
  !*** external "xhr2" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"xhr2\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieGhyMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInhocjJcIj85YTkwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInhocjJcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///xhr2\n");

/***/ })

/******/ });